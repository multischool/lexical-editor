import t,{createContext as e,useContext as n,useReducer as o,useEffect as r,useDebugValue as i,useCallback as u}from"react";import{getDefaultStore as s}from"./vanilla.mjs.js";const a=e(void 0),c=t=>{const e=n(a);return(null==t?void 0:t.store)||e||s()},l=t=>"function"==typeof(null==t?void 0:t.then),f=t=>{t.status="pending",t.then((e=>{t.status="fulfilled",t.value=e}),(e=>{t.status="rejected",t.reason=e}))},d=t.use||(t=>{if("pending"===t.status)throw t;if("fulfilled"===t.status)return t.value;throw"rejected"===t.status?t.reason:(f(t),t)}),m=new WeakMap,p=t=>{let e=m.get(t);return e||(e=new Promise(((n,o)=>{let r=t;const i=t=>e=>{r===t&&n(e)},u=t=>e=>{r===t&&o(e)},s=t=>{"onCancel"in t&&"function"==typeof t.onCancel&&t.onCancel((o=>{if("production"!==(import.meta.env?import.meta.env.MODE:void 0)&&o===t)throw new Error("[Bug] p is not updated even after cancelation");l(o)?(m.set(o,e),r=o,o.then(i(o),u(o)),s(o)):n(o)}))};t.then(i(t),u(t)),s(t)})),m.set(t,e)),e};function v(t,e){const n=c(e),[[u,s,a],m]=o((e=>{const o=n.get(t);return Object.is(e[0],o)&&e[1]===n&&e[2]===t?e:[o,n,t]}),void 0,(()=>[n.get(t),n,t]));let v=u;s===n&&a===t||(m(),v=n.get(t));const w=null==e?void 0:e.delay;if(r((()=>{const e=n.sub(t,(()=>{if("number"==typeof w){const e=n.get(t);return l(e)&&f(p(e)),void setTimeout(m,w)}m()}));return m(),e}),[n,t,w]),i(v),l(v)){const t=p(v);return d(t)}return v}function w(t,e){const n=c(e);return u(((...e)=>{if("production"!==(import.meta.env?import.meta.env.MODE:void 0)&&!("write"in t))throw new Error("not writable atom");return n.set(t,...e)}),[n,t])}function g(t,e){return[v(t,e),w(t,e)]}export{g as useAtom,v as useAtomValue,w as useSetAtom,c as useStore};
//# sourceMappingURL=react.mjs.js.map
