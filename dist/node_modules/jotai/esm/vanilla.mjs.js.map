{"version":3,"file":"vanilla.mjs.js","sources":["../../../../node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst isPendingPromise = (value) => {\n  var _a;\n  return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? void 0 : _a[1]);\n};\nconst cancelPromise = (promise, nextValue) => {\n  const promiseState = cancelablePromiseMap.get(promise);\n  if (promiseState) {\n    promiseState[1] = true;\n    promiseState[0].forEach((fn) => fn(nextValue));\n  } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    throw new Error(\"[Bug] cancelable promise not found\");\n  }\n};\nconst patchPromiseForCancelability = (promise) => {\n  if (cancelablePromiseMap.has(promise)) {\n    return;\n  }\n  const promiseState = [/* @__PURE__ */ new Set(), false];\n  cancelablePromiseMap.set(promise, promiseState);\n  const settle = () => {\n    promiseState[1] = true;\n  };\n  promise.then(settle, settle);\n  promise.onCancel = (fn) => {\n    promiseState[0].add(fn);\n  };\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst addDependency = (batch, atom, atomState, a, aState) => {\n  var _a;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a === atom) {\n    throw new Error(\"[Bug] atom cannot depend on itself\");\n  }\n  atomState.d.set(a, aState.n);\n  if (isPendingPromise(atomState.v)) {\n    addPendingPromiseToDependency(atom, atomState.v, aState);\n  }\n  (_a = aState.m) == null ? void 0 : _a.t.add(atom);\n  if (batch) {\n    addBatchAtomDependent(batch, a, atom);\n  }\n};\nconst createBatch = () => ({\n  D: /* @__PURE__ */ new Map(),\n  H: /* @__PURE__ */ new Set(),\n  M: /* @__PURE__ */ new Set(),\n  L: /* @__PURE__ */ new Set()\n});\nconst addBatchFunc = (batch, priority, fn) => {\n  batch[priority].add(fn);\n};\nconst registerBatchAtom = (batch, atom, atomState) => {\n  if (!batch.D.has(atom)) {\n    batch.D.set(atom, /* @__PURE__ */ new Set());\n    addBatchFunc(batch, \"M\", () => {\n      var _a;\n      (_a = atomState.m) == null ? void 0 : _a.l.forEach((listener) => addBatchFunc(batch, \"M\", listener));\n    });\n  }\n};\nconst addBatchAtomDependent = (batch, atom, dependent) => {\n  const dependents = batch.D.get(atom);\n  if (dependents) {\n    dependents.add(dependent);\n  }\n};\nconst getBatchAtomDependents = (batch, atom) => batch.D.get(atom);\nconst flushBatch = (batch) => {\n  let error;\n  let hasError = false;\n  const call = (fn) => {\n    try {\n      fn();\n    } catch (e) {\n      if (!hasError) {\n        error = e;\n        hasError = true;\n      }\n    }\n  };\n  while (batch.H.size || batch.M.size || batch.L.size) {\n    batch.D.clear();\n    batch.H.forEach(call);\n    batch.H.clear();\n    batch.M.forEach(call);\n    batch.M.clear();\n    batch.L.forEach(call);\n    batch.L.clear();\n  }\n  if (hasError) {\n    throw error;\n  }\n};\nconst buildStore = (...[getAtomState, atomRead, atomWrite, atomOnMount]) => {\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;\n    if (isPromiseLike(valueOrPromise)) {\n      patchPromiseForCancelability(valueOrPromise);\n      for (const a of atomState.d.keys()) {\n        addPendingPromiseToDependency(atom, valueOrPromise, getAtomState(a));\n      }\n      atomState.v = valueOrPromise;\n    } else {\n      atomState.v = valueOrPromise;\n    }\n    delete atomState.e;\n    delete atomState.x;\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n      if (pendingPromise) {\n        cancelPromise(pendingPromise, valueOrPromise);\n      }\n    }\n  };\n  const readAtomState = (batch, atom) => {\n    var _a;\n    const atomState = getAtomState(atom);\n    if (isAtomStateInitialized(atomState)) {\n      if (atomState.m && !atomState.x) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(batch, a).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(batch, a);\n      try {\n        return returnAtomValue(aState);\n      } finally {\n        if (isSync) {\n          addDependency(batch, atom, atomState, a, aState);\n        } else {\n          const batch2 = createBatch();\n          addDependency(batch2, atom, atomState, a, aState);\n          mountDependencies(batch2, atom, atomState);\n          flushBatch(batch2);\n        }\n      }\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atomRead(atom, getter, options);\n      setAtomStateValueOrPromise(atom, atomState, valueOrPromise);\n      if (isPromiseLike(valueOrPromise)) {\n        (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n        const complete = () => {\n          if (atomState.m) {\n            const batch2 = createBatch();\n            mountDependencies(batch2, atom, atomState);\n            flushBatch(batch2);\n          }\n        };\n        valueOrPromise.then(complete, complete);\n      }\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      delete atomState.x;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));\n  const getMountedOrBatchDependents = (batch, atom, atomState) => {\n    var _a, _b;\n    const dependents = /* @__PURE__ */ new Map();\n    for (const a of ((_a = atomState.m) == null ? void 0 : _a.t) || []) {\n      const aState = getAtomState(a);\n      if (aState.m) {\n        dependents.set(a, aState);\n      }\n    }\n    for (const atomWithPendingPromise of atomState.p) {\n      dependents.set(\n        atomWithPendingPromise,\n        getAtomState(atomWithPendingPromise)\n      );\n    }\n    (_b = getBatchAtomDependents(batch, atom)) == null ? void 0 : _b.forEach((dependent) => {\n      dependents.set(dependent, getAtomState(dependent));\n    });\n    return dependents;\n  };\n  const recomputeDependents = (batch, atom, atomState) => {\n    const topSortedReversed = [];\n    const visiting = /* @__PURE__ */ new Set();\n    const visited = /* @__PURE__ */ new Set();\n    const stack = [[atom, atomState]];\n    while (stack.length > 0) {\n      const [a, aState] = stack[stack.length - 1];\n      if (visited.has(a)) {\n        stack.pop();\n        continue;\n      }\n      if (visiting.has(a)) {\n        topSortedReversed.push([a, aState, aState.n]);\n        visited.add(a);\n        aState.x = true;\n        stack.pop();\n        continue;\n      }\n      visiting.add(a);\n      for (const [d, s] of getMountedOrBatchDependents(batch, a, aState)) {\n        if (a !== d && !visiting.has(d)) {\n          stack.push([d, s]);\n        }\n      }\n    }\n    addBatchFunc(batch, \"H\", () => {\n      const changedAtoms = /* @__PURE__ */ new Set([atom]);\n      for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n        const [a, aState, prevEpochNumber] = topSortedReversed[i];\n        let hasChangedDeps = false;\n        for (const dep of aState.d.keys()) {\n          if (dep !== a && changedAtoms.has(dep)) {\n            hasChangedDeps = true;\n            break;\n          }\n        }\n        if (hasChangedDeps) {\n          readAtomState(batch, a);\n          mountDependencies(batch, a, aState);\n          if (prevEpochNumber !== aState.n) {\n            registerBatchAtom(batch, a, aState);\n            changedAtoms.add(a);\n          }\n        }\n        delete aState.x;\n      }\n    });\n  };\n  const writeAtomState = (batch, atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(batch, a));\n    const setter = (a, ...args2) => {\n      const aState = getAtomState(a);\n      try {\n        if (isSelfAtom(atom, a)) {\n          if (!hasInitialValue(a)) {\n            throw new Error(\"atom not writable\");\n          }\n          const prevEpochNumber = aState.n;\n          const v = args2[0];\n          setAtomStateValueOrPromise(a, aState, v);\n          mountDependencies(batch, a, aState);\n          if (prevEpochNumber !== aState.n) {\n            registerBatchAtom(batch, a, aState);\n            recomputeDependents(batch, a, aState);\n          }\n          return void 0;\n        } else {\n          return writeAtomState(batch, a, ...args2);\n        }\n      } finally {\n        if (!isSync) {\n          flushBatch(batch);\n        }\n      }\n    };\n    try {\n      return atomWrite(atom, getter, setter, ...args);\n    } finally {\n      isSync = false;\n    }\n  };\n  const writeAtom = (atom, ...args) => {\n    const batch = createBatch();\n    try {\n      return writeAtomState(batch, atom, ...args);\n    } finally {\n      flushBatch(batch);\n    }\n  };\n  const mountDependencies = (batch, atom, atomState) => {\n    if (atomState.m && !isPendingPromise(atomState.v)) {\n      for (const a of atomState.d.keys()) {\n        if (!atomState.m.d.has(a)) {\n          const aMounted = mountAtom(batch, a, getAtomState(a));\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(batch, a, getAtomState(a));\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (batch, atom, atomState) => {\n    if (!atomState.m) {\n      readAtomState(batch, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(batch, a, getAtomState(a));\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      if (isActuallyWritableAtom(atom)) {\n        const mounted = atomState.m;\n        let setAtom;\n        const createInvocationContext = (batch2, fn) => {\n          let isSync = true;\n          setAtom = (...args) => {\n            try {\n              return writeAtomState(batch2, atom, ...args);\n            } finally {\n              if (!isSync) {\n                flushBatch(batch2);\n              }\n            }\n          };\n          try {\n            return fn();\n          } finally {\n            isSync = false;\n          }\n        };\n        addBatchFunc(batch, \"L\", () => {\n          const onUnmount = createInvocationContext(\n            batch,\n            () => atomOnMount(atom, (...args) => setAtom(...args))\n          );\n          if (onUnmount) {\n            mounted.u = (batch2) => createInvocationContext(batch2, onUnmount);\n          }\n        });\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (batch, atom, atomState) => {\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a;\n      return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        addBatchFunc(batch, \"L\", () => onUnmount(batch));\n      }\n      delete atomState.m;\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(batch, a, getAtomState(a));\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      return void 0;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const batch = createBatch();\n    const atomState = getAtomState(atom);\n    const mounted = mountAtom(batch, atom, atomState);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    flushBatch(batch);\n    return () => {\n      listeners.delete(listener);\n      const batch2 = createBatch();\n      unmountAtom(batch2, atom, atomState);\n      flushBatch(batch2);\n    };\n  };\n  const unstable_derive = (fn) => buildStore(...fn(getAtomState, atomRead, atomWrite, atomOnMount));\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom,\n    unstable_derive\n  };\n  return store;\n};\nconst deriveDevStoreRev4 = (store) => {\n  const proxyAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const debugMountedAtoms = /* @__PURE__ */ new Set();\n  let savedGetAtomState;\n  let inRestoreAtom = 0;\n  const derivedStore = store.unstable_derive(\n    (getAtomState, atomRead, atomWrite, atomOnMount) => {\n      savedGetAtomState = getAtomState;\n      return [\n        (atom) => {\n          let proxyAtomState = proxyAtomStateMap.get(atom);\n          if (!proxyAtomState) {\n            const atomState = getAtomState(atom);\n            proxyAtomState = new Proxy(atomState, {\n              set(target, prop, value) {\n                if (prop === \"m\") {\n                  debugMountedAtoms.add(atom);\n                }\n                return Reflect.set(target, prop, value);\n              },\n              deleteProperty(target, prop) {\n                if (prop === \"m\") {\n                  debugMountedAtoms.delete(atom);\n                }\n                return Reflect.deleteProperty(target, prop);\n              }\n            });\n            proxyAtomStateMap.set(atom, proxyAtomState);\n          }\n          return proxyAtomState;\n        },\n        atomRead,\n        (atom, getter, setter, ...args) => {\n          if (inRestoreAtom) {\n            return setter(atom, ...args);\n          }\n          return atomWrite(atom, getter, setter, ...args);\n        },\n        atomOnMount\n      ];\n    }\n  );\n  const savedStoreSet = derivedStore.set;\n  const devStore = {\n    // store dev methods (these are tentative and subject to change without notice)\n    dev4_get_internal_weak_map: () => ({\n      get: (atom) => {\n        const atomState = savedGetAtomState(atom);\n        if (atomState.n === 0) {\n          return void 0;\n        }\n        return atomState;\n      }\n    }),\n    dev4_get_mounted_atoms: () => debugMountedAtoms,\n    dev4_restore_atoms: (values) => {\n      const restoreAtom = {\n        read: () => null,\n        write: (_get, set) => {\n          ++inRestoreAtom;\n          try {\n            for (const [atom, value] of values) {\n              if (hasInitialValue(atom)) {\n                set(atom, value);\n              }\n            }\n          } finally {\n            --inRestoreAtom;\n          }\n        }\n      };\n      savedStoreSet(restoreAtom);\n    }\n  };\n  return Object.assign(derivedStore, devStore);\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const getAtomState = (atom) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n      throw new Error(\"Atom is undefined or null\");\n    }\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n    }\n    return atomState;\n  };\n  const store = buildStore(\n    getAtomState,\n    (atom, ...params) => atom.read(...params),\n    (atom, ...params) => atom.write(...params),\n    (atom, ...params) => {\n      var _a;\n      return (_a = atom.onMount) == null ? void 0 : _a.call(atom, ...params);\n    }\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return deriveDevStoreRev4(store);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"names":["isSelfAtom","atom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","write","cancelablePromiseMap","WeakMap","isPendingPromise","value","_a","isPromiseLike","get","x","then","isAtomStateInitialized","atomState","returnAtomValue","e","env","MODE","Error","v","addPendingPromiseToDependency","promise","dependencyAtomState","p","has","add","delete","addDependency","batch","aState","d","set","n","m","t","addBatchAtomDependent","createBatch","D","Map","H","Set","M","L","addBatchFunc","priority","fn","registerBatchAtom","l","forEach","listener","dependent","dependents","flushBatch","error","hasError","call","size","clear","buildStore","getAtomState","atomRead","atomWrite","atomOnMount","setAtomStateValueOrPromise","valueOrPromise","hasPrevValue","prevValue","pendingPromise","promiseState","settle","onCancel","patchPromiseForCancelability","keys","Object","is","nextValue","cancelPromise","readAtomState","Array","from","every","isSync","getter","aState2","init","batch2","mountDependencies","controller","setSelf","options","signal","AbortController","console","warn","args","writeAtom","abort","complete","getMountedOrBatchDependents","_b","atomWithPendingPromise","getBatchAtomDependents","writeAtomState","setter","args2","prevEpochNumber","topSortedReversed","visiting","visited","stack","length","pop","push","s","changedAtoms","i","hasChangedDeps","dep","recomputeDependents","mountAtom","aMounted","unmountAtom","mounted","setAtom","createInvocationContext","onUnmount","u","some","sub","listeners","unstable_derive","createStore","atomStateMap","store","params","read","onMount","proxyAtomStateMap","debugMountedAtoms","savedGetAtomState","inRestoreAtom","derivedStore","proxyAtomState","Proxy","target","prop","Reflect","deleteProperty","savedStoreSet","devStore","dev4_get_internal_weak_map","dev4_get_mounted_atoms","dev4_restore_atoms","values","_get","assign","deriveDevStoreRev4","defaultStore","getDefaultStore","globalThis","__JOTAI_DEFAULT_STORE__"],"mappings":"AA8BA,MAAMA,EAAa,CAACC,EAAMC,IAAMD,EAAKE,YAAcF,EAAKE,YAAYD,GAAKA,IAAMD,EACzEG,EAAmBH,GAAS,SAAUA,EACtCI,EAA0BJ,KAAWA,EAAKK,MAC1CC,EAAuC,IAAIC,QAC3CC,EAAoBC,IACxB,IAAIC,EACJ,OAAOC,EAAcF,MAAsD,OAAzCC,EAAKJ,EAAqBM,IAAIH,SAAkB,EAASC,EAAG,GAAG,EAyB7FC,EAAiBE,GAA+C,mBAA5B,MAALA,OAAY,EAASA,EAAEC,MACtDC,EAA0BC,GAAc,MAAOA,GAAa,MAAOA,EACnEC,EAAmBD,IACvB,GAAI,MAAOA,EACT,MAAMA,EAAUE,EAElB,GAA0D,4BAAzCC,gBAAkBA,IAAIC,UAAO,MAA8B,MAAOJ,GACjF,MAAM,IAAIK,MAAM,uCAElB,OAAOL,EAAUM,CAAC,EAEdC,EAAgC,CAACvB,EAAMwB,EAASC,KAC/CA,EAAoBC,EAAEC,IAAI3B,KAC7ByB,EAAoBC,EAAEE,IAAI5B,GAC1BwB,EAAQV,MACN,KACEW,EAAoBC,EAAEG,OAAO7B,EAAK,IAEpC,KACEyB,EAAoBC,EAAEG,OAAO7B,EAAK,IAGvC,EAEG8B,EAAgB,CAACC,EAAO/B,EAAMgB,EAAWf,EAAG+B,KAChD,IAAItB,EACJ,GAA0D,4BAAzCS,gBAAkBA,IAAIC,UAAO,IAA4BnB,IAAMD,EAC9E,MAAM,IAAIqB,MAAM,sCAElBL,EAAUiB,EAAEC,IAAIjC,EAAG+B,EAAOG,GACtB3B,EAAiBQ,EAAUM,IAC7BC,EAA8BvB,EAAMgB,EAAUM,EAAGU,GAEhC,OAAlBtB,EAAKsB,EAAOI,IAAsB1B,EAAG2B,EAAET,IAAI5B,GACxC+B,GACFO,EAAsBP,EAAO9B,EAAGD,EACjC,EAEGuC,EAAc,KAAO,CACzBC,EAAmB,IAAIC,IACvBC,EAAmB,IAAIC,IACvBC,EAAmB,IAAID,IACvBE,EAAmB,IAAIF,MAEnBG,EAAe,CAACf,EAAOgB,EAAUC,KACrCjB,EAAMgB,GAAUnB,IAAIoB,EAAG,EAEnBC,EAAoB,CAAClB,EAAO/B,EAAMgB,KACjCe,EAAMS,EAAEb,IAAI3B,KACf+B,EAAMS,EAAEN,IAAIlC,EAAsB,IAAI2C,KACtCG,EAAaf,EAAO,KAAK,KACvB,IAAIrB,EACkB,OAArBA,EAAKM,EAAUoB,IAAsB1B,EAAGwC,EAAEC,SAASC,GAAaN,EAAaf,EAAO,IAAKqB,IAAU,IAEvG,EAEGd,EAAwB,CAACP,EAAO/B,EAAMqD,KAC1C,MAAMC,EAAavB,EAAMS,EAAE5B,IAAIZ,GAC3BsD,GACFA,EAAW1B,IAAIyB,EAChB,EAGGE,EAAcxB,IAClB,IAAIyB,EACAC,GAAW,EACf,MAAMC,EAAQV,IACZ,IACEA,GACD,CAAC,MAAO9B,GACFuC,IACHD,EAAQtC,EACRuC,GAAW,EAEd,GAEH,KAAO1B,EAAMW,EAAEiB,MAAQ5B,EAAMa,EAAEe,MAAQ5B,EAAMc,EAAEc,MAC7C5B,EAAMS,EAAEoB,QACR7B,EAAMW,EAAES,QAAQO,GAChB3B,EAAMW,EAAEkB,QACR7B,EAAMa,EAAEO,QAAQO,GAChB3B,EAAMa,EAAEgB,QACR7B,EAAMc,EAAEM,QAAQO,GAChB3B,EAAMc,EAAEe,QAEV,GAAIH,EACF,MAAMD,CACP,EAEGK,EAAa,KAAKC,EAAcC,EAAUC,EAAWC,MACzD,MAAMC,EAA6B,CAAClE,EAAMgB,EAAWmD,KACnD,MAAMC,EAAe,MAAOpD,EACtBqD,EAAYrD,EAAUM,EACtBgD,EAAiB9D,EAAiBQ,EAAUM,GAAKN,EAAUM,EAAI,KACrE,GAAIX,EAAcwD,GAAiB,CA5GF,CAAC3C,IACpC,GAAIlB,EAAqBqB,IAAIH,GAC3B,OAEF,MAAM+C,EAAe,CAAiB,IAAI5B,KAAO,GACjDrC,EAAqB4B,IAAIV,EAAS+C,GAClC,MAAMC,EAAS,KACbD,EAAa,IAAK,CAAI,EAExB/C,EAAQV,KAAK0D,EAAQA,GACrBhD,EAAQiD,SAAYzB,IAClBuB,EAAa,GAAG3C,IAAIoB,EAAG,CACxB,EAiGG0B,CAA6BP,GAC7B,IAAK,MAAMlE,KAAKe,EAAUiB,EAAE0C,OAC1BpD,EAA8BvB,EAAMmE,EAAgBL,EAAa7D,IAEnEe,EAAUM,EAAI6C,CACpB,MACMnD,EAAUM,EAAI6C,SAETnD,EAAUE,SACVF,EAAUH,EACZuD,GAAiBQ,OAAOC,GAAGR,EAAWrD,EAAUM,OACjDN,EAAUmB,EACRmC,GAlIY,EAAC9C,EAASsD,KAC9B,MAAMP,EAAejE,EAAqBM,IAAIY,GAC9C,GAAI+C,EACFA,EAAa,IAAK,EAClBA,EAAa,GAAGpB,SAASH,GAAOA,EAAG8B,UAC9B,GAA0D,4BAAzC3D,gBAAkBA,IAAIC,UAAO,GACnD,MAAM,IAAIC,MAAM,qCACjB,EA4HK0D,CAAcT,EAAgBH,GAEjC,EAEGa,EAAgB,CAACjD,EAAO/B,KAC5B,IAAIU,EACJ,MAAMM,EAAY8C,EAAa9D,GAC/B,GAAIe,EAAuBC,GAAY,CACrC,GAAIA,EAAUoB,IAAMpB,EAAUH,EAC5B,OAAOG,EAET,GAAIiE,MAAMC,KAAKlE,EAAUiB,GAAGkD,OAC1B,EAAElF,EAAGkC,KAGH6C,EAAcjD,EAAO9B,GAAGkC,IAAMA,IAGhC,OAAOnB,CAEV,CACDA,EAAUiB,EAAE2B,QACZ,IAAIwB,GAAS,EACb,MAAMC,EAAUpF,IACd,GAAIF,EAAWC,EAAMC,GAAI,CACvB,MAAMqF,EAAUxB,EAAa7D,GAC7B,IAAKc,EAAuBuE,GAAU,CACpC,IAAInF,EAAgBF,GAGlB,MAAM,IAAIoB,MAAM,gBAFhB6C,EAA2BjE,EAAGqF,EAASrF,EAAEsF,KAI5C,CACD,OAAOtE,EAAgBqE,EACxB,CACD,MAAMtD,EAASgD,EAAcjD,EAAO9B,GACpC,IACE,OAAOgB,EAAgBe,EAC/B,CAAgB,QACR,GAAIoD,EACFtD,EAAcC,EAAO/B,EAAMgB,EAAWf,EAAG+B,OACpC,CACL,MAAMwD,EAASjD,IACfT,EAAc0D,EAAQxF,EAAMgB,EAAWf,EAAG+B,GAC1CyD,EAAkBD,EAAQxF,EAAMgB,GAChCuC,EAAWiC,EACZ,CACF,GAEH,IAAIE,EACAC,EACJ,MAAMC,EAAU,CACd,UAAIC,GAIF,OAHKH,IACHA,EAAa,IAAII,iBAEZJ,EAAWG,MACnB,EACD,WAAIF,GAcF,MAb0D,4BAAzCxE,gBAAkBA,IAAIC,UAAO,IAA6BhB,EAAuBJ,IAChG+F,QAAQC,KAAK,wDAEVL,GAAWvF,EAAuBJ,KACrC2F,EAAU,IAAIM,KAIZ,GAH0D,4BAAzC9E,gBAAkBA,IAAIC,UAAO,IAA4BgE,GACxEW,QAAQC,KAAK,8CAEVZ,EACH,OAAOc,EAAUlG,KAASiG,EAC3B,GAGEN,CACR,GAEH,IACE,MAAMxB,EAAiBJ,EAAS/D,EAAMqF,EAAQO,GAE9C,GADA1B,EAA2BlE,EAAMgB,EAAWmD,GACxCxD,EAAcwD,GAAiB,CACC,OAAjCzD,EAAKyD,EAAeM,WAA6B/D,EAAGgD,KAAKS,GAAgB,IAAoB,MAAduB,OAAqB,EAASA,EAAWS,UACzH,MAAMC,EAAW,KACf,GAAIpF,EAAUoB,EAAG,CACf,MAAMoD,EAASjD,IACfkD,EAAkBD,EAAQxF,EAAMgB,GAChCuC,EAAWiC,EACZ,GAEHrB,EAAerD,KAAKsF,EAAUA,EAC/B,CACD,OAAOpF,CACR,CAAC,MAAOwC,GAKP,cAJOxC,EAAUM,EACjBN,EAAUE,EAAIsC,SACPxC,EAAUH,IACfG,EAAUmB,EACLnB,CACb,CAAc,QACRoE,GAAS,CACV,GAGGiB,EAA8B,CAACtE,EAAO/B,EAAMgB,KAChD,IAAIN,EAAI4F,EACR,MAAMhD,EAA6B,IAAIb,IACvC,IAAK,MAAMxC,KAA4B,OAArBS,EAAKM,EAAUoB,QAAa,EAAS1B,EAAG2B,IAAM,GAAI,CAClE,MAAML,EAAS8B,EAAa7D,GACxB+B,EAAOI,GACTkB,EAAWpB,IAAIjC,EAAG+B,EAErB,CACD,IAAK,MAAMuE,KAA0BvF,EAAUU,EAC7C4B,EAAWpB,IACTqE,EACAzC,EAAayC,IAMjB,OAH8C,OAA7CD,EAlK0B,EAACvE,EAAO/B,IAAS+B,EAAMS,EAAE5B,IAAIZ,GAkKlDwG,CAAuBzE,EAAO/B,KAA0BsG,EAAGnD,SAASE,IACxEC,EAAWpB,IAAImB,EAAWS,EAAaT,GAAW,IAE7CC,CAAU,EAkDbmD,EAAiB,CAAC1E,EAAO/B,KAASiG,KACtC,IAAIb,GAAS,EACb,MAAMC,EAAUpF,GAAMgB,EAAgB+D,EAAcjD,EAAO9B,IACrDyG,EAAS,CAACzG,KAAM0G,KACpB,MAAM3E,EAAS8B,EAAa7D,GAC5B,IACE,GAAIF,EAAWC,EAAMC,GAAI,CACvB,IAAKE,EAAgBF,GACnB,MAAM,IAAIoB,MAAM,qBAElB,MAAMuF,EAAkB5E,EAAOG,EACzBb,EAAIqF,EAAM,GAOhB,OANAzC,EAA2BjE,EAAG+B,EAAQV,GACtCmE,EAAkB1D,EAAO9B,EAAG+B,QACxB4E,IAAoB5E,EAAOG,IAC7Bc,EAAkBlB,EAAO9B,EAAG+B,GA/DV,EAACD,EAAO/B,EAAMgB,KACxC,MAAM6F,EAAoB,GACpBC,EAA2B,IAAInE,IAC/BoE,EAA0B,IAAIpE,IAC9BqE,EAAQ,CAAC,CAAChH,EAAMgB,IACtB,KAAOgG,EAAMC,OAAS,GAAG,CACvB,MAAOhH,EAAG+B,GAAUgF,EAAMA,EAAMC,OAAS,GACzC,GAAIF,EAAQpF,IAAI1B,GACd+G,EAAME,WAGR,GAAIJ,EAASnF,IAAI1B,GACf4G,EAAkBM,KAAK,CAAClH,EAAG+B,EAAQA,EAAOG,IAC1C4E,EAAQnF,IAAI3B,GACZ+B,EAAOnB,GAAI,EACXmG,EAAME,UAJR,CAOAJ,EAASlF,IAAI3B,GACb,IAAK,MAAOgC,EAAGmF,KAAMf,EAA4BtE,EAAO9B,EAAG+B,GACrD/B,IAAMgC,GAAM6E,EAASnF,IAAIM,IAC3B+E,EAAMG,KAAK,CAAClF,EAAGmF,GAJlB,CAOF,CACDtE,EAAaf,EAAO,KAAK,KACvB,MAAMsF,EAA+B,IAAI1E,IAAI,CAAC3C,IAC9C,IAAK,IAAIsH,EAAIT,EAAkBI,OAAS,EAAGK,GAAK,IAAKA,EAAG,CACtD,MAAOrH,EAAG+B,EAAQ4E,GAAmBC,EAAkBS,GACvD,IAAIC,GAAiB,EACrB,IAAK,MAAMC,KAAOxF,EAAOC,EAAE0C,OACzB,GAAI6C,IAAQvH,GAAKoH,EAAa1F,IAAI6F,GAAM,CACtCD,GAAiB,EACjB,KACD,CAECA,IACFvC,EAAcjD,EAAO9B,GACrBwF,EAAkB1D,EAAO9B,EAAG+B,GACxB4E,IAAoB5E,EAAOG,IAC7Bc,EAAkBlB,EAAO9B,EAAG+B,GAC5BqF,EAAazF,IAAI3B,YAGd+B,EAAOnB,CACf,IACD,EAkBM4G,CAAoB1F,EAAO9B,EAAG+B,IAG1C,CACU,OAAOyE,EAAe1E,EAAO9B,KAAM0G,EAE7C,CAAgB,QACHvB,GACH7B,EAAWxB,EAEd,GAEH,IACE,OAAOiC,EAAUhE,EAAMqF,EAAQqB,KAAWT,EAChD,CAAc,QACRb,GAAS,CACV,GAEGc,EAAY,CAAClG,KAASiG,KAC1B,MAAMlE,EAAQQ,IACd,IACE,OAAOkE,EAAe1E,EAAO/B,KAASiG,EAC5C,CAAc,QACR1C,EAAWxB,EACZ,GAEG0D,EAAoB,CAAC1D,EAAO/B,EAAMgB,KACtC,GAAIA,EAAUoB,IAAM5B,EAAiBQ,EAAUM,GAAI,CACjD,IAAK,MAAMrB,KAAKe,EAAUiB,EAAE0C,OAC1B,IAAK3D,EAAUoB,EAAEH,EAAEN,IAAI1B,GAAI,CACRyH,EAAU3F,EAAO9B,EAAG6D,EAAa7D,IACzCoC,EAAET,IAAI5B,GACfgB,EAAUoB,EAAEH,EAAEL,IAAI3B,EACnB,CAEH,IAAK,MAAMA,KAAKe,EAAUoB,EAAEH,GAAK,GAC/B,IAAKjB,EAAUiB,EAAEN,IAAI1B,GAAI,CACvBe,EAAUoB,EAAEH,EAAEJ,OAAO5B,GACrB,MAAM0H,EAAWC,EAAY7F,EAAO9B,EAAG6D,EAAa7D,IACxC,MAAZ0H,GAA4BA,EAAStF,EAAER,OAAO7B,EAC/C,CAEJ,GAEG0H,EAAY,CAAC3F,EAAO/B,EAAMgB,KAC9B,IAAKA,EAAUoB,EAAG,CAChB4C,EAAcjD,EAAO/B,GACrB,IAAK,MAAMC,KAAKe,EAAUiB,EAAE0C,OAAQ,CACjB+C,EAAU3F,EAAO9B,EAAG6D,EAAa7D,IACzCoC,EAAET,IAAI5B,EAChB,CAMD,GALAgB,EAAUoB,EAAI,CACZc,EAAmB,IAAIP,IACvBV,EAAG,IAAIU,IAAI3B,EAAUiB,EAAE0C,QACvBtC,EAAmB,IAAIM,KAErBvC,EAAuBJ,GAAO,CAChC,MAAM6H,EAAU7G,EAAUoB,EAC1B,IAAI0F,EACJ,MAAMC,EAA0B,CAACvC,EAAQxC,KACvC,IAAIoC,GAAS,EACb0C,EAAU,IAAI7B,KACZ,IACE,OAAOQ,EAAejB,EAAQxF,KAASiG,EACrD,CAAsB,QACHb,GACH7B,EAAWiC,EAEd,GAEH,IACE,OAAOxC,GACnB,CAAoB,QACRoC,GAAS,CACV,GAEHtC,EAAaf,EAAO,KAAK,KACvB,MAAMiG,EAAYD,EAChBhG,GACA,IAAMkC,EAAYjE,GAAM,IAAIiG,IAAS6B,KAAW7B,OAE9C+B,IACFH,EAAQI,EAAKzC,GAAWuC,EAAwBvC,EAAQwC,GACzD,GAEJ,CACF,CACD,OAAOhH,EAAUoB,CAAC,EAEdwF,EAAc,CAAC7F,EAAO/B,EAAMgB,KAChC,IAAIA,EAAUoB,GAAMpB,EAAUoB,EAAEc,EAAES,MAASsB,MAAMC,KAAKlE,EAAUoB,EAAEC,GAAG6F,MAAMjI,IACzE,IAAIS,EACJ,OAAmC,OAA3BA,EAAKoD,EAAa7D,GAAGmC,QAAa,EAAS1B,EAAGuB,EAAEN,IAAI3B,EAAK,IAanE,OAAOgB,EAAUoB,EAfjB,CAIE,MAAM4F,EAAYhH,EAAUoB,EAAE6F,EAC1BD,GACFlF,EAAaf,EAAO,KAAK,IAAMiG,EAAUjG,YAEpCf,EAAUoB,EACjB,IAAK,MAAMnC,KAAKe,EAAUiB,EAAE0C,OAAQ,CAClC,MAAMgD,EAAWC,EAAY7F,EAAO9B,EAAG6D,EAAa7D,IACxC,MAAZ0H,GAA4BA,EAAStF,EAAER,OAAO7B,EAC/C,CAEF,CACiB,EAuBpB,MANc,CACZY,IAhNgBZ,GAASiB,EAAgB+D,OAAc,EAAQhF,IAiN/DkC,IAAKgE,EACLiC,IAlBoB,CAACnI,EAAMoD,KAC3B,MAAMrB,EAAQQ,IACRvB,EAAY8C,EAAa9D,GAEzBoI,EADUV,EAAU3F,EAAO/B,EAAMgB,GACbkC,EAG1B,OAFAkF,EAAUxG,IAAIwB,GACdG,EAAWxB,GACJ,KACLqG,EAAUvG,OAAOuB,GACjB,MAAMoC,EAASjD,IACfqF,EAAYpC,EAAQxF,EAAMgB,GAC1BuC,EAAWiC,EAAO,CACnB,EAOD6C,gBALuBrF,GAAOa,KAAcb,EAAGc,EAAcC,EAAUC,EAAWC,IAOxE,EA8ERqE,EAAc,KAClB,MAAMC,EAA+B,IAAIhI,QAYnCiI,EAAQ3E,GAXQ7D,IACpB,GAA0D,4BAAzCmB,gBAAkBA,IAAIC,UAAO,KAA6BpB,EACzE,MAAM,IAAIqB,MAAM,6BAElB,IAAIL,EAAYuH,EAAa3H,IAAIZ,GAKjC,OAJKgB,IACHA,EAAY,CAAEiB,EAAmB,IAAIQ,IAAOf,EAAmB,IAAIiB,IAAOR,EAAG,GAC7EoG,EAAarG,IAAIlC,EAAMgB,IAElBA,CAAS,IAIhB,CAAChB,KAASyI,IAAWzI,EAAK0I,QAAQD,KAClC,CAACzI,KAASyI,IAAWzI,EAAKK,SAASoI,KACnC,CAACzI,KAASyI,KACR,IAAI/H,EACJ,OAA8B,OAAtBA,EAAKV,EAAK2I,cAAmB,EAASjI,EAAGgD,KAAK1D,KAASyI,EAAO,IAG1E,MAA0D,4BAAzCtH,gBAAkBA,IAAIC,UAAO,GAlGrB,CAACoH,IAC1B,MAAMI,EAAoC,IAAIrI,QACxCsI,EAAoC,IAAIlG,IAC9C,IAAImG,EACAC,EAAgB,EACpB,MAAMC,EAAeR,EAAMH,iBACzB,CAACvE,EAAcC,EAAUC,EAAWC,KAClC6E,EAAoBhF,EACb,CACJ9D,IACC,IAAIiJ,EAAiBL,EAAkBhI,IAAIZ,GAC3C,IAAKiJ,EAAgB,CACnB,MAAMjI,EAAY8C,EAAa9D,GAC/BiJ,EAAiB,IAAIC,MAAMlI,EAAW,CACpCkB,IAAG,CAACiH,EAAQC,EAAM3I,KACH,MAAT2I,GACFP,EAAkBjH,IAAI5B,GAEjBqJ,QAAQnH,IAAIiH,EAAQC,EAAM3I,IAEnC6I,eAAc,CAACH,EAAQC,KACR,MAATA,GACFP,EAAkBhH,OAAO7B,GAEpBqJ,QAAQC,eAAeH,EAAQC,MAG1CR,EAAkB1G,IAAIlC,EAAMiJ,EAC7B,CACD,OAAOA,CAAc,EAEvBlF,EACA,CAAC/D,EAAMqF,EAAQqB,KAAWT,IACpB8C,EACKrC,EAAO1G,KAASiG,GAElBjC,EAAUhE,EAAMqF,EAAQqB,KAAWT,GAE5ChC,MAIAsF,EAAgBP,EAAa9G,IAC7BsH,EAAW,CAEfC,2BAA4B,KAAO,CACjC7I,IAAMZ,IACJ,MAAMgB,EAAY8H,EAAkB9I,GACpC,GAAoB,IAAhBgB,EAAUmB,EAGd,OAAOnB,CAAS,IAGpB0I,uBAAwB,IAAMb,EAC9Bc,mBAAqBC,IAgBnBL,EAfoB,CAClBb,KAAM,IAAM,KACZrI,MAAO,CAACwJ,EAAM3H,OACV6G,EACF,IACE,IAAK,MAAO/I,EAAMS,KAAUmJ,EACtBzJ,EAAgBH,IAClBkC,EAAIlC,EAAMS,EAG1B,CAAoB,UACNsI,CACH,IAGqB,GAG9B,OAAOnE,OAAOkF,OAAOd,EAAcQ,EAAS,EAyBnCO,CAAmBvB,GAErBA,CAAK,EAEd,IAAIwB,EACC,MAACC,EAAkB,KACjBD,IACHA,EAAe1B,IAC2C,4BAAzCnH,gBAAkBA,IAAIC,UAAO,KAC5C8I,WAAWC,0BAA4BD,WAAWC,wBAA0BH,GACxEE,WAAWC,0BAA4BH,GACzCjE,QAAQC,KACN,kJAKDgE"}