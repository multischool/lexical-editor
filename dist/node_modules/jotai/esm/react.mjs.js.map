{"version":3,"file":"react.mjs.js","sources":["../../../../node_modules/jotai/esm/react.mjs"],"sourcesContent":["'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(\n  void 0\n);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef(void 0);\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseMeta = (promise) => {\n  promise.status = \"pending\";\n  promise.then(\n    (v) => {\n      promise.status = \"fulfilled\";\n      promise.value = v;\n    },\n    (e) => {\n      promise.status = \"rejected\";\n      promise.reason = e;\n    }\n  );\n};\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseMeta(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const registerCancelHandler = (p) => {\n        if (\"onCancel\" in p && typeof p.onCancel === \"function\") {\n          p.onCancel((nextValue) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && nextValue === p) {\n              throw new Error(\"[Bug] p is not updated even after cancelation\");\n            }\n            if (isPromiseLike(nextValue)) {\n              continuablePromiseMap.set(nextValue, continuablePromise);\n              curr = nextValue;\n              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n              registerCancelHandler(nextValue);\n            } else {\n              resolve(nextValue);\n            }\n          });\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      registerCancelHandler(promise);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        const value2 = store.get(atom);\n        if (isPromiseLike(value2)) {\n          attachPromiseMeta(createContinuablePromise(value2));\n        }\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value);\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],"names":["StoreContext","createContext","useStore","options","store","useContext","getDefaultStore","isPromiseLike","x","then","attachPromiseMeta","promise","status","v","value","e","reason","use","ReactExports","continuablePromiseMap","WeakMap","createContinuablePromise","continuablePromise","get","Promise","resolve","reject","curr","onFulfilled","me","onRejected","registerCancelHandler","p","onCancel","nextValue","env","MODE","Error","set","useAtomValue","atom","valueFromReducer","storeFromReducer","atomFromReducer","rerender","useReducer","prev","Object","is","delay","useEffect","unsub","sub","value2","setTimeout","useDebugValue","useSetAtom","useCallback","args","useAtom"],"mappings":"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"}