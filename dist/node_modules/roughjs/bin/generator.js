import{line as s,rectangle as t,solidFillPolygon as e,patternFillPolygons as i,generateEllipseParams as o,ellipseWithParams as l,linearPath as r,arc as h,patternFillArc as n,curve as a,svgPath as p}from"./renderer.js";import{randomSeed as u}from"./math.js";import{curveToBezier as f}from"../node_modules/points-on-curve/lib/curve-to-bezier.js";import{pointsOnBezierCurves as c}from"../node_modules/points-on-curve/lib/index.js";import{pointsOnPath as d}from"../../points-on-path/lib/index.js";const g="none";class k{constructor(s){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,disableMultiStroke:!1,disableMultiStrokeFill:!1,preserveVertices:!1,fillShapeRoughnessGain:.8},this.config=s||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}static newSeed(){return u()}_o(s){return s?Object.assign({},this.defaultOptions,s):this.defaultOptions}_d(s,t,e){return{shape:s,sets:t||[],options:e||this.defaultOptions}}line(t,e,i,o,l){const r=this._o(l);return this._d("line",[s(t,e,i,o,r)],r)}rectangle(s,o,l,r,h){const n=this._o(h),a=[],p=t(s,o,l,r,n);if(n.fill){const t=[[s,o],[s+l,o],[s+l,o+r],[s,o+r]];"solid"===n.fillStyle?a.push(e([t],n)):a.push(i([t],n))}return n.stroke!==g&&a.push(p),this._d("rectangle",a,n)}ellipse(s,t,e,r,h){const n=this._o(h),a=[],p=o(e,r,n),u=l(s,t,n,p);if(n.fill)if("solid"===n.fillStyle){const e=l(s,t,n,p).opset;e.type="fillPath",a.push(e)}else a.push(i([u.estimatedPoints],n));return n.stroke!==g&&a.push(u.opset),this._d("ellipse",a,n)}circle(s,t,e,i){const o=this.ellipse(s,t,e,e,i);return o.shape="circle",o}linearPath(s,t){const e=this._o(t);return this._d("linearPath",[r(s,!1,e)],e)}arc(s,t,e,i,o,l,r=!1,a){const p=this._o(a),u=[],f=h(s,t,e,i,o,l,r,!0,p);if(r&&p.fill)if("solid"===p.fillStyle){const r=Object.assign({},p);r.disableMultiStroke=!0;const n=h(s,t,e,i,o,l,!0,!1,r);n.type="fillPath",u.push(n)}else u.push(n(s,t,e,i,o,l,p));return p.stroke!==g&&u.push(f),this._d("arc",u,p)}curve(s,t){const e=this._o(t),o=[],l=a(s,e);if(e.fill&&e.fill!==g&&s.length>=3)if("solid"===e.fillStyle){const t=a(s,Object.assign(Object.assign({},e),{disableMultiStroke:!0,roughness:e.roughness?e.roughness+e.fillShapeRoughnessGain:0}));o.push({type:"fillPath",ops:this._mergedShape(t.ops)})}else{const t=f(s),l=c(t,10,(1+e.roughness)/2);o.push(i([l],e))}return e.stroke!==g&&o.push(l),this._d("curve",o,e)}polygon(s,t){const o=this._o(t),l=[],h=r(s,!0,o);return o.fill&&("solid"===o.fillStyle?l.push(e([s],o)):l.push(i([s],o))),o.stroke!==g&&l.push(h),this._d("polygon",l,o)}path(s,t){const o=this._o(t),l=[];if(!s)return this._d("path",l,o);s=(s||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");const h=o.fill&&"transparent"!==o.fill&&o.fill!==g,n=o.stroke!==g,a=!!(o.simplification&&o.simplification<1),u=a?4-4*(o.simplification||1):(1+o.roughness)/2,f=d(s,1,u),c=p(s,o);if(h)if("solid"===o.fillStyle)if(1===f.length){const t=p(s,Object.assign(Object.assign({},o),{disableMultiStroke:!0,roughness:o.roughness?o.roughness+o.fillShapeRoughnessGain:0}));l.push({type:"fillPath",ops:this._mergedShape(t.ops)})}else l.push(e(f,o));else l.push(i(f,o));return n&&(a?f.forEach((s=>{l.push(r(s,!1,o))})):l.push(c)),this._d("path",l,o)}opsToPath(s,t){let e="";for(const i of s.ops){const s="number"==typeof t&&t>=0?i.data.map((s=>+s.toFixed(t))):i.data;switch(i.op){case"move":e+=`M${s[0]} ${s[1]} `;break;case"bcurveTo":e+=`C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;break;case"lineTo":e+=`L${s[0]} ${s[1]} `}}return e.trim()}toPaths(s){const t=s.sets||[],e=s.options||this.defaultOptions,i=[];for(const s of t){let t=null;switch(s.type){case"path":t={d:this.opsToPath(s),stroke:e.stroke,strokeWidth:e.strokeWidth,fill:g};break;case"fillPath":t={d:this.opsToPath(s),stroke:g,strokeWidth:0,fill:e.fill||g};break;case"fillSketch":t=this.fillSketch(s,e)}t&&i.push(t)}return i}fillSketch(s,t){let e=t.fillWeight;return e<0&&(e=t.strokeWidth/2),{d:this.opsToPath(s),stroke:t.fill||g,strokeWidth:e,fill:g}}_mergedShape(s){return s.filter(((s,t)=>0===t||"move"!==s.op))}}export{k as RoughGenerator};
//# sourceMappingURL=generator.js.map
