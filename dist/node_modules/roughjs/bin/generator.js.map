{"version":3,"file":"generator.js","sources":["../../../../node_modules/roughjs/bin/generator.js"],"sourcesContent":["import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = curve(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const bcurve = curveToBezier(points);\n                const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n                paths.push(patternFillPolygons([polyPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        const shape = svgPath(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = svgPath(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push(solidFillPolygon(sets, o));\n                }\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n"],"names":["NOS","RoughGenerator","constructor","config","this","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","disableMultiStroke","disableMultiStrokeFill","preserveVertices","fillShapeRoughnessGain","options","_o","newSeed","randomSeed","Object","assign","_d","shape","sets","line","x1","y1","x2","y2","o","rectangle","x","y","width","height","paths","outline","fill","points","push","solidFillPolygon","patternFillPolygons","ellipse","ellipseParams","generateEllipseParams","ellipseResponse","ellipseWithParams","opset","type","estimatedPoints","circle","diameter","ret","linearPath","arc","start","stop","closed","fillOptions","patternFillArc","curve","length","fillShape","ops","_mergedShape","bcurve","curveToBezier","polyPoints","pointsOnBezierCurves","polygon","path","d","replace","hasFill","hasStroke","simplified","simplification","distance","pointsOnPath","svgPath","forEach","set","opsToPath","drawing","fixedDecimals","item","data","map","toFixed","op","trim","toPaths","drawable","fillSketch","fweight","input","filter","i"],"mappings":"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"}