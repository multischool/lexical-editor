{"version":3,"file":"renderer.js","sources":["../../../../node_modules/roughjs/bin/renderer.js"],"sourcesContent":["import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n"],"names":["helper","randOffset","randOffsetWithRange","ellipse","doubleLineOps","doubleLineFillOps","line","x1","y1","x2","y2","o","type","ops","_doubleLine","linearPath","points","close","len","length","i","push","polygon","rectangle","x","y","width","height","curve","o1","_curveWithOffset","roughness","disableMultiStroke","o2","result","Object","assign","randomizer","undefined","seed","cloneOptionsAlterSeed","concat","ellipseWithParams","generateEllipseParams","opset","psq","Math","sqrt","PI","pow","stepCount","ceil","max","curveStepCount","increment","rx","abs","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","ap1","cp1","_computeEllipsePoints","_offset","_curve","ap2","estimatedPoints","arc","start","stop","closed","roughClosure","cx","cy","strt","stp","ellipseInc","arcInc","min","_arc","cos","sin","op","data","svgPath","path","segments","normalize","absolutize","parsePath","first","current","key","_bezierTo","solidFillPolygon","polygonList","offset","maxRandomnessOffset","patternFillPolygons","getFiller","fillPolygons","patternFillArc","angle","random","Random","next","roughnessGain","filling","singleStroke","disableMultiStrokeFill","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","preserveVertices","ps","closePoint","b","s","curveTightness","cachedVertArray","ro","overlap","corePoints","allPoints","p","radOffset","endAngle","ros","f","iterations"],"mappings":"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"}