{"version":3,"file":"bk.js","sources":["../../../../../../node_modules/dagre-d3-es/src/dagre/position/bk.js"],"sourcesContent":["import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\n\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nexport {\n  positionX,\n  findType1Conflicts,\n  findType2Conflicts,\n  addConflict,\n  hasConflict,\n  verticalAlignment,\n  horizontalCompaction,\n  alignCoordinates,\n  findSmallestWidthAlignment,\n  balance,\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function (v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        // @ts-expect-error\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          var uNode = g.node(u);\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          // @ts-expect-error\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function (layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function (v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) {\n          return pos[w];\n        });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? 'borderLeft' : 'borderRight';\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function (acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function (layer) {\n    var u;\n    _.forEach(layer, function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach(['u', 'd'], function (vert) {\n    _.forEach(['l', 'r'], function (horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) {\n          return x + delta;\n        });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse();\n    _.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === 'u' ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === 'r');\n      if (horiz === 'r') {\n        xs = _.mapValues(xs, function (x) {\n          return -x;\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (_.has(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = -vLabel.width / 2;\n          break;\n        case 'r':\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_.has(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = wLabel.width / 2;\n          break;\n        case 'r':\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n"],"names":["findType1Conflicts","g","layering","conflicts","_.reduce","prevLayer","layer","k0","scanPos","prevLayerLength","length","lastNode","_.last","_.forEach","v","i","w","node","dummy","_.find","predecessors","u","findOtherInnerSegmentNode","k1","order","slice","scanNode","uLabel","uPos","addConflict","findType2Conflicts","scan","south","southPos","southEnd","prevNorthBorder","nextNorthBorder","_.range","uNode","north","nextNorthPos","prevNorthPos","southLookahead","tmp","conflictsV","hasConflict","_.has","verticalAlignment","neighborFn","root","align","pos","prevIdx","ws","_.sortBy","mp","Math","floor","il","ceil","horizontalCompaction","reverseSep","xs","blockG","blockGraph","Graph","graphLabel","graph","sepFn","nodeSep","edgeSep","delta","vLabel","wLabel","sum","width","labelpos","toLowerCase","sep","nodesep","edgesep","vRoot","setNode","uRoot","prevMax","edge","setEdge","max","buildBlockGraph","borderType","iterate","setXsFunc","nextNodesFunc","stack","nodes","elem","pop","visited","push","concat","inEdges","reduce","acc","e","bind","min","outEdges","Number","POSITIVE_INFINITY","successors","findSmallestWidthAlignment","xss","_.minBy","_.values","NEGATIVE_INFINITY","_.forIn","x","halfWidth","alignCoordinates","alignTo","alignToVals","alignToMin","_.min","alignToMax","_.max","vert","horiz","alignment","xsVals","_.mapValues","balance","ul","ignore","_.map","positionX","adjustedLayering","util.buildLayerMatrix","_.merge","reverse","inner","smallestWidth"],"mappings":"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"}