{"version":3,"file":"cross-count.js","sources":["../../../../../../node_modules/dagre-d3-es/src/dagre/order/cross-count.js"],"sourcesContent":["import * as _ from 'lodash-es';\n\nexport { crossCount };\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(\n    southLayer,\n    _.map(southLayer, function (v, i) {\n      return i;\n    })\n  );\n  var southEntries = _.flatten(\n    _.map(northLayer, function (v) {\n      return _.sortBy(\n        _.map(g.outEdges(v), function (e) {\n          return { pos: southPos[e.w], weight: g.edge(e).weight };\n        }),\n        'pos'\n      );\n    })\n  );\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function () {\n    return 0;\n  });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(\n    // @ts-expect-error\n    southEntries.forEach(function (entry) {\n      var index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      var weightSum = 0;\n      // @ts-expect-error\n      while (index > 0) {\n        // @ts-expect-error\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        // @ts-expect-error\n        index = (index - 1) >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight * weightSum;\n    })\n  );\n\n  return cc;\n}\n"],"names":["crossCount","g","layering","cc","i","length","twoLayerCrossCount","northLayer","southLayer","southPos","_.zipObject","_.map","v","southEntries","_.flatten","_.sortBy","outEdges","e","pos","w","weight","edge","firstIndex","treeSize","tree","Array","_.forEach","forEach","entry","index","weightSum"],"mappings":"6OAoBA,SAASA,EAAWC,EAAGC,GAErB,IADA,IAAIC,EAAK,EACAC,EAAI,EAAGA,EAAIF,EAASG,SAAUD,EACrCD,GAAMG,EAAmBL,EAAGC,EAASE,EAAI,GAAIF,EAASE,IAExD,OAAOD,CACT,CAEA,SAASG,EAAmBL,EAAGM,EAAYC,GAuBzC,IAnBA,IAAIC,EAAWC,EACbF,EACAG,EAAMH,GAAY,SAAUI,EAAGR,GAC7B,OAAOA,CACb,KAEMS,EAAeC,EACjBH,EAAMJ,GAAY,SAAUK,GAC1B,OAAOG,EACLJ,EAAMV,EAAEe,SAASJ,IAAI,SAAUK,GAC7B,MAAO,CAAEC,IAAKT,EAASQ,EAAEE,GAAIC,OAAQnB,EAAEoB,KAAKJ,GAAGG,OACzD,IACQ,MAER,KAIME,EAAa,EACVA,EAAad,EAAWH,QAAQiB,IAAe,EACtD,IAAIC,EAAW,EAAID,EAAa,EAChCA,GAAc,EACd,IAAIE,EAAOb,EAAM,IAAIc,MAAMF,IAAW,WACpC,OAAO,CACX,IAGMpB,EAAK,EAqBT,OApBAuB,EAEEb,EAAac,SAAQ,SAAUC,GAC7B,IAAIC,EAAQD,EAAMV,IAAMI,EACxBE,EAAKK,IAAUD,EAAMR,OAGrB,IAFA,IAAIU,EAAY,EAETD,EAAQ,GAETA,EAAQ,IACVC,GAAaN,EAAKK,EAAQ,IAI5BL,EADAK,EAASA,EAAQ,GAAM,IACRD,EAAMR,OAEvBjB,GAAMyB,EAAMR,OAASU,CAC3B,KAGS3B,CACT"}