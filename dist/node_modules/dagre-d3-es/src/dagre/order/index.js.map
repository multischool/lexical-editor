{"version":3,"file":"index.js","sources":["../../../../../../node_modules/dagre-d3-es/src/dagre/order/index.js"],"sourcesContent":["import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\nimport { addSubgraphConstraints } from './add-subgraph-constraints.js';\nimport { buildLayerGraph } from './build-layer-graph.js';\nimport { crossCount } from './cross-count.js';\nimport { initOrder } from './init-order.js';\nimport { sortSubgraph } from './sort-subgraph.js';\n\nexport { order };\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges'),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges');\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n"],"names":["order","g","maxRank","util.maxRank","downLayerGraphs","buildLayerGraphs","_.range","upLayerGraphs","layering","initOrder","assignOrder","best","bestCC","Number","POSITIVE_INFINITY","i","lastBest","sweepLayerGraphs","util.buildLayerMatrix","cc","crossCount","_.cloneDeep","ranks","relationship","_.map","rank","buildLayerGraph","layerGraphs","biasRight","cg","Graph","_.forEach","lg","root","graph","sorted","sortSubgraph","vs","v","node","addSubgraphConstraints","layer"],"mappings":"mjBA0BA,SAASA,EAAMC,GACb,IAAIC,EAAUC,EAAaF,GACzBG,EAAkBC,EAAiBJ,EAAGK,EAAQ,EAAGJ,EAAU,GAAI,WAC/DK,EAAgBF,EAAiBJ,EAAGK,EAAQJ,EAAU,GAAI,GAAI,GAAI,YAEhEM,EAAWC,EAAUR,GACzBS,EAAYT,EAAGO,GAKf,IAHA,IACEG,EADEC,EAASC,OAAOC,kBAGXC,EAAI,EAAGC,EAAW,EAAGA,EAAW,IAAKD,IAAKC,EAAU,CAC3DC,EAAiBF,EAAI,EAAIX,EAAkBG,EAAeQ,EAAI,GAAK,GAEnEP,EAAWU,EAAsBjB,GACjC,IAAIkB,EAAKC,EAAWnB,EAAGO,GACnBW,EAAKP,IACPI,EAAW,EACXL,EAAOU,EAAYb,GACnBI,EAASO,EAEZ,CAEDT,EAAYT,EAAGU,EACjB,CAEA,SAASN,EAAiBJ,EAAGqB,EAAOC,GAClC,OAAOC,EAAMF,GAAO,SAAUG,GAC5B,OAAOC,EAAgBzB,EAAGwB,EAAMF,EACpC,GACA,CAEA,SAASN,EAAiBU,EAAaC,GACrC,IAAIC,EAAK,IAAIC,EACbC,EAAUJ,GAAa,SAAUK,GAC/B,IAAIC,EAAOD,EAAGE,QAAQD,KAClBE,EAASC,EAAaJ,EAAIC,EAAMJ,EAAID,GACxCG,EAAUI,EAAOE,IAAI,SAAUC,EAAGvB,GAChCiB,EAAGO,KAAKD,GAAGtC,MAAQe,CACzB,IACIyB,EAAuBR,EAAIH,EAAIM,EAAOE,GAC1C,GACA,CAEA,SAAS3B,EAAYT,EAAGO,GACtBuB,EAAUvB,GAAU,SAAUiC,GAC5BV,EAAUU,GAAO,SAAUH,EAAGvB,GAC5Bd,EAAEsC,KAAKD,GAAGtC,MAAQe,CACxB,GACA,GACA"}