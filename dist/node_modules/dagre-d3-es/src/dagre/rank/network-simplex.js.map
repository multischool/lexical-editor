{"version":3,"file":"network-simplex.js","sources":["../../../../../../node_modules/dagre-d3-es/src/dagre/rank/network-simplex.js"],"sourcesContent":["import * as _ from 'lodash-es';\nimport * as alg from '../../graphlib/alg/index.js';\nimport { simplify } from '../util.js';\nimport { feasibleTree } from './feasible-tree.js';\nimport { longestPath, slack } from './util.js';\n\nexport { networkSimplex };\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  longestPath(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = alg.postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function (edge) {\n    return (\n      flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n      flip !== isDescendant(t, t.node(edge.w), tailLabel)\n    );\n  });\n\n  return _.minBy(candidates, function (edge) {\n    return slack(g, edge);\n  });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function (v) {\n    return !g.node(v).parent;\n  });\n  var vs = alg.preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function (v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n"],"names":["networkSimplex","g","simplify","longestPath","e","t","feasibleTree","initLowLimValues","initCutValues","leaveEdge","exchangeEdges","enterEdge","vs","alg.postorder","nodes","slice","length","_.forEach","v","child","childLab","node","parent","edge","cutvalue","calcCutValue","assignCutValue","childIsTail","graphEdge","cutValue","weight","nodeEdges","u","isOutEdge","other","w","pointsToHead","otherWeight","hasEdge","otherCutValue","tree","root","arguments","dfsAssignLowLim","visited","nextLim","low","label","neighbors","_.has","lim","_.find","edges","vLabel","wLabel","tailLabel","flip","candidates","_.filter","isDescendant","_.minBy","slack","f","removeEdge","setEdge","alg.preorder","flipped","rank","minlen","updateRanks","rootLabel"],"mappings":"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"}