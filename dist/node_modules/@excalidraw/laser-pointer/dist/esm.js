var t,i,s,n;function e([t,i,s],[n,e,h]){return[t+n,i+e,s+h]}function h([t,i,s],[n,e,h]){return[t-n,i-e,s-h]}function o([t,i,s],n){return[t*n,i*n,s*n]}function r([t,i,s]){return[t/Math.sqrt(t**2+i**2),i/Math.sqrt(t**2+i**2),s]}function a([t,i,s],n){return[Math.cos(n)*t-Math.sin(n)*i,Math.sin(n)*t+Math.cos(n)*i,s]}function l(t,i,s){return Math.atan2(s[1]-t[1],s[0]-t[0])-Math.atan2(i[1]-t[1],i[0]-t[0])}function u(t){return Math.atan2(Math.sin(t),Math.cos(t))}function c([t,i]){return Math.sqrt(t**2+i**2)}function p([t,i],[s,n]){return Math.sqrt((s-t)**2+(n-i)**2)}t={},i="LaserPointer",s=()=>M,Object.defineProperty(t,i,{get:s,set:n,enumerable:!0,configurable:!0});function f(t,i,s){const n=p(i,s);if(0===n)return p(t,i);const e=((t,i,s)=>Math.max(i,Math.min(s,t)))(((t[0]-i[0])*(s[0]-i[0])+(t[1]-i[1])*(s[1]-i[1]))/n**2,0,1);return p([i[0]+e*(s[0]-i[0]),i[1]+e*(s[1]-i[1]),t[2]],t)}function P(t,i){if(0===i)return t;if(t.length<=2)return t;const s=t[0],n=t[t.length-1],[e,h]=t.reduce((([t,i],e,h)=>{const o=f(e,s,n);return o>t?[o,h]:[t,i]}),[0,-1]);if(e>=i){const e=t[h];return[...P([s,...t.slice(1,h),e],i).slice(0,-1),e,...P([e,...t.slice(h,-1),n],i).slice(1)]}return[s,n]}class M{static{this.defaults={size:2,streamline:.45,simplify:.1,simplifyPhase:"output",keepHead:!1,sizeMapping:()=>1}}static{this.constants={cornerDetectionMaxAngle:75,cornerDetectionVariance:t=>t>35?.5:1,maxTailLength:50}}constructor(t){this.originalPoints=[],this.stablePoints=[],this.tailPoints=[],this.isFresh=!0,this.options=Object.assign({},M.defaults,t)}get lastPoint(){return this.tailPoints[this.tailPoints.length-1]??this.stablePoints[this.stablePoints.length-1]}addPoint(t){const i=this.originalPoints[this.originalPoints.length-1];if(!i||i[0]!==t[0]||i[1]!==t[1]){if(this.originalPoints.push(t),this.isFresh)return this.isFresh=!1,void this.stablePoints.push(t);var s,n,r;this.options.streamline>0&&(s=this.lastPoint,n=t,r=1-this.options.streamline,t=e(s,o(h(n,s),r))),this.tailPoints.push(t),function(t){if(t.length<2)return 0;let i=0;for(let s=1;s<=t.length-1;s++)i+=p(t[s-1],t[s]);return i+=p(t[t.length-2],t[t.length-1]),i}(this.tailPoints)>M.constants.maxTailLength&&this.stabilizeTail()}}close(){this.stabilizeTail()}stabilizeTail(){if(this.options.simplify>0&&"tail"==this.options.simplifyPhase)throw new Error("Not implemented yet");this.stablePoints.push(...this.tailPoints),this.tailPoints=[]}getSize(t,i,s,n,e){return(t??this.options.size)*this.options.sizeMapping({pressure:i,runningLength:e,currentIndex:s,totalLength:n})}getStrokeOutline(t){if(this.isFresh)return[];let i=[...this.stablePoints,...this.tailPoints];this.options.simplify>0&&"input"===this.options.simplifyPhase&&(i=P(i,this.options.simplify));const s=i.length;if(0===s)return[];if(1===s){const n=i[0],h=this.getSize(t,n[2],0,s,0);if(h<.5)return[];const r=[];for(let t=0;t<=2*Math.PI;t+=Math.PI/16)r.push(e(n,o(a([1,0,0],t),h)));return r.push(e(n,o([1,0,0],this.getSize(t,n[2],0,s,0)))),r}if(2===s){const n=i[0],h=i[1],r=this.getSize(t,n[2],0,s,0),u=this.getSize(t,h[2],0,s,0);if(r<.5||u<.5)return[];const c=[],p=l(n,[n[0],n[1]-100,n[2]],h);for(let t=p;t<=Math.PI+p;t+=Math.PI/16)c.push(e(n,o(a([1,0,0],t),r)));for(let t=Math.PI+p;t<=2*Math.PI+p;t+=Math.PI/16)c.push(e(h,o(a([1,0,0],t),u)));return c.push(c[0]),c}const n=[],f=[];let g=0,I=0,m=0,z=0;for(let P=1;P<s-1;P++){const b=i[P-1],d=i[P],y=i[P+1];let S=d[2];const x=p(b,d);z+=x,g=I+.2*(x-I);const L=this.getSize(t,S,P,s,z);if(0===L){m=P+1;continue}const v=r(h(b,d)),T=r(h(y,d)),k=a(v,Math.PI/2),q=a(v,-Math.PI/2),D=a(T,Math.PI/2),F=a(T,-Math.PI/2),H=e(d,o(k,L)),O=e(d,o(q,L)),j=e(d,o(D,L)),w=e(d,o(F,L)),A=e(k,F),V=e(q,D),E=e(d,o(0===c(A)?v:r(A),L)),N=e(d,o(0===c(V)?T:r(V),L)),B=u(l(d,b,y)),C=M.constants.cornerDetectionMaxAngle/180*Math.PI*M.constants.cornerDetectionVariance(g);if(Math.abs(B)<C){const t=Math.abs(u(Math.PI-B));if(0===t)continue;if(B<0){f.push(O,N);for(let i=0;i<=t;i+=t/4)n.push(e(d,a(o(k,L),i)));for(let i=t;i>=0;i-=t/4)f.push(e(d,a(o(k,L),i)));f.push(N,j)}else{n.push(H,E);for(let i=0;i<=t;i+=t/4)f.push(e(d,a(o(k,-L),-i)));for(let i=t;i>=0;i-=t/4)n.push(e(d,a(o(k,-L),-i)));n.push(E,w)}}else n.push(E),f.push(N);I=g}if(m>=s-2){if(this.options.keepHead){const t=i[s-1],n=[];for(let i=0;i<=2*Math.PI;i+=Math.PI/16)n.push(e(t,o(a([1,0,0],i),this.options.size)));return n.push(e(t,o([1,0,0],this.options.size))),n}return[]}const b=i[m],d=i[m+1],y=i[s-2],S=i[s-1],x=r(h(d,b)),L=r(h(y,S)),v=a(x,-Math.PI/2),T=a(L,Math.PI/2),k=this.getSize(t,b[2],0,s,0),q=[],D=this.options.keepHead?this.options.size:this.getSize(t,y[2],s-2,s,z),F=[];if(k>1){for(let t=0;t<=Math.PI;t+=Math.PI/16)q.unshift(e(b,a(o(v,k),-t)));q.unshift(e(b,o(v,-k)))}else q.push(b);for(let t=0;t<=3*Math.PI;t+=Math.PI/16)F.push(e(S,a(o(T,-D),-t)));const H=[...q,...n,...F.reverse(),...f.reverse()];return q.length>0&&H.push(q[0]),this.options.simplify>0&&"output"===this.options.simplifyPhase?P(H,this.options.simplify):H}}export{M as LaserPointer};
//# sourceMappingURL=esm.js.map
