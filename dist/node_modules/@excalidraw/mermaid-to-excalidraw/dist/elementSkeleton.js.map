{"version":3,"file":"elementSkeleton.js","sources":["../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/elementSkeleton.js"],"sourcesContent":["import { entityCodesToText } from \"./utils.js\";\nimport { DEFAULT_FONT_SIZE } from \"./constants.js\";\nexport const createArrowSkeletonFromSVG = (arrowNode, opts) => {\n    const arrow = {};\n    if (opts?.label) {\n        arrow.label = { text: entityCodesToText(opts.label), fontSize: 16 };\n    }\n    const tagName = arrowNode.tagName;\n    if (tagName === \"line\") {\n        arrow.startX = Number(arrowNode.getAttribute(\"x1\"));\n        arrow.startY = Number(arrowNode.getAttribute(\"y1\"));\n        arrow.endX = Number(arrowNode.getAttribute(\"x2\"));\n        arrow.endY = Number(arrowNode.getAttribute(\"y2\"));\n    }\n    else if (tagName === \"path\") {\n        const dAttr = arrowNode.getAttribute(\"d\");\n        if (!dAttr) {\n            throw new Error('Path element does not contain a \"d\" attribute');\n        }\n        // Split the d attribute based on M (Move To)  and C (Curve) commands\n        const commands = dAttr.split(/(?=[LC])/);\n        const startPosition = commands[0]\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        const points = [];\n        commands.forEach((command) => {\n            const currPoints = command\n                .substring(1)\n                .trim()\n                .split(\" \")\n                .map((pos) => {\n                const [x, y] = pos.split(\",\");\n                return [\n                    parseFloat(x) - startPosition[0],\n                    parseFloat(y) - startPosition[1],\n                ];\n            });\n            points.push(...currPoints);\n        });\n        const endPosition = points[points.length - 1];\n        arrow.startX = startPosition[0];\n        arrow.startY = startPosition[1];\n        arrow.endX = endPosition[0];\n        arrow.endY = endPosition[1];\n        arrow.points = points;\n    }\n    if (opts?.label) {\n        // In mermaid the text is positioned above arrow but in Excalidraw\n        // its postioned on the arrow hence the elements below it might look cluttered so shifting the arrow by an offset of 10px\n        const offset = 10;\n        arrow.startY = arrow.startY - offset;\n        arrow.endY = arrow.endY - offset;\n    }\n    arrow.strokeColor = arrowNode.getAttribute(\"stroke\");\n    arrow.strokeWidth = Number(arrowNode.getAttribute(\"stroke-width\"));\n    arrow.type = \"arrow\";\n    arrow.strokeStyle = opts?.strokeStyle || \"solid\";\n    arrow.startArrowhead = opts?.startArrowhead || null;\n    arrow.endArrowhead = opts?.endArrowhead || null;\n    return arrow;\n};\nexport const createArrowSkeletion = (startX, startY, endX, endY, opts) => {\n    const arrow = {};\n    arrow.type = \"arrow\";\n    arrow.startX = startX;\n    arrow.startY = startY;\n    arrow.endX = endX;\n    arrow.endY = endY;\n    Object.assign(arrow, { ...opts });\n    return arrow;\n};\nexport const createTextSkeleton = (x, y, text, opts) => {\n    const textElement = {\n        type: \"text\",\n        x,\n        y,\n        text,\n        width: opts?.width || 20,\n        height: opts?.height || 20,\n        fontSize: opts?.fontSize || DEFAULT_FONT_SIZE,\n        id: opts?.id,\n        groupId: opts?.groupId,\n        metadata: opts?.metadata,\n    };\n    return textElement;\n};\nexport const createTextSkeletonFromSVG = (textNode, text, opts) => {\n    const node = {};\n    const x = Number(textNode.getAttribute(\"x\"));\n    const y = Number(textNode.getAttribute(\"y\"));\n    node.type = \"text\";\n    node.text = entityCodesToText(text);\n    if (opts?.id) {\n        node.id = opts.id;\n    }\n    if (opts?.groupId) {\n        node.groupId = opts.groupId;\n    }\n    const boundingBox = textNode.getBBox();\n    node.width = boundingBox.width;\n    node.height = boundingBox.height;\n    node.x = x - boundingBox.width / 2;\n    node.y = y;\n    const fontSize = parseInt(getComputedStyle(textNode).fontSize);\n    node.fontSize = fontSize;\n    return node;\n};\nexport const createContainerSkeletonFromSVG = (node, type, opts = {}) => {\n    const container = {};\n    container.type = type;\n    const { label, subtype, id, groupId } = opts;\n    container.id = id;\n    if (groupId) {\n        container.groupId = groupId;\n    }\n    if (label) {\n        container.label = {\n            text: entityCodesToText(label.text),\n            fontSize: 16,\n            verticalAlign: label?.verticalAlign,\n        };\n    }\n    const boundingBox = node.getBBox();\n    container.x = boundingBox.x;\n    container.y = boundingBox.y;\n    container.width = boundingBox.width;\n    container.height = boundingBox.height;\n    container.subtype = subtype;\n    switch (subtype) {\n        case \"highlight\":\n            const bgColor = node.getAttribute(\"fill\");\n            if (bgColor) {\n                container.bgColor = bgColor;\n            }\n            break;\n        case \"note\":\n            container.strokeStyle = \"dashed\";\n            break;\n    }\n    return container;\n};\nexport const createLineSkeletonFromSVG = (lineNode, startX, startY, endX, endY, opts) => {\n    const line = {};\n    line.startX = startX;\n    line.startY = startY;\n    line.endX = endX;\n    if (opts?.groupId) {\n        line.groupId = opts.groupId;\n    }\n    if (opts?.id) {\n        line.id = opts.id;\n    }\n    // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n    line.endY = endY;\n    line.strokeColor = lineNode.getAttribute(\"stroke\");\n    line.strokeWidth = Number(lineNode.getAttribute(\"stroke-width\"));\n    line.type = \"line\";\n    return line;\n};\n"],"names":["createArrowSkeletonFromSVG","arrowNode","opts","arrow","label","text","entityCodesToText","fontSize","tagName","startX","Number","getAttribute","startY","endX","endY","dAttr","Error","commands","split","startPosition","substring","map","coord","parseFloat","points","forEach","command","currPoints","trim","pos","x","y","push","endPosition","length","offset","strokeColor","strokeWidth","type","strokeStyle","startArrowhead","endArrowhead","createArrowSkeletion","Object","assign","createTextSkeleton","width","height","DEFAULT_FONT_SIZE","id","groupId","metadata","createTextSkeletonFromSVG","textNode","node","boundingBox","getBBox","parseInt","getComputedStyle","createContainerSkeletonFromSVG","container","subtype","verticalAlign","bgColor","createLineSkeletonFromSVG","lineNode","line"],"mappings":"kGAEY,MAACA,EAA6B,CAACC,EAAWC,KAClD,MAAMC,EAAQ,CAAA,EACVD,GAAME,QACND,EAAMC,MAAQ,CAAEC,KAAMC,EAAkBJ,EAAKE,OAAQG,SAAU,KAEnE,MAAMC,EAAUP,EAAUO,QAC1B,GAAgB,SAAZA,EACAL,EAAMM,OAASC,OAAOT,EAAUU,aAAa,OAC7CR,EAAMS,OAASF,OAAOT,EAAUU,aAAa,OAC7CR,EAAMU,KAAOH,OAAOT,EAAUU,aAAa,OAC3CR,EAAMW,KAAOJ,OAAOT,EAAUU,aAAa,YAE1C,GAAgB,SAAZH,EAAoB,CACzB,MAAMO,EAAQd,EAAUU,aAAa,KACrC,IAAKI,EACD,MAAM,IAAIC,MAAM,iDAGpB,MAAMC,EAAWF,EAAMG,MAAM,YACvBC,EAAgBF,EAAS,GAC1BG,UAAU,GACVF,MAAM,KACNG,KAAKC,GAAUC,WAAWD,KACzBE,EAAS,GACfP,EAASQ,SAASC,IACd,MAAMC,EAAaD,EACdN,UAAU,GACVQ,OACAV,MAAM,KACNG,KAAKQ,IACN,MAAOC,EAAGC,GAAKF,EAAIX,MAAM,KACzB,MAAO,CACHK,WAAWO,GAAKX,EAAc,GAC9BI,WAAWQ,GAAKZ,EAAc,GACjC,IAELK,EAAOQ,QAAQL,EAAW,IAE9B,MAAMM,EAAcT,EAAOA,EAAOU,OAAS,GAC3C/B,EAAMM,OAASU,EAAc,GAC7BhB,EAAMS,OAASO,EAAc,GAC7BhB,EAAMU,KAAOoB,EAAY,GACzB9B,EAAMW,KAAOmB,EAAY,GACzB9B,EAAMqB,OAASA,CAClB,CACD,GAAItB,GAAME,MAAO,CAGb,MAAM+B,EAAS,GACfhC,EAAMS,OAAST,EAAMS,OAASuB,EAC9BhC,EAAMW,KAAOX,EAAMW,KAAOqB,CAC7B,CAOD,OANAhC,EAAMiC,YAAcnC,EAAUU,aAAa,UAC3CR,EAAMkC,YAAc3B,OAAOT,EAAUU,aAAa,iBAClDR,EAAMmC,KAAO,QACbnC,EAAMoC,YAAcrC,GAAMqC,aAAe,QACzCpC,EAAMqC,eAAiBtC,GAAMsC,gBAAkB,KAC/CrC,EAAMsC,aAAevC,GAAMuC,cAAgB,KACpCtC,CAAK,EAEHuC,EAAuB,CAACjC,EAAQG,EAAQC,EAAMC,EAAMZ,KAC7D,MAAMC,EAAQ,CACdA,KAAa,SAMb,OALAA,EAAMM,OAASA,EACfN,EAAMS,OAASA,EACfT,EAAMU,KAAOA,EACbV,EAAMW,KAAOA,EACb6B,OAAOC,OAAOzC,EAAO,IAAKD,IACnBC,CAAK,EAEH0C,EAAqB,CAACf,EAAGC,EAAG1B,EAAMH,KACvB,CAChBoC,KAAM,OACNR,IACAC,IACA1B,OACAyC,MAAO5C,GAAM4C,OAAS,GACtBC,OAAQ7C,GAAM6C,QAAU,GACxBxC,SAAUL,GAAMK,UAAYyC,EAC5BC,GAAI/C,GAAM+C,GACVC,QAAShD,GAAMgD,QACfC,SAAUjD,GAAMiD,WAIXC,EAA4B,CAACC,EAAUhD,EAAMH,KACtD,MAAMoD,EAAO,CAAA,EACPxB,EAAIpB,OAAO2C,EAAS1C,aAAa,MACjCoB,EAAIrB,OAAO2C,EAAS1C,aAAa,MACvC2C,EAAKhB,KAAO,OACZgB,EAAKjD,KAAOC,EAAkBD,GAC1BH,GAAM+C,KACNK,EAAKL,GAAK/C,EAAK+C,IAEf/C,GAAMgD,UACNI,EAAKJ,QAAUhD,EAAKgD,SAExB,MAAMK,EAAcF,EAASG,UAC7BF,EAAKR,MAAQS,EAAYT,MACzBQ,EAAKP,OAASQ,EAAYR,OAC1BO,EAAKxB,EAAIA,EAAIyB,EAAYT,MAAQ,EACjCQ,EAAKvB,EAAIA,EACT,MAAMxB,EAAWkD,SAASC,iBAAiBL,GAAU9C,UAErD,OADA+C,EAAK/C,SAAWA,EACT+C,CAAI,EAEFK,EAAiC,CAACL,EAAMhB,EAAMpC,EAAO,CAAA,KAC9D,MAAM0D,EAAY,CAAA,EAClBA,EAAUtB,KAAOA,EACjB,MAAMlC,MAAEA,EAAKyD,QAAEA,EAAOZ,GAAEA,EAAEC,QAAEA,GAAYhD,EACxC0D,EAAUX,GAAKA,EACXC,IACAU,EAAUV,QAAUA,GAEpB9C,IACAwD,EAAUxD,MAAQ,CACdC,KAAMC,EAAkBF,EAAMC,MAC9BE,SAAU,GACVuD,cAAe1D,GAAO0D,gBAG9B,MAAMP,EAAcD,EAAKE,UAMzB,OALAI,EAAU9B,EAAIyB,EAAYzB,EAC1B8B,EAAU7B,EAAIwB,EAAYxB,EAC1B6B,EAAUd,MAAQS,EAAYT,MAC9Bc,EAAUb,OAASQ,EAAYR,OAC/Ba,EAAUC,QAAUA,EACZA,GACJ,IAAK,YACD,MAAME,EAAUT,EAAK3C,aAAa,QAC9BoD,IACAH,EAAUG,QAAUA,GAExB,MACJ,IAAK,OACDH,EAAUrB,YAAc,SAGhC,OAAOqB,CAAS,EAEPI,EAA4B,CAACC,EAAUxD,EAAQG,EAAQC,EAAMC,EAAMZ,KAC5E,MAAMgE,EAAO,CAAA,EAeb,OAdAA,EAAKzD,OAASA,EACdyD,EAAKtD,OAASA,EACdsD,EAAKrD,KAAOA,EACRX,GAAMgD,UACNgB,EAAKhB,QAAUhD,EAAKgD,SAEpBhD,GAAM+C,KACNiB,EAAKjB,GAAK/C,EAAK+C,IAGnBiB,EAAKpD,KAAOA,EACZoD,EAAK9B,YAAc6B,EAAStD,aAAa,UACzCuD,EAAK7B,YAAc3B,OAAOuD,EAAStD,aAAa,iBAChDuD,EAAK5B,KAAO,OACL4B,CAAI"}