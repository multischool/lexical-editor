{"version":3,"file":"utils.js","sources":["../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js"],"sourcesContent":["// Convert mermaid entity codes to text e.g. \"#9829;\" to \"♥\"\nexport const entityCodesToText = (input) => {\n    input = decodeEntities(input);\n    // Append & before the pattern #(\\d+); or #([a-z]+); to convert to decimal code\n    // so it can be rendered as html character\n    // eg #9829; => &#9829;\n    const inputWithDecimalCode = input\n        .replace(/#(\\d+);/g, \"&#$1;\")\n        .replace(/#([a-z]+);/g, \"&$1;\");\n    // Render the decimal code as html character, eg &#9829; => ♥\n    const element = document.createElement(\"textarea\");\n    element.innerHTML = inputWithDecimalCode;\n    return element.value;\n};\nexport const getTransformAttr = (el) => {\n    const transformAttr = el.getAttribute(\"transform\");\n    const translateMatch = transformAttr?.match(/translate\\(([ \\d.-]+),\\s*([\\d.-]+)\\)/);\n    let transformX = 0;\n    let transformY = 0;\n    if (translateMatch) {\n        transformX = Number(translateMatch[1]);\n        transformY = Number(translateMatch[2]);\n    }\n    return { transformX, transformY };\n};\n//TODO Once fixed in mermaid this will be removed\nexport const encodeEntities = (text) => {\n    let txt = text;\n    txt = txt.replace(/style.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/classDef.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/#\\w+;/g, (s) => {\n        const innerTxt = s.substring(1, s.length - 1);\n        const isInt = /^\\+?\\d+$/.test(innerTxt);\n        if (isInt) {\n            return `ﬂ°°${innerTxt}¶ß`;\n        }\n        return `ﬂ°${innerTxt}¶ß`;\n    });\n    return txt;\n};\nexport const decodeEntities = function (text) {\n    return text.replace(/ﬂ°°/g, \"#\").replace(/ﬂ°/g, \"&\").replace(/¶ß/g, \";\");\n};\n// Compute edge postion start, end and points (reflection points)\nexport const computeEdgePositions = (pathElement, offset = { x: 0, y: 0 }) => {\n    // Check if the element is a path else throw an error\n    if (pathElement.tagName.toLowerCase() !== \"path\") {\n        throw new Error(`Invalid input: Expected an HTMLElement of tag \"path\", got ${pathElement.tagName}`);\n    }\n    // Get the d attribute from the path element else throw an error\n    const dAttr = pathElement.getAttribute(\"d\");\n    if (!dAttr) {\n        throw new Error('Path element does not contain a \"d\" attribute');\n    }\n    // Split the d attribute based on M (Move To) and L (Line To) commands\n    // eg \"M29.383,38.5L29.383,63.5L29.383,83.2\" => [\"M29.383,38.5\", \"L29.383,63.5\", \"L29.383,83.2\"]\n    const commands = dAttr.split(/(?=[LM])/);\n    // Get the start position from the first commands element => [29.383,38.5]\n    const startPosition = commands[0]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    // Get the last position from the last commands element => [29.383,83.2]\n    const endPosition = commands[commands.length - 1]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    // compute the reflection points -> [ {x: 29.383, y: 38.5}, {x: 29.383, y: 83.2} ]\n    // These includes the start and end points and also points which are not the same as the previous points\n    const reflectionPoints = commands\n        .map((command) => {\n        const coords = command\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        return { x: coords[0], y: coords[1] };\n    })\n        .filter((point, index, array) => {\n        // Always include the last point\n        if (index === 0 || index === array.length - 1) {\n            return true;\n        }\n        // Exclude the points which are the same as the previous point\n        if (point.x === array[index - 1].x && point.y === array[index - 1].y) {\n            return false;\n        }\n        // The below check is exclusively for second last point\n        if (index === array.length - 2 &&\n            (array[index - 1].x === point.x || array[index - 1].y === point.y)) {\n            const lastPoint = array[array.length - 1];\n            // Get the distance between the last point and second last point using Euclidean distance formula\n            const distance = Math.hypot(lastPoint.x - point.x, lastPoint.y - point.y);\n            // Include the second last point if the distance between the\n            // last point and second last point is > 20.\n            // This is to ensure we have a distance for render the edge.\n            // 20 seems to be a good enough distance to render the edge\n            return distance > 20;\n        }\n        // Always include if the current point is not the same as the previous point\n        return point.x !== array[index - 1].x || point.y !== array[index - 1].y;\n    })\n        .map((p) => {\n        // Offset the point by the provided offset\n        return {\n            x: p.x + offset.x,\n            y: p.y + offset.y,\n        };\n    });\n    // Return the edge positions\n    return {\n        startX: startPosition[0] + offset.x,\n        startY: startPosition[1] + offset.y,\n        endX: endPosition[0] + offset.x,\n        endY: endPosition[1] + offset.y,\n        reflectionPoints,\n    };\n};\n"],"names":["entityCodesToText","input","inputWithDecimalCode","decodeEntities","replace","element","document","createElement","innerHTML","value","getTransformAttr","el","transformAttr","getAttribute","translateMatch","match","transformX","transformY","Number","encodeEntities","text","txt","s","substring","length","innerTxt","test","computeEdgePositions","pathElement","offset","x","y","tagName","toLowerCase","Error","dAttr","commands","split","startPosition","map","coord","parseFloat","endPosition","reflectionPoints","command","coords","filter","point","index","array","lastPoint","Math","hypot","p","startX","startY","endX","endY"],"mappings":"AACY,MAACA,EAAqBC,IAK9B,MAAMC,GAJND,EAAQE,EAAeF,IAKlBG,QAAQ,WAAY,SACpBA,QAAQ,cAAe,QAEtBC,EAAUC,SAASC,cAAc,YAEvC,OADAF,EAAQG,UAAYN,EACbG,EAAQI,KAAK,EAEXC,EAAoBC,IAC7B,MAAMC,EAAgBD,EAAGE,aAAa,aAChCC,EAAiBF,GAAeG,MAAM,wCAC5C,IAAIC,EAAa,EACbC,EAAa,EAKjB,OAJIH,IACAE,EAAaE,OAAOJ,EAAe,IACnCG,EAAaC,OAAOJ,EAAe,KAEhC,CAAEE,aAAYC,aAAY,EAGxBE,EAAkBC,IAC3B,IAAIC,EAAMD,EAeV,OAdAC,EAAMA,EAAIjB,QAAQ,oBAAqBkB,GAC5BA,EAAEC,UAAU,EAAGD,EAAEE,OAAS,KAErCH,EAAMA,EAAIjB,QAAQ,uBAAwBkB,GAC/BA,EAAEC,UAAU,EAAGD,EAAEE,OAAS,KAErCH,EAAMA,EAAIjB,QAAQ,UAAWkB,IACzB,MAAMG,EAAWH,EAAEC,UAAU,EAAGD,EAAEE,OAAS,GAE3C,MADc,WAAWE,KAAKD,GAEnB,MAAMA,MAEV,KAAKA,KAAY,IAErBJ,CAAG,EAEDlB,EAAiB,SAAUiB,GACpC,OAAOA,EAAKhB,QAAQ,OAAQ,KAAKA,QAAQ,MAAO,KAAKA,QAAQ,MAAO,IACxE,EAEauB,EAAuB,CAACC,EAAaC,EAAS,CAAEC,EAAG,EAAGC,EAAG,MAElE,GAA0C,SAAtCH,EAAYI,QAAQC,cACpB,MAAM,IAAIC,MAAM,6DAA6DN,EAAYI,WAG7F,MAAMG,EAAQP,EAAYf,aAAa,KACvC,IAAKsB,EACD,MAAM,IAAID,MAAM,iDAIpB,MAAME,EAAWD,EAAME,MAAM,YAEvBC,EAAgBF,EAAS,GAC1Bb,UAAU,GACVc,MAAM,KACNE,KAAKC,GAAUC,WAAWD,KAEzBE,EAAcN,EAASA,EAASZ,OAAS,GAC1CD,UAAU,GACVc,MAAM,KACNE,KAAKC,GAAUC,WAAWD,KAGzBG,EAAmBP,EACpBG,KAAKK,IACN,MAAMC,EAASD,EACVrB,UAAU,GACVc,MAAM,KACNE,KAAKC,GAAUC,WAAWD,KAC/B,MAAO,CAAEV,EAAGe,EAAO,GAAId,EAAGc,EAAO,GAAI,IAEpCC,QAAO,CAACC,EAAOC,EAAOC,KAEvB,GAAc,IAAVD,GAAeA,IAAUC,EAAMzB,OAAS,EACxC,OAAO,EAGX,GAAIuB,EAAMjB,IAAMmB,EAAMD,EAAQ,GAAGlB,GAAKiB,EAAMhB,IAAMkB,EAAMD,EAAQ,GAAGjB,EAC/D,OAAO,EAGX,GAAIiB,IAAUC,EAAMzB,OAAS,IACxByB,EAAMD,EAAQ,GAAGlB,IAAMiB,EAAMjB,GAAKmB,EAAMD,EAAQ,GAAGjB,IAAMgB,EAAMhB,GAAI,CACpE,MAAMmB,EAAYD,EAAMA,EAAMzB,OAAS,GAOvC,OALiB2B,KAAKC,MAAMF,EAAUpB,EAAIiB,EAAMjB,EAAGoB,EAAUnB,EAAIgB,EAAMhB,GAKrD,EACrB,CAED,OAAOgB,EAAMjB,IAAMmB,EAAMD,EAAQ,GAAGlB,GAAKiB,EAAMhB,IAAMkB,EAAMD,EAAQ,GAAGjB,CAAC,IAEtEQ,KAAKc,IAEC,CACHvB,EAAGuB,EAAEvB,EAAID,EAAOC,EAChBC,EAAGsB,EAAEtB,EAAIF,EAAOE,MAIxB,MAAO,CACHuB,OAAQhB,EAAc,GAAKT,EAAOC,EAClCyB,OAAQjB,EAAc,GAAKT,EAAOE,EAClCyB,KAAMd,EAAY,GAAKb,EAAOC,EAC9B2B,KAAMf,EAAY,GAAKb,EAAOE,EAC9BY,mBACH"}