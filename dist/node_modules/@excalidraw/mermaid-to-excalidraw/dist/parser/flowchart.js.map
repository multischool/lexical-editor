{"version":3,"file":"flowchart.js","sources":["../../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/flowchart.js"],"sourcesContent":["import { computeEdgePositions, entityCodesToText, getTransformAttr, } from \"../utils.js\";\nconst parseSubGraph = (data, containerEl) => {\n    // Extract only node id for better reference\n    // e.g. full element id = \"flowchart-c1-205\" will map to \"c1\"\n    const nodeIds = data.nodes.map((n) => {\n        if (n.startsWith(\"flowchart-\")) {\n            return n.split(\"-\")[1];\n        }\n        return n;\n    });\n    // Get position\n    const el = containerEl.querySelector(`[id='${data.id}']`);\n    if (!el) {\n        throw new Error(\"SubGraph element not found\");\n    }\n    const position = computeElementPosition(el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Remove irrelevant properties\n    data.classes = undefined;\n    data.dir = undefined;\n    return {\n        ...data,\n        nodeIds,\n        ...position,\n        ...dimension,\n        text: entityCodesToText(data.title),\n    };\n};\nconst parseVertex = (data, containerEl) => {\n    // Find Vertex element\n    const el = containerEl.querySelector(`[id*=\"flowchart-${data.id}-\"]`);\n    if (!el) {\n        return undefined;\n    }\n    // Check if Vertex attached with link\n    let link;\n    if (el.parentElement?.tagName.toLowerCase() === \"a\") {\n        link = el.parentElement.getAttribute(\"xlink:href\");\n    }\n    // Get position\n    const position = computeElementPosition(link ? el.parentElement : el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Extract style\n    const labelContainerStyleText = el\n        .querySelector(\".label-container\")\n        ?.getAttribute(\"style\");\n    const labelStyleText = el.querySelector(\".label\")?.getAttribute(\"style\");\n    const containerStyle = {};\n    labelContainerStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        containerStyle[key] = value;\n    });\n    const labelStyle = {};\n    labelStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        labelStyle[key] = value;\n    });\n    return {\n        id: data.id,\n        labelType: data.labelType,\n        text: entityCodesToText(data.text),\n        type: data.type,\n        link: link || undefined,\n        ...position,\n        ...dimension,\n        containerStyle,\n        labelStyle,\n    };\n};\nconst parseEdge = (data, edgeIndex, containerEl) => {\n    // Find edge element\n    const edge = containerEl.querySelector(`[id*=\"L-${data.start}-${data.end}-${edgeIndex}\"]`);\n    if (!edge) {\n        throw new Error(\"Edge element not found\");\n    }\n    // Compute edge position data\n    const position = computeElementPosition(edge, containerEl);\n    const edgePositionData = computeEdgePositions(edge, position);\n    // Remove irrelevant properties\n    data.length = undefined;\n    return {\n        ...data,\n        ...edgePositionData,\n        text: entityCodesToText(data.text),\n    };\n};\n// Compute element position\nconst computeElementPosition = (el, containerEl) => {\n    if (!el) {\n        throw new Error(\"Element not found\");\n    }\n    let root = el.parentElement?.parentElement;\n    const childElement = el.childNodes[0];\n    let childPosition = { x: 0, y: 0 };\n    if (childElement) {\n        const { transformX, transformY } = getTransformAttr(childElement);\n        const boundingBox = childElement.getBBox();\n        childPosition = {\n            x: Number(childElement.getAttribute(\"x\")) ||\n                transformX + boundingBox.x ||\n                0,\n            y: Number(childElement.getAttribute(\"y\")) ||\n                transformY + boundingBox.y ||\n                0,\n        };\n    }\n    const { transformX, transformY } = getTransformAttr(el);\n    const position = {\n        x: transformX + childPosition.x,\n        y: transformY + childPosition.y,\n    };\n    while (root && root.id !== containerEl.id) {\n        if (root.classList.value === \"root\" && root.hasAttribute(\"transform\")) {\n            const { transformX, transformY } = getTransformAttr(root);\n            position.x += transformX;\n            position.y += transformY;\n        }\n        root = root.parentElement;\n    }\n    return position;\n};\nexport const parseMermaidFlowChartDiagram = (diagram, containerEl) => {\n    // This does some cleanup and initialization making sure\n    // diagram is parsed correctly. Useful when multiple diagrams are\n    // parsed together one after another, eg in playground\n    // https://github.com/mermaid-js/mermaid/blob/e561cbd3be2a93b8bedfa4839484966faad92ccf/packages/mermaid/src/Diagram.ts#L43\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const vertices = mermaidParser.getVertices();\n    Object.keys(vertices).forEach((id) => {\n        vertices[id] = parseVertex(vertices[id], containerEl);\n    });\n    // Track the count of edges based on the edge id\n    const edgeCountMap = new Map();\n    const edges = mermaidParser\n        .getEdges()\n        .filter((edge) => {\n        // Sometimes mermaid parser returns edges which are not present in the DOM hence this is a safety check to only consider edges present in the DOM, issue - https://github.com/mermaid-js/mermaid/issues/5516\n        return containerEl.querySelector(`[id*=\"L-${edge.start}-${edge.end}\"]`);\n    })\n        .map((data) => {\n        const edgeId = `${data.start}-${data.end}`;\n        const count = edgeCountMap.get(edgeId) || 0;\n        edgeCountMap.set(edgeId, count + 1);\n        return parseEdge(data, count, containerEl);\n    });\n    const subGraphs = mermaidParser\n        .getSubGraphs()\n        .map((data) => parseSubGraph(data, containerEl));\n    return {\n        type: \"flowchart\",\n        subGraphs,\n        vertices,\n        edges,\n    };\n};\n"],"names":["computeElementPosition","el","containerEl","Error","root","parentElement","childElement","childNodes","childPosition","x","y","transformX","transformY","getTransformAttr","boundingBox","getBBox","Number","getAttribute","position","id","classList","value","hasAttribute","parseMermaidFlowChartDiagram","diagram","parse","mermaidParser","parser","yy","vertices","getVertices","Object","keys","forEach","data","querySelector","link","tagName","toLowerCase","dimension","width","height","labelContainerStyleText","labelStyleText","containerStyle","split","property","key","trim","labelStyle","labelType","text","entityCodesToText","type","undefined","parseVertex","edgeCountMap","Map","edges","getEdges","filter","edge","start","end","map","edgeId","count","get","set","edgeIndex","edgePositionData","computeEdgePositions","length","parseEdge","subGraphs","getSubGraphs","nodeIds","nodes","n","startsWith","classes","dir","title","parseSubGraph"],"mappings":"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"}