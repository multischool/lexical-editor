{"version":3,"file":"sequence.js","sources":["../../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/sequence.js"],"sourcesContent":["import { SVG_TO_SHAPE_MAPPER } from \"../constants.js\";\nimport { nanoid } from \"nanoid\";\nimport { createArrowSkeletonFromSVG, createContainerSkeletonFromSVG, createLineSkeletonFromSVG, createTextSkeletonFromSVG, } from \"../elementSkeleton.js\";\n// Currently mermaid supported these 6 arrow types, the names are taken from mermaidParser.LINETYPE\nconst SEQUENCE_ARROW_TYPES = {\n    0: \"SOLID\",\n    1: \"DOTTED\",\n    3: \"SOLID_CROSS\",\n    4: \"DOTTED_CROSS\",\n    5: \"SOLID_OPEN\",\n    6: \"DOTTED_OPEN\",\n    24: \"SOLID_POINT\",\n    25: \"DOTTED_POINT\",\n};\nconst MESSAGE_TYPE = {\n    SOLID: 0,\n    DOTTED: 1,\n    NOTE: 2,\n    SOLID_CROSS: 3,\n    DOTTED_CROSS: 4,\n    SOLID_OPEN: 5,\n    DOTTED_OPEN: 6,\n    LOOP_START: 10,\n    LOOP_END: 11,\n    ALT_START: 12,\n    ALT_ELSE: 13,\n    ALT_END: 14,\n    OPT_START: 15,\n    OPT_END: 16,\n    ACTIVE_START: 17,\n    ACTIVE_END: 18,\n    PAR_START: 19,\n    PAR_AND: 20,\n    PAR_END: 21,\n    RECT_START: 22,\n    RECT_END: 23,\n    SOLID_POINT: 24,\n    DOTTED_POINT: 25,\n    AUTONUMBER: 26,\n    CRITICAL_START: 27,\n    CRITICAL_OPTION: 28,\n    CRITICAL_END: 29,\n    BREAK_START: 30,\n    BREAK_END: 31,\n    PAR_OVER_START: 32,\n};\nconst getStrokeStyle = (type) => {\n    let strokeStyle;\n    switch (type) {\n        case MESSAGE_TYPE.SOLID:\n        case MESSAGE_TYPE.SOLID_CROSS:\n        case MESSAGE_TYPE.SOLID_OPEN:\n        case MESSAGE_TYPE.SOLID_POINT:\n            strokeStyle = \"solid\";\n            break;\n        case MESSAGE_TYPE.DOTTED:\n        case MESSAGE_TYPE.DOTTED_CROSS:\n        case MESSAGE_TYPE.DOTTED_OPEN:\n        case MESSAGE_TYPE.DOTTED_POINT:\n            strokeStyle = \"dotted\";\n            break;\n        default:\n            strokeStyle = \"solid\";\n            break;\n    }\n    return strokeStyle;\n};\nconst attachSequenceNumberToArrow = (node, arrow) => {\n    const showSequenceNumber = !!node.nextElementSibling?.classList.contains(\"sequenceNumber\");\n    if (showSequenceNumber) {\n        const text = node.nextElementSibling?.textContent;\n        if (!text) {\n            throw new Error(\"sequence number not present\");\n        }\n        const height = 30;\n        const yOffset = height / 2;\n        const xOffset = 10;\n        const sequenceNumber = {\n            type: \"rectangle\",\n            x: arrow.startX - xOffset,\n            y: arrow.startY - yOffset,\n            label: { text, fontSize: 14 },\n            bgColor: \"#e9ecef\",\n            height,\n            subtype: \"sequence\",\n        };\n        Object.assign(arrow, { sequenceNumber });\n    }\n};\nconst createActorSymbol = (rootNode, text, opts) => {\n    if (!rootNode) {\n        throw \"root node not found\";\n    }\n    const groupId = nanoid();\n    const children = Array.from(rootNode.children);\n    const nodeElements = [];\n    children.forEach((child, index) => {\n        const id = `${opts?.id}-${index}`;\n        let ele;\n        switch (child.tagName) {\n            case \"line\":\n                const startX = Number(child.getAttribute(\"x1\"));\n                const startY = Number(child.getAttribute(\"y1\"));\n                const endX = Number(child.getAttribute(\"x2\"));\n                const endY = Number(child.getAttribute(\"y2\"));\n                ele = createLineSkeletonFromSVG(child, startX, startY, endX, endY, { groupId, id });\n                break;\n            case \"text\":\n                ele = createTextSkeletonFromSVG(child, text, {\n                    groupId,\n                    id,\n                });\n                break;\n            case \"circle\":\n                ele = createContainerSkeletonFromSVG(child, \"ellipse\", {\n                    label: child.textContent ? { text: child.textContent } : undefined,\n                    groupId,\n                    id,\n                });\n            default:\n                ele = createContainerSkeletonFromSVG(child, SVG_TO_SHAPE_MAPPER[child.tagName], {\n                    label: child.textContent ? { text: child.textContent } : undefined,\n                    groupId,\n                    id,\n                });\n        }\n        nodeElements.push(ele);\n    });\n    return nodeElements;\n};\nconst parseActor = (actors, containerEl) => {\n    const actorTopNodes = Array.from(containerEl.querySelectorAll(\".actor-top\"));\n    const actorBottomNodes = Array.from(containerEl.querySelectorAll(\".actor-bottom\"));\n    const nodes = [];\n    const lines = [];\n    Object.values(actors).forEach((actor, index) => {\n        const topRootNode = actorTopNodes.find((actorNode) => actorNode.getAttribute(\"name\") === actor.name);\n        const bottomRootNode = actorBottomNodes.find((actorNode) => actorNode.getAttribute(\"name\") === actor.name);\n        if (!topRootNode || !bottomRootNode) {\n            throw \"root not found\";\n        }\n        const text = actor.description;\n        if (actor.type === \"participant\") {\n            // creating top actor node element\n            const topNodeElement = createContainerSkeletonFromSVG(topRootNode, \"rectangle\", { id: `${actor.name}-top`, label: { text }, subtype: \"actor\" });\n            if (!topNodeElement) {\n                throw \"Top Node element not found!\";\n            }\n            nodes.push([topNodeElement]);\n            // creating bottom actor node element\n            const bottomNodeElement = createContainerSkeletonFromSVG(bottomRootNode, \"rectangle\", { id: `${actor.name}-bottom`, label: { text }, subtype: \"actor\" });\n            nodes.push([bottomNodeElement]);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling parent of top root node\n            const lineNode = topRootNode?.parentElement\n                ?.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            if (!topNodeElement.height) {\n                throw \"Top node element height is null\";\n            }\n            const startY = topNodeElement.y + topNodeElement.height;\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const endY = bottomNodeElement.y;\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);\n            lines.push(line);\n        }\n        else if (actor.type === \"actor\") {\n            const topNodeElement = createActorSymbol(topRootNode, text, {\n                id: `${actor.name}-top`,\n            });\n            nodes.push(topNodeElement);\n            const bottomNodeElement = createActorSymbol(bottomRootNode, text, {\n                id: `${actor.name}-bottom`,\n            });\n            nodes.push(bottomNodeElement);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling of the actor root element\n            const lineNode = topRootNode.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const bottomEllipseNode = bottomNodeElement.find((node) => node.type === \"ellipse\");\n            if (bottomEllipseNode) {\n                const endY = bottomEllipseNode.y;\n                const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);\n                lines.push(line);\n            }\n        }\n    });\n    return { nodes, lines };\n};\nconst computeArrows = (messages, containerEl) => {\n    const arrows = [];\n    const arrowNodes = Array.from(containerEl.querySelectorAll('[class*=\"messageLine\"]'));\n    const supportedMessageTypes = Object.keys(SEQUENCE_ARROW_TYPES);\n    const arrowMessages = messages.filter((message) => supportedMessageTypes.includes(message.type.toString()));\n    arrowNodes.forEach((arrowNode, index) => {\n        const message = arrowMessages[index];\n        const messageType = SEQUENCE_ARROW_TYPES[message.type];\n        const arrow = createArrowSkeletonFromSVG(arrowNode, {\n            label: message?.message,\n            strokeStyle: getStrokeStyle(message.type),\n            endArrowhead: messageType === \"SOLID_OPEN\" || messageType === \"DOTTED_OPEN\"\n                ? null\n                : \"arrow\",\n        });\n        attachSequenceNumberToArrow(arrowNode, arrow);\n        arrows.push(arrow);\n    });\n    return arrows;\n};\nconst computeNotes = (messages, containerEl) => {\n    const noteNodes = Array.from(containerEl.querySelectorAll(\".note\")).map((node) => node.parentElement);\n    const noteText = messages.filter((message) => message.type === MESSAGE_TYPE.NOTE);\n    const notes = [];\n    noteNodes.forEach((node, index) => {\n        if (!node) {\n            return;\n        }\n        const rect = node.firstChild;\n        const text = noteText[index].message;\n        const note = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            label: { text },\n            subtype: \"note\",\n        });\n        notes.push(note);\n    });\n    return notes;\n};\nconst parseActivations = (containerEl) => {\n    const activationNodes = Array.from(containerEl.querySelectorAll(`[class*=activation]`));\n    const activations = [];\n    activationNodes.forEach((node) => {\n        const rect = createContainerSkeletonFromSVG(node, \"rectangle\", {\n            label: { text: \"\" },\n            subtype: \"activation\",\n        });\n        activations.push(rect);\n    });\n    return activations;\n};\nconst parseLoops = (messages, containerEl) => {\n    const lineNodes = Array.from(containerEl.querySelectorAll(\".loopLine\"));\n    const lines = [];\n    const texts = [];\n    const nodes = [];\n    lineNodes.forEach((node) => {\n        const startX = Number(node.getAttribute(\"x1\"));\n        const startY = Number(node.getAttribute(\"y1\"));\n        const endX = Number(node.getAttribute(\"x2\"));\n        const endY = Number(node.getAttribute(\"y2\"));\n        const line = createLineSkeletonFromSVG(node, startX, startY, endX, endY);\n        line.strokeStyle = \"dotted\";\n        line.strokeColor = \"#adb5bd\";\n        line.strokeWidth = 2;\n        lines.push(line);\n    });\n    const loopTextNodes = Array.from(containerEl.querySelectorAll(\".loopText\"));\n    const criticalMessages = messages\n        .filter((message) => message.type === MESSAGE_TYPE.CRITICAL_START)\n        .map((message) => message.message);\n    loopTextNodes.forEach((node) => {\n        const text = node.textContent || \"\";\n        const textElement = createTextSkeletonFromSVG(node, text);\n        // The text is rendered between [ ] in DOM hence getting the text excluding the [ ]\n        const rawText = text.match(/\\[(.*?)\\]/)?.[1] || \"\";\n        const isCritical = criticalMessages.includes(rawText);\n        // For critical label the coordinates are not accurate in mermaid as there is\n        // no padding left hence shifting the text next to critical label by 16px (font size)\n        if (isCritical) {\n            textElement.x += 16;\n        }\n        texts.push(textElement);\n    });\n    const labelBoxes = Array.from(containerEl?.querySelectorAll(\".labelBox\"));\n    const labelTextNode = Array.from(containerEl?.querySelectorAll(\".labelText\"));\n    labelBoxes.forEach((labelBox, index) => {\n        const text = labelTextNode[index]?.textContent || \"\";\n        const container = createContainerSkeletonFromSVG(labelBox, \"rectangle\", {\n            label: { text },\n        });\n        container.strokeColor = \"#adb5bd\";\n        container.bgColor = \"#e9ecef\";\n        // So width is calculated based on label\n        container.width = undefined;\n        nodes.push(container);\n    });\n    return { lines, texts, nodes };\n};\nconst computeHighlights = (containerEl) => {\n    const rects = Array.from(containerEl.querySelectorAll(\".rect\"))\n        // Only drawing specifically for highlights as the same selector is for grouping as well. For grouping we\n        // draw it ourselves\n        .filter((node) => node.parentElement?.tagName !== \"g\");\n    const nodes = [];\n    rects.forEach((rect) => {\n        const node = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            label: { text: \"\" },\n            subtype: \"highlight\",\n        });\n        nodes.push(node);\n    });\n    return nodes;\n};\nexport const parseMermaidSequenceDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const nodes = [];\n    const groups = mermaidParser.getBoxes();\n    const bgHightlights = computeHighlights(containerEl);\n    const actorData = mermaidParser.getActors();\n    const { nodes: actors, lines } = parseActor(actorData, containerEl);\n    const messages = mermaidParser.getMessages();\n    const arrows = computeArrows(messages, containerEl);\n    const notes = computeNotes(messages, containerEl);\n    const activations = parseActivations(containerEl);\n    const loops = parseLoops(messages, containerEl);\n    nodes.push(bgHightlights);\n    nodes.push(...actors);\n    nodes.push(notes);\n    nodes.push(activations);\n    return { type: \"sequence\", lines, arrows, nodes, loops, groups };\n};\n"],"names":["SEQUENCE_ARROW_TYPES","MESSAGE_TYPE","getStrokeStyle","type","strokeStyle","createActorSymbol","rootNode","text","opts","groupId","nanoid","children","Array","from","nodeElements","forEach","child","index","id","ele","tagName","startX","Number","getAttribute","startY","endX","endY","createLineSkeletonFromSVG","createTextSkeletonFromSVG","createContainerSkeletonFromSVG","label","textContent","undefined","SVG_TO_SHAPE_MAPPER","push","computeArrows","messages","containerEl","arrows","arrowNodes","querySelectorAll","supportedMessageTypes","Object","keys","arrowMessages","filter","message","includes","toString","arrowNode","messageType","arrow","createArrowSkeletonFromSVG","endArrowhead","node","nextElementSibling","classList","contains","Error","height","yOffset","xOffset","sequenceNumber","x","y","fontSize","bgColor","subtype","assign","attachSequenceNumberToArrow","parseMermaidSequenceDiagram","diagram","parse","mermaidParser","parser","yy","nodes","groups","getBoxes","bgHightlights","rects","parentElement","rect","computeHighlights","actorData","getActors","actors","lines","actorTopNodes","actorBottomNodes","values","actor","topRootNode","find","actorNode","name","bottomRootNode","description","topNodeElement","bottomNodeElement","lineNode","previousElementSibling","line","bottomEllipseNode","parseActor","getMessages","notes","noteNodes","map","noteText","firstChild","note","computeNotes","activations","activationNodes","parseActivations","loops","lineNodes","texts","strokeColor","strokeWidth","loopTextNodes","criticalMessages","textElement","rawText","match","labelBoxes","labelTextNode","labelBox","container","width","parseLoops"],"mappings":"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"}