{"version":3,"file":"class.js","sources":["../../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/class.js"],"sourcesContent":["import { nanoid } from \"nanoid\";\nimport { computeEdgePositions, getTransformAttr } from \"../utils.js\";\nimport { createArrowSkeletion, createContainerSkeletonFromSVG, createLineSkeletonFromSVG, createTextSkeleton, } from \"../elementSkeleton.js\";\n// Taken from mermaidParser.relationType\nconst RELATION_TYPE = {\n    AGGREGATION: 0,\n    EXTENSION: 1,\n    COMPOSITION: 2,\n    DEPENDENCY: 3,\n    LOLLIPOP: 4,\n};\n// Taken from mermaidParser.lineType\nconst LINE_TYPE = {\n    LINE: 0,\n    DOTTED_LINE: 1,\n};\n// This is the offset to update the arrow head postition for rendering in excalidraw as mermaid calculates the position until the start of arrowhead\nconst MERMAID_ARROW_HEAD_OFFSET = 16;\nconst getStrokeStyle = (type) => {\n    let lineType;\n    switch (type) {\n        case LINE_TYPE.LINE:\n            lineType = \"solid\";\n            break;\n        case LINE_TYPE.DOTTED_LINE:\n            lineType = \"dotted\";\n            break;\n        default:\n            lineType = \"solid\";\n    }\n    return lineType;\n};\nconst getArrowhead = (type) => {\n    let arrowhead;\n    switch (type) {\n        case RELATION_TYPE.AGGREGATION:\n            arrowhead = \"diamond_outline\";\n            break;\n        case RELATION_TYPE.COMPOSITION:\n            arrowhead = \"diamond\";\n            break;\n        case RELATION_TYPE.EXTENSION:\n            arrowhead = \"triangle_outline\";\n            break;\n        case \"none\":\n            arrowhead = null;\n            break;\n        case RELATION_TYPE.DEPENDENCY:\n        default:\n            arrowhead = \"arrow\";\n            break;\n    }\n    return arrowhead;\n};\nconst parseClasses = (classes, containerEl) => {\n    const nodes = [];\n    const lines = [];\n    const text = [];\n    Object.values(classes).forEach((classNode) => {\n        const { domId, id: classId } = classNode;\n        const groupId = nanoid();\n        const domNode = containerEl.querySelector(`[data-id=${classId}]`);\n        if (!domNode) {\n            throw Error(`DOM Node with id ${domId} not found`);\n        }\n        const { transformX, transformY } = getTransformAttr(domNode);\n        const container = createContainerSkeletonFromSVG(domNode.firstChild, \"rectangle\", { id: classId, groupId });\n        container.x += transformX;\n        container.y += transformY;\n        container.metadata = { classId };\n        nodes.push(container);\n        const lineNodes = Array.from(domNode.querySelectorAll(\".divider\"));\n        lineNodes.forEach((lineNode) => {\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const endY = Number(lineNode.getAttribute(\"y2\"));\n            const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY, {\n                groupId,\n                id: nanoid(),\n            });\n            line.startX += transformX;\n            line.startY += transformY;\n            line.endX += transformX;\n            line.endY += transformY;\n            line.metadata = { classId };\n            lines.push(line);\n        });\n        const labelNodes = domNode.querySelector(\".label\")?.children;\n        if (!labelNodes) {\n            throw \"label nodes not found\";\n        }\n        Array.from(labelNodes).forEach((node) => {\n            const label = node.textContent;\n            if (!label) {\n                return;\n            }\n            const id = nanoid();\n            const { transformX: textTransformX, transformY: textTransformY } = getTransformAttr(node);\n            const boundingBox = node.getBBox();\n            const offsetY = 10;\n            const textElement = createTextSkeleton(transformX + textTransformX, transformY + textTransformY + offsetY, label, {\n                width: boundingBox.width,\n                height: boundingBox.height,\n                id,\n                groupId,\n                metadata: { classId },\n            });\n            text.push(textElement);\n        });\n    });\n    return { nodes, lines, text };\n};\n// update arrow position by certain offset for triangle and diamond arrow head types\n// as mermaid calculates the position until the start of arrowhead\n// for reference - https://github.com/mermaid-js/mermaid/issues/5417\nconst adjustArrowPosition = (direction, arrow) => {\n    // The arrowhead shapes where we need to update the position by a 16px offset\n    const arrowHeadShapes = [\"triangle_outline\", \"diamond\", \"diamond_outline\"];\n    const shouldUpdateStartArrowhead = arrow.startArrowhead && arrowHeadShapes.includes(arrow.startArrowhead);\n    const shouldUpdateEndArrowhead = arrow.endArrowhead && arrowHeadShapes.includes(arrow.endArrowhead);\n    if (!shouldUpdateEndArrowhead && !shouldUpdateStartArrowhead) {\n        return arrow;\n    }\n    if (shouldUpdateStartArrowhead) {\n        if (direction === \"LR\") {\n            arrow.startX -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"RL\") {\n            arrow.startX += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"TB\") {\n            arrow.startY -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"BT\") {\n            arrow.startY += MERMAID_ARROW_HEAD_OFFSET;\n        }\n    }\n    if (shouldUpdateEndArrowhead) {\n        if (direction === \"LR\") {\n            arrow.endX += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"RL\") {\n            arrow.endX -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"TB\") {\n            arrow.endY += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"BT\") {\n            arrow.endY -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n    }\n    return arrow;\n};\nconst parseRelations = (relations, classNodes, containerEl, direction) => {\n    const edges = containerEl.querySelector(\".edgePaths\")?.children;\n    if (!edges) {\n        throw new Error(\"No Edges found!\");\n    }\n    const arrows = [];\n    const text = [];\n    relations.forEach((relationNode, index) => {\n        const { id1, id2, relation } = relationNode;\n        const node1 = classNodes.find((node) => node.id === id1);\n        const node2 = classNodes.find((node) => node.id === id2);\n        const strokeStyle = getStrokeStyle(relation.lineType);\n        const startArrowhead = getArrowhead(relation.type1);\n        const endArrowhead = getArrowhead(relation.type2);\n        const edgePositionData = computeEdgePositions(edges[index]);\n        const arrowSkeletion = createArrowSkeletion(edgePositionData.startX, edgePositionData.startY, edgePositionData.endX, edgePositionData.endY, {\n            strokeStyle,\n            startArrowhead,\n            endArrowhead,\n            label: relationNode.title ? { text: relationNode.title } : undefined,\n            start: { type: \"rectangle\", id: node1.id },\n            end: { type: \"rectangle\", id: node2.id },\n        });\n        const arrow = adjustArrowPosition(direction, arrowSkeletion);\n        arrows.push(arrow);\n        // Add cardianlities and Multiplicities\n        const { relationTitle1, relationTitle2 } = relationNode;\n        const offsetX = 20;\n        const offsetY = 15;\n        const directionOffset = 15;\n        let x;\n        let y;\n        if (relationTitle1 && relationTitle1 !== \"none\") {\n            switch (direction) {\n                case \"TB\":\n                    x = arrow.startX - offsetX;\n                    if (arrow.endX < arrow.startX) {\n                        x -= directionOffset;\n                    }\n                    y = arrow.startY + offsetY;\n                    break;\n                case \"BT\":\n                    x = arrow.startX + offsetX;\n                    if (arrow.endX > arrow.startX) {\n                        x += directionOffset;\n                    }\n                    y = arrow.startY - offsetY;\n                    break;\n                case \"LR\":\n                    x = arrow.startX + offsetX;\n                    y = arrow.startY + offsetY;\n                    if (arrow.endY > arrow.startY) {\n                        y += directionOffset;\n                    }\n                    break;\n                case \"RL\":\n                    x = arrow.startX - offsetX;\n                    y = arrow.startY - offsetY;\n                    if (arrow.startY > arrow.endY) {\n                        y -= directionOffset;\n                    }\n                    break;\n                default:\n                    x = arrow.startX - offsetX;\n                    y = arrow.startY + offsetY;\n            }\n            const relationTitleElement = createTextSkeleton(x, y, relationTitle1, {\n                fontSize: 16,\n            });\n            text.push(relationTitleElement);\n        }\n        if (relationTitle2 && relationTitle2 !== \"none\") {\n            switch (direction) {\n                case \"TB\":\n                    x = arrow.endX + offsetX;\n                    if (arrow.endX < arrow.startX) {\n                        x += directionOffset;\n                    }\n                    y = arrow.endY - offsetY;\n                    break;\n                case \"BT\":\n                    x = arrow.endX - offsetX;\n                    if (arrow.endX > arrow.startX) {\n                        x -= directionOffset;\n                    }\n                    y = arrow.endY + offsetY;\n                    break;\n                case \"LR\":\n                    x = arrow.endX - offsetX;\n                    y = arrow.endY - offsetY;\n                    if (arrow.endY > arrow.startY) {\n                        y -= directionOffset;\n                    }\n                    break;\n                case \"RL\":\n                    x = arrow.endX + offsetX;\n                    y = arrow.endY + offsetY;\n                    if (arrow.startY > arrow.endY) {\n                        y += directionOffset;\n                    }\n                    break;\n                default:\n                    x = arrow.endX + offsetX;\n                    y = arrow.endY - offsetY;\n            }\n            const relationTitleElement = createTextSkeleton(x, y, relationTitle2, {\n                fontSize: 16,\n            });\n            text.push(relationTitleElement);\n        }\n    });\n    return { arrows, text };\n};\nconst parseNotes = (notes, containerEl, classNodes) => {\n    const noteContainers = [];\n    const connectors = [];\n    notes.forEach((note) => {\n        const { id, text, class: classId } = note;\n        const node = containerEl.querySelector(`#${id}`);\n        if (!node) {\n            throw new Error(`Node with id ${id} not found!`);\n        }\n        const { transformX, transformY } = getTransformAttr(node);\n        const rect = node.firstChild;\n        const container = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            id,\n            subtype: \"note\",\n            label: { text },\n        });\n        Object.assign(container, {\n            x: container.x + transformX,\n            y: container.y + transformY,\n        });\n        noteContainers.push(container);\n        if (classId) {\n            const classNode = classNodes.find((node) => node.id === classId);\n            if (!classNode) {\n                throw new Error(`class node with id ${classId} not found!`);\n            }\n            const startX = container.x + (container.width || 0) / 2;\n            const startY = container.y + (container.height || 0);\n            const endX = startX;\n            const endY = classNode.y;\n            const connector = createArrowSkeletion(startX, startY, endX, endY, {\n                strokeStyle: \"dotted\",\n                startArrowhead: null,\n                endArrowhead: null,\n                start: { id: container.id, type: \"rectangle\" },\n                end: { id: classNode.id, type: \"rectangle\" },\n            });\n            connectors.push(connector);\n        }\n    });\n    return { notes: noteContainers, connectors };\n};\nexport const parseMermaidClassDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const direction = mermaidParser.getDirection();\n    const nodes = [];\n    const lines = [];\n    const text = [];\n    const classNodes = [];\n    const namespaces = mermaidParser.getNamespaces();\n    const classes = mermaidParser.getClasses();\n    if (Object.keys(classes).length) {\n        const classData = parseClasses(classes, containerEl);\n        nodes.push(classData.nodes);\n        lines.push(...classData.lines);\n        text.push(...classData.text);\n        classNodes.push(...classData.nodes);\n    }\n    const relations = mermaidParser.getRelations();\n    const { arrows, text: relationTitles } = parseRelations(relations, classNodes, containerEl, direction);\n    const { notes, connectors } = parseNotes(mermaidParser.getNotes(), containerEl, classNodes);\n    nodes.push(notes);\n    arrows.push(...connectors);\n    text.push(...relationTitles);\n    return { type: \"class\", nodes, lines, arrows, text, namespaces };\n};\n"],"names":["RELATION_TYPE","LINE_TYPE","MERMAID_ARROW_HEAD_OFFSET","getArrowhead","type","arrowhead","parseRelations","relations","classNodes","containerEl","direction","edges","querySelector","children","Error","arrows","text","forEach","relationNode","index","id1","id2","relation","node1","find","node","id","node2","strokeStyle","lineType","getStrokeStyle","startArrowhead","type1","endArrowhead","type2","edgePositionData","computeEdgePositions","arrowSkeletion","createArrowSkeletion","startX","startY","endX","endY","label","title","undefined","start","end","arrow","arrowHeadShapes","shouldUpdateStartArrowhead","includes","shouldUpdateEndArrowhead","adjustArrowPosition","push","relationTitle1","relationTitle2","offsetX","offsetY","directionOffset","x","y","relationTitleElement","createTextSkeleton","fontSize","parseMermaidClassDiagram","diagram","parse","mermaidParser","parser","yy","getDirection","nodes","lines","namespaces","getNamespaces","classes","getClasses","Object","keys","length","classData","values","classNode","domId","classId","groupId","nanoid","domNode","transformX","transformY","getTransformAttr","container","createContainerSkeletonFromSVG","firstChild","metadata","Array","from","querySelectorAll","lineNode","Number","getAttribute","line","createLineSkeletonFromSVG","labelNodes","textContent","textTransformX","textTransformY","boundingBox","getBBox","textElement","width","height","parseClasses","getRelations","relationTitles","notes","connectors","noteContainers","note","class","rect","subtype","assign","connector","parseNotes","getNotes"],"mappings":"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"}