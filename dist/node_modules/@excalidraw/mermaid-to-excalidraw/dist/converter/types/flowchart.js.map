{"version":3,"file":"flowchart.js","sources":["../../../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/flowchart.js"],"sourcesContent":["import { GraphConverter } from \"../GraphConverter.js\";\nimport { getText, computeExcalidrawVertexStyle, computeExcalidrawVertexLabelStyle, computeExcalidrawArrowType, } from \"../helpers.js\";\nimport { VERTEX_TYPE } from \"../../interfaces.js\";\nconst computeGroupIds = (graph) => {\n    // Parse the diagram into a tree for rendering and grouping\n    const tree = {};\n    graph.subGraphs.map((subGraph) => {\n        subGraph.nodeIds.forEach((nodeId) => {\n            tree[subGraph.id] = {\n                id: subGraph.id,\n                parent: null,\n                isLeaf: false,\n            };\n            tree[nodeId] = {\n                id: nodeId,\n                parent: subGraph.id,\n                isLeaf: graph.vertices[nodeId] !== undefined,\n            };\n        });\n    });\n    const mapper = {};\n    [...Object.keys(graph.vertices), ...graph.subGraphs.map((c) => c.id)].forEach((id) => {\n        if (!tree[id]) {\n            return;\n        }\n        let curr = tree[id];\n        const groupIds = [];\n        if (!curr.isLeaf) {\n            groupIds.push(`subgraph_group_${curr.id}`);\n        }\n        while (true) {\n            if (curr.parent) {\n                groupIds.push(`subgraph_group_${curr.parent}`);\n                curr = tree[curr.parent];\n            }\n            else {\n                break;\n            }\n        }\n        mapper[id] = groupIds;\n    });\n    return {\n        getGroupIds: (elementId) => {\n            return mapper[elementId] || [];\n        },\n        getParentId: (elementId) => {\n            return tree[elementId] ? tree[elementId].parent : null;\n        },\n    };\n};\nexport const FlowchartToExcalidrawSkeletonConverter = new GraphConverter({\n    converter: (graph, options) => {\n        const elements = [];\n        const fontSize = options.fontSize;\n        const { getGroupIds, getParentId } = computeGroupIds(graph);\n        // SubGraphs\n        graph.subGraphs.reverse().forEach((subGraph) => {\n            const groupIds = getGroupIds(subGraph.id);\n            const containerElement = {\n                id: subGraph.id,\n                type: \"rectangle\",\n                groupIds,\n                x: subGraph.x,\n                y: subGraph.y,\n                width: subGraph.width,\n                height: subGraph.height,\n                label: {\n                    groupIds,\n                    text: getText(subGraph),\n                    fontSize,\n                    verticalAlign: \"top\",\n                },\n            };\n            elements.push(containerElement);\n        });\n        // Vertices\n        Object.values(graph.vertices).forEach((vertex) => {\n            if (!vertex) {\n                return;\n            }\n            const groupIds = getGroupIds(vertex.id);\n            // Compute custom style\n            const containerStyle = computeExcalidrawVertexStyle(vertex.containerStyle);\n            const labelStyle = computeExcalidrawVertexLabelStyle(vertex.labelStyle);\n            let containerElement = {\n                id: vertex.id,\n                type: \"rectangle\",\n                groupIds,\n                x: vertex.x,\n                y: vertex.y,\n                width: vertex.width,\n                height: vertex.height,\n                strokeWidth: 2,\n                label: {\n                    groupIds,\n                    text: getText(vertex),\n                    fontSize,\n                    ...labelStyle,\n                },\n                link: vertex.link || null,\n                ...containerStyle,\n            };\n            switch (vertex.type) {\n                case VERTEX_TYPE.STADIUM: {\n                    containerElement = { ...containerElement, roundness: { type: 3 } };\n                    break;\n                }\n                case VERTEX_TYPE.ROUND: {\n                    containerElement = { ...containerElement, roundness: { type: 3 } };\n                    break;\n                }\n                case VERTEX_TYPE.DOUBLECIRCLE: {\n                    const CIRCLE_MARGIN = 5;\n                    // Create new groupId for double circle\n                    groupIds.push(`doublecircle_${vertex.id}}`);\n                    // Create inner circle element\n                    const innerCircle = {\n                        type: \"ellipse\",\n                        groupIds,\n                        x: vertex.x + CIRCLE_MARGIN,\n                        y: vertex.y + CIRCLE_MARGIN,\n                        width: vertex.width - CIRCLE_MARGIN * 2,\n                        height: vertex.height - CIRCLE_MARGIN * 2,\n                        strokeWidth: 2,\n                        roundness: { type: 3 },\n                        label: {\n                            groupIds,\n                            text: getText(vertex),\n                            fontSize,\n                        },\n                    };\n                    containerElement = { ...containerElement, groupIds, type: \"ellipse\" };\n                    elements.push(innerCircle);\n                    break;\n                }\n                case VERTEX_TYPE.CIRCLE: {\n                    containerElement.type = \"ellipse\";\n                    break;\n                }\n                case VERTEX_TYPE.DIAMOND: {\n                    containerElement.type = \"diamond\";\n                    break;\n                }\n            }\n            elements.push(containerElement);\n        });\n        // Edges\n        graph.edges.forEach((edge) => {\n            let groupIds = [];\n            const startParentId = getParentId(edge.start);\n            const endParentId = getParentId(edge.end);\n            if (startParentId && startParentId === endParentId) {\n                groupIds = getGroupIds(startParentId);\n            }\n            // Get arrow position data\n            const { startX, startY, reflectionPoints } = edge;\n            // Calculate Excalidraw arrow's points\n            const points = reflectionPoints.map((point) => [\n                point.x - reflectionPoints[0].x,\n                point.y - reflectionPoints[0].y,\n            ]);\n            // Get supported arrow type\n            const arrowType = computeExcalidrawArrowType(edge.type);\n            const arrowId = `${edge.start}_${edge.end}`;\n            const containerElement = {\n                id: arrowId,\n                type: \"arrow\",\n                groupIds,\n                x: startX,\n                y: startY,\n                // 4 and 2 are the Excalidraw's stroke width of thick and thin respectively\n                // TODO: use constant exported from Excalidraw package\n                strokeWidth: edge.stroke === \"thick\" ? 4 : 2,\n                strokeStyle: edge.stroke === \"dotted\" ? \"dashed\" : undefined,\n                points,\n                ...(edge.text\n                    ? { label: { text: getText(edge), fontSize, groupIds } }\n                    : {}),\n                roundness: {\n                    type: 2,\n                },\n                ...arrowType,\n            };\n            // Bind start and end vertex to arrow\n            const startVertex = elements.find((e) => e.id === edge.start);\n            const endVertex = elements.find((e) => e.id === edge.end);\n            if (!startVertex || !endVertex) {\n                return;\n            }\n            containerElement.start = {\n                id: startVertex.id || \"\",\n            };\n            containerElement.end = {\n                id: endVertex.id || \"\",\n            };\n            elements.push(containerElement);\n        });\n        return {\n            elements,\n        };\n    },\n});\n"],"names":["FlowchartToExcalidrawSkeletonConverter","GraphConverter","converter","graph","options","elements","fontSize","getGroupIds","getParentId","tree","subGraphs","map","subGraph","nodeIds","forEach","nodeId","id","parent","isLeaf","undefined","vertices","mapper","Object","keys","c","curr","groupIds","push","elementId","computeGroupIds","reverse","containerElement","type","x","y","width","height","label","text","getText","verticalAlign","values","vertex","containerStyle","computeExcalidrawVertexStyle","labelStyle","computeExcalidrawVertexLabelStyle","strokeWidth","link","VERTEX_TYPE","STADIUM","ROUND","roundness","DOUBLECIRCLE","CIRCLE_MARGIN","innerCircle","CIRCLE","DIAMOND","edges","edge","startParentId","start","endParentId","end","startX","startY","reflectionPoints","points","point","arrowType","computeExcalidrawArrowType","stroke","strokeStyle","startVertex","find","e","endVertex"],"mappings":"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"}