{"version":3,"file":"sequence.js","sources":["../../../../../../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/sequence.js"],"sourcesContent":["import { nanoid } from \"nanoid\";\nimport { GraphConverter } from \"../GraphConverter.js\";\nimport { transformToExcalidrawLineSkeleton, transformToExcalidrawTextSkeleton, transformToExcalidrawContainerSkeleton, transformToExcalidrawArrowSkeleton, } from \"../transformToExcalidrawSkeleton.js\";\nexport const SequenceToExcalidrawSkeletonConvertor = new GraphConverter({\n    converter: (chart) => {\n        const elements = [];\n        const activations = [];\n        Object.values(chart.nodes).forEach((node) => {\n            if (!node || !node.length) {\n                return;\n            }\n            node.forEach((element) => {\n                let excalidrawElement;\n                switch (element.type) {\n                    case \"line\":\n                        excalidrawElement = transformToExcalidrawLineSkeleton(element);\n                        break;\n                    case \"rectangle\":\n                    case \"ellipse\":\n                        excalidrawElement = transformToExcalidrawContainerSkeleton(element);\n                        break;\n                    case \"text\":\n                        excalidrawElement = transformToExcalidrawTextSkeleton(element);\n                        break;\n                    default:\n                        throw `unknown type ${element.type}`;\n                        break;\n                }\n                if (element.type === \"rectangle\" && element?.subtype === \"activation\") {\n                    activations.push(excalidrawElement);\n                }\n                else {\n                    elements.push(excalidrawElement);\n                }\n            });\n        });\n        Object.values(chart.lines).forEach((line) => {\n            if (!line) {\n                return;\n            }\n            elements.push(transformToExcalidrawLineSkeleton(line));\n        });\n        Object.values(chart.arrows).forEach((arrow) => {\n            if (!arrow) {\n                return;\n            }\n            elements.push(transformToExcalidrawArrowSkeleton(arrow));\n            if (arrow.sequenceNumber) {\n                elements.push(transformToExcalidrawContainerSkeleton(arrow.sequenceNumber));\n            }\n        });\n        elements.push(...activations);\n        // loops\n        if (chart.loops) {\n            const { lines, texts, nodes } = chart.loops;\n            lines.forEach((line) => {\n                elements.push(transformToExcalidrawLineSkeleton(line));\n            });\n            texts.forEach((text) => {\n                elements.push(transformToExcalidrawTextSkeleton(text));\n            });\n            nodes.forEach((node) => {\n                elements.push(transformToExcalidrawContainerSkeleton(node));\n            });\n        }\n        if (chart.groups) {\n            chart.groups.forEach((group) => {\n                const { actorKeys, name } = group;\n                let minX = Infinity;\n                let minY = Infinity;\n                let maxX = 0;\n                let maxY = 0;\n                if (!actorKeys.length) {\n                    return;\n                }\n                const actors = elements.filter((ele) => {\n                    if (ele.id) {\n                        const hyphenIndex = ele.id.indexOf(\"-\");\n                        const id = ele.id.substring(0, hyphenIndex);\n                        return actorKeys.includes(id);\n                    }\n                });\n                actors.forEach((actor) => {\n                    if (actor.x === undefined ||\n                        actor.y === undefined ||\n                        actor.width === undefined ||\n                        actor.height === undefined) {\n                        throw new Error(`Actor attributes missing ${actor}`);\n                    }\n                    minX = Math.min(minX, actor.x);\n                    minY = Math.min(minY, actor.y);\n                    maxX = Math.max(maxX, actor.x + actor.width);\n                    maxY = Math.max(maxY, actor.y + actor.height);\n                });\n                // Draw the outer rectangle enclosing the group elements\n                const PADDING = 10;\n                const groupRectX = minX - PADDING;\n                const groupRectY = minY - PADDING;\n                const groupRectWidth = maxX - minX + PADDING * 2;\n                const groupRectHeight = maxY - minY + PADDING * 2;\n                const groupRectId = nanoid();\n                const groupRect = transformToExcalidrawContainerSkeleton({\n                    type: \"rectangle\",\n                    x: groupRectX,\n                    y: groupRectY,\n                    width: groupRectWidth,\n                    height: groupRectHeight,\n                    bgColor: group.fill,\n                    id: groupRectId,\n                });\n                elements.unshift(groupRect);\n                const frameId = nanoid();\n                const frameChildren = [groupRectId];\n                elements.forEach((ele) => {\n                    if (ele.type === \"frame\") {\n                        return;\n                    }\n                    if (ele.x === undefined ||\n                        ele.y === undefined ||\n                        ele.width === undefined ||\n                        ele.height === undefined) {\n                        throw new Error(`Element attributes missing ${ele}`);\n                    }\n                    if (ele.x >= minX &&\n                        ele.x + ele.width <= maxX &&\n                        ele.y >= minY &&\n                        ele.y + ele.height <= maxY) {\n                        const elementId = ele.id || nanoid();\n                        if (!ele.id) {\n                            Object.assign(ele, { id: elementId });\n                        }\n                        frameChildren.push(elementId);\n                    }\n                });\n                const frame = {\n                    type: \"frame\",\n                    id: frameId,\n                    name,\n                    children: frameChildren,\n                };\n                elements.push(frame);\n            });\n        }\n        return { elements };\n    },\n});\n"],"names":["SequenceToExcalidrawSkeletonConvertor","GraphConverter","converter","chart","elements","activations","Object","values","nodes","forEach","node","length","element","excalidrawElement","type","transformToExcalidrawLineSkeleton","transformToExcalidrawContainerSkeleton","transformToExcalidrawTextSkeleton","subtype","push","lines","line","arrows","arrow","transformToExcalidrawArrowSkeleton","sequenceNumber","loops","texts","text","groups","group","actorKeys","name","minX","Infinity","minY","maxX","maxY","filter","ele","id","hyphenIndex","indexOf","substring","includes","actor","undefined","x","y","width","height","Error","Math","min","max","groupRectX","groupRectY","groupRectWidth","PADDING","groupRectHeight","groupRectId","nanoid","groupRect","bgColor","fill","unshift","frameId","frameChildren","elementId","assign","frame","children"],"mappings":"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"}