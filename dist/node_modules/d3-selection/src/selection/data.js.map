{"version":3,"file":"data.js","sources":["../../../../../node_modules/d3-selection/src/selection/data.js"],"sourcesContent":["import {Selection} from \"./index.js\";\nimport {EnterNode} from \"./enter.js\";\nimport constant from \"../constant.js\";\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = new Map,\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction datum(node) {\n  return node.__data__;\n}\n\nexport default function(value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n\n// Given some data, this returns an array-like view of it: an object that\n// exposes a length property and allows numeric indexing. Note that unlike\n// selectAll, this isn’t worried about “live” collections because the resulting\n// array will only be used briefly while data is being bound. (It is possible to\n// cause the data to change while iterating by using a key function, but please\n// don’t; we’d rather avoid a gratuitous copy.)\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data\n    ? data // Array, TypedArray, NodeList, array-like\n    : Array.from(data); // Map, Set, iterable, string, or anything else\n}\n"],"names":["bindIndex","parent","group","enter","update","exit","data","node","i","groupLength","length","dataLength","__data__","EnterNode","bindKey","key","keyValue","nodeByKeyValue","Map","keyValues","Array","call","has","set","get","delete","datum","selection_data","value","arguments","from","this","bind","parents","_parents","groups","_groups","constant","m","j","arraylike","enterGroup","updateGroup","previous","next","i0","i1","_next","Selection","_enter","_exit"],"mappings":"4GAIA,SAASA,EAAUC,EAAQC,EAAOC,EAAOC,EAAQC,EAAMC,GASrD,IARA,IACIC,EADAC,EAAI,EAEJC,EAAcP,EAAMQ,OACpBC,EAAaL,EAAKI,OAKfF,EAAIG,IAAcH,GACnBD,EAAOL,EAAMM,KACfD,EAAKK,SAAWN,EAAKE,GACrBJ,EAAOI,GAAKD,GAEZJ,EAAMK,GAAK,IAAIK,EAAUZ,EAAQK,EAAKE,IAK1C,KAAOA,EAAIC,IAAeD,GACpBD,EAAOL,EAAMM,MACfH,EAAKG,GAAKD,EAGhB,CAEA,SAASO,EAAQb,EAAQC,EAAOC,EAAOC,EAAQC,EAAMC,EAAMS,GACzD,IAAIP,EACAD,EAKAS,EAJAC,EAAiB,IAAIC,IACrBT,EAAcP,EAAMQ,OACpBC,EAAaL,EAAKI,OAClBS,EAAY,IAAIC,MAAMX,GAK1B,IAAKD,EAAI,EAAGA,EAAIC,IAAeD,GACzBD,EAAOL,EAAMM,MACfW,EAAUX,GAAKQ,EAAWD,EAAIM,KAAKd,EAAMA,EAAKK,SAAUJ,EAAGN,GAAS,GAChEe,EAAeK,IAAIN,GACrBX,EAAKG,GAAKD,EAEVU,EAAeM,IAAIP,EAAUT,IAQnC,IAAKC,EAAI,EAAGA,EAAIG,IAAcH,EAC5BQ,EAAWD,EAAIM,KAAKpB,EAAQK,EAAKE,GAAIA,EAAGF,GAAQ,IAC5CC,EAAOU,EAAeO,IAAIR,KAC5BZ,EAAOI,GAAKD,EACZA,EAAKK,SAAWN,EAAKE,GACrBS,EAAeQ,OAAOT,IAEtBb,EAAMK,GAAK,IAAIK,EAAUZ,EAAQK,EAAKE,IAK1C,IAAKA,EAAI,EAAGA,EAAIC,IAAeD,GACxBD,EAAOL,EAAMM,KAAQS,EAAeO,IAAIL,EAAUX,MAAQD,IAC7DF,EAAKG,GAAKD,EAGhB,CAEA,SAASmB,EAAMnB,GACb,OAAOA,EAAKK,QACd,CAEe,SAAAe,EAASC,EAAOb,GAC7B,IAAKc,UAAUnB,OAAQ,OAAOU,MAAMU,KAAKC,KAAML,GAE/C,IAAIM,EAAOjB,EAAMD,EAAUd,EACvBiC,EAAUF,KAAKG,SACfC,EAASJ,KAAKK,QAEG,mBAAVR,IAAsBA,EAAQS,EAAST,IAElD,IAAK,IAAIU,EAAIH,EAAOzB,OAAQN,EAAS,IAAIgB,MAAMkB,GAAInC,EAAQ,IAAIiB,MAAMkB,GAAIjC,EAAO,IAAIe,MAAMkB,GAAIC,EAAI,EAAGA,EAAID,IAAKC,EAAG,CAC/G,IAAItC,EAASgC,EAAQM,GACjBrC,EAAQiC,EAAOI,GACf9B,EAAcP,EAAMQ,OACpBJ,EAAOkC,EAAUZ,EAAMP,KAAKpB,EAAQA,GAAUA,EAAOW,SAAU2B,EAAGN,IAClEtB,EAAaL,EAAKI,OAClB+B,EAAatC,EAAMoC,GAAK,IAAInB,MAAMT,GAClC+B,EAActC,EAAOmC,GAAK,IAAInB,MAAMT,GAGxCqB,EAAK/B,EAAQC,EAAOuC,EAAYC,EAFhBrC,EAAKkC,GAAK,IAAInB,MAAMX,GAEoBH,EAAMS,GAK9D,IAAK,IAAoB4B,EAAUC,EAA1BC,EAAK,EAAGC,EAAK,EAAmBD,EAAKlC,IAAckC,EAC1D,GAAIF,EAAWF,EAAWI,GAAK,CAE7B,IADIA,GAAMC,IAAIA,EAAKD,EAAK,KACfD,EAAOF,EAAYI,OAAUA,EAAKnC,IAC3CgC,EAASI,MAAQH,GAAQ,IAC1B,CAEJ,CAKD,OAHAxC,EAAS,IAAI4C,EAAU5C,EAAQ6B,IACxBgB,OAAS9C,EAChBC,EAAO8C,MAAQ7C,EACRD,CACT,CAQA,SAASoC,EAAUlC,GACjB,MAAuB,iBAATA,GAAqB,WAAYA,EAC3CA,EACAc,MAAMU,KAAKxB,EACjB"}