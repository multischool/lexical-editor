{"version":3,"file":"index.modern.js","sources":["../../../../node_modules/jotai-scope/dist/index.modern.js"],"sourcesContent":["import { jsx } from 'react/jsx-runtime';\nimport { createContext, useRef, useContext, useState, useEffect } from 'react';\nimport { createStore } from 'jotai/vanilla';\nimport { useStore, useAtom, useAtomValue, useSetAtom, Provider } from 'jotai/react';\nimport { useHydrateAtoms } from 'jotai/react/utils';\nimport { atom } from 'jotai';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction createIsolation() {\n  const StoreContext = createContext(null);\n  function Provider({\n    store,\n    initialValues = [],\n    children\n  }) {\n    const storeRef = useRef(store);\n    if (!storeRef.current) {\n      storeRef.current = createStore();\n    }\n    useHydrateAtoms(initialValues, {\n      store: storeRef.current\n    });\n    return jsx(StoreContext.Provider, {\n      value: storeRef.current,\n      children: children\n    });\n  }\n  const useStore$1 = options => {\n    const store = useContext(StoreContext);\n    if (!store) throw new Error('Missing Provider from createIsolation');\n    return useStore(_extends({\n      store\n    }, options));\n  };\n  const useAtom$1 = (anAtom, options) => {\n    const store = useStore$1();\n    return useAtom(anAtom, _extends({\n      store\n    }, options));\n  };\n  const useAtomValue$1 = (anAtom, options) => {\n    const store = useStore$1();\n    return useAtomValue(anAtom, _extends({\n      store\n    }, options));\n  };\n  const useSetAtom$1 = (anAtom, options) => {\n    const store = useStore$1();\n    return useSetAtom(anAtom, _extends({\n      store\n    }, options));\n  };\n  return {\n    Provider,\n    useStore: useStore$1,\n    useAtom: useAtom$1,\n    useAtomValue: useAtomValue$1,\n    useSetAtom: useSetAtom$1\n  };\n}\n\nconst globalScopeKey = {};\nif (process.env.NODE_ENV !== 'production') {\n  globalScopeKey.name = 'unscoped';\n  globalScopeKey.toString = toString;\n}\nfunction createScope(atoms, atomFamilies, parentScope, scopeName) {\n  const explicit = new WeakMap();\n  const implicit = new WeakMap();\n  const inherited = new WeakMap();\n  const currentScope = {\n    getAtom,\n    cleanup() {},\n    prepareWriteAtom(anAtom, originalAtom, implicitScope) {\n      if (originalAtom.read === defaultRead && isWritableAtom(originalAtom) && isWritableAtom(anAtom) && originalAtom.write !== defaultWrite && currentScope !== implicitScope) {\n        // atom is writable with init and holds a value\n        // we need to preserve the value, so we don't want to copy the atom\n        // instead, we need to override write until the write is finished\n        const {\n          write\n        } = originalAtom;\n        anAtom.write = createScopedWrite(originalAtom.write.bind(originalAtom), implicitScope);\n        return () => {\n          anAtom.write = write;\n        };\n      }\n      return undefined;\n    }\n  };\n  if (scopeName && process.env.NODE_ENV !== 'production') {\n    currentScope.name = scopeName;\n    currentScope.toString = toString;\n  }\n  // populate explicitly scoped atoms\n  for (const anAtom of atoms) {\n    explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);\n  }\n  const cleanupFamiliesSet = new Set();\n  for (const atomFamily of atomFamilies) {\n    for (const param of atomFamily.getParams()) {\n      const anAtom = atomFamily(param);\n      if (!explicit.has(anAtom)) {\n        explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);\n      }\n    }\n    const cleanupFamily = atomFamily.unstable_listen(e => {\n      if (e.type === 'CREATE' && !explicit.has(e.atom)) {\n        explicit.set(e.atom, [cloneAtom(e.atom, currentScope), currentScope]);\n      } else if (!atoms.has(e.atom)) {\n        explicit.delete(e.atom);\n      }\n    });\n    cleanupFamiliesSet.add(cleanupFamily);\n  }\n  currentScope.cleanup = combineVoidFunctions(currentScope.cleanup, ...Array.from(cleanupFamiliesSet));\n  /**\n   * Returns a scoped atom from the original atom.\n   * @param anAtom\n   * @param implicitScope the atom is implicitly scoped in the provided scope\n   * @returns the scoped atom and the scope of the atom\n   */\n  function getAtom(anAtom, implicitScope) {\n    var _inherited$get2;\n    if (explicit.has(anAtom)) {\n      return explicit.get(anAtom);\n    }\n    if (implicitScope === currentScope) {\n      // dependencies of explicitly scoped atoms are implicitly scoped\n      // implicitly scoped atoms are only accessed by implicit and explicit scoped atoms\n      if (!implicit.has(anAtom)) {\n        implicit.set(anAtom, [cloneAtom(anAtom, implicitScope), implicitScope]);\n      }\n      return implicit.get(anAtom);\n    }\n    const scopeKey = implicitScope != null ? implicitScope : globalScopeKey;\n    if (parentScope) {\n      var _inherited$get;\n      // inherited atoms are copied so they can access scoped atoms\n      // but they are not explicitly scoped\n      // dependencies of inherited atoms first check if they are explicitly scoped\n      // otherwise they use their original scope's atom\n      if (!((_inherited$get = inherited.get(scopeKey)) != null && _inherited$get.has(anAtom))) {\n        const [ancestorAtom, explicitScope] = parentScope.getAtom(anAtom, implicitScope);\n        setInheritedAtom(inheritAtom(ancestorAtom, anAtom, explicitScope), anAtom, implicitScope, explicitScope);\n      }\n      return inherited.get(scopeKey).get(anAtom);\n    }\n    if (!((_inherited$get2 = inherited.get(scopeKey)) != null && _inherited$get2.has(anAtom))) {\n      // non-primitive atoms may need to access scoped atoms\n      // so we need to create a copy of the atom\n      setInheritedAtom(inheritAtom(anAtom, anAtom), anAtom);\n    }\n    return inherited.get(scopeKey).get(anAtom);\n  }\n  function setInheritedAtom(scopedAtom, originalAtom, implicitScope, explicitScope) {\n    const scopeKey = implicitScope != null ? implicitScope : globalScopeKey;\n    if (!inherited.has(scopeKey)) {\n      inherited.set(scopeKey, new WeakMap());\n    }\n    inherited.get(scopeKey).set(originalAtom, [scopedAtom, explicitScope].filter(Boolean));\n  }\n  /**\n   * @returns a copy of the atom for derived atoms or the original atom for primitive and writable atoms\n   */\n  function inheritAtom(anAtom, originalAtom, implicitScope) {\n    if (originalAtom.read !== defaultRead) {\n      return cloneAtom(originalAtom, implicitScope);\n    }\n    return anAtom;\n  }\n  /**\n   * @returns a scoped copy of the atom\n   */\n  function cloneAtom(originalAtom, implicitScope) {\n    // avoid reading `init` to preserve lazy initialization\n    const scopedAtom = Object.create(Object.getPrototypeOf(originalAtom), Object.getOwnPropertyDescriptors(originalAtom));\n    if (scopedAtom.read !== defaultRead) {\n      scopedAtom.read = createScopedRead(originalAtom.read.bind(originalAtom), implicitScope);\n    }\n    if (isWritableAtom(scopedAtom) && isWritableAtom(originalAtom) && scopedAtom.write !== defaultWrite) {\n      scopedAtom.write = createScopedWrite(originalAtom.write.bind(originalAtom), implicitScope);\n    }\n    return scopedAtom;\n  }\n  function createScopedRead(read, implicitScope) {\n    return function scopedRead(get, opts) {\n      return read(function scopedGet(a) {\n        const [scopedAtom] = getAtom(a, implicitScope);\n        return get(scopedAtom);\n      },\n      //\n      opts);\n    };\n  }\n  function createScopedWrite(write, implicitScope) {\n    return function scopedWrite(get, set, ...args) {\n      return write(function scopedGet(a) {\n        const [scopedAtom] = getAtom(a, implicitScope);\n        return get(scopedAtom);\n      }, function scopedSet(a, ...v) {\n        const [scopedAtom] = getAtom(a, implicitScope);\n        return set(scopedAtom, ...v);\n      }, ...args);\n    };\n  }\n  return currentScope;\n}\nfunction isWritableAtom(anAtom) {\n  return 'write' in anAtom;\n}\nconst {\n  read: defaultRead,\n  write: defaultWrite\n} = atom(null);\nfunction toString() {\n  return this.name;\n}\nfunction combineVoidFunctions(...fns) {\n  return function combinedFunctions() {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\nfunction PatchedStore() {}\n/**\n * @returns a patched store that intercepts get and set calls to apply the scope\n */\nfunction createPatchedStore(baseStore, scope) {\n  const store = _extends({}, baseStore, {\n    get(anAtom, ...args) {\n      const [scopedAtom] = scope.getAtom(anAtom);\n      return baseStore.get(scopedAtom, ...args);\n    },\n    set(anAtom, ...args) {\n      const [scopedAtom, implicitScope] = scope.getAtom(anAtom);\n      const restore = scope.prepareWriteAtom(scopedAtom, anAtom, implicitScope);\n      try {\n        return baseStore.set(scopedAtom, ...args);\n      } finally {\n        restore == null || restore();\n      }\n    },\n    sub(anAtom, ...args) {\n      const [scopedAtom] = scope.getAtom(anAtom);\n      return baseStore.sub(scopedAtom, ...args);\n    }\n    // TODO: update this patch to support devtools\n  });\n\n  return Object.assign(Object.create(PatchedStore.prototype), store);\n}\n/**\n * @returns true if the current scope is the first descendant scope under Provider\n */\nfunction isTopLevelScope(parentStore) {\n  return !(parentStore instanceof PatchedStore);\n}\n\nconst ScopeContext = createContext({\n  scope: undefined,\n  baseStore: undefined\n});\nfunction ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName\n}) {\n  const parentStore = useStore();\n  let {\n    scope: parentScope,\n    baseStore = parentStore\n  } = useContext(ScopeContext);\n  // if this ScopeProvider is the first descendant scope under Provider then it is the top level scope\n  // https://github.com/jotaijs/jotai-scope/pull/33#discussion_r1604268003\n  if (isTopLevelScope(parentStore)) {\n    parentScope = undefined;\n    baseStore = parentStore;\n  }\n  // atomSet is used to detect if the atoms prop has changed.\n  const atomSet = new Set(atoms);\n  const atomFamilySet = new Set(atomFamilies);\n  function initialize() {\n    const scope = createScope(atomSet, atomFamilySet, parentScope, debugName);\n    return {\n      patchedStore: createPatchedStore(baseStore, scope),\n      scopeContext: {\n        scope,\n        baseStore\n      },\n      hasChanged(current) {\n        return parentScope !== current.parentScope || baseStore !== current.baseStore || !isEqualSet(atomSet, current.atomSet) || !isEqualSet(atomFamilySet, current.atomFamilySet);\n      }\n    };\n  }\n  const [state, setState] = useState(initialize);\n  const {\n    hasChanged,\n    scopeContext,\n    patchedStore\n  } = state;\n  if (hasChanged({\n    parentScope,\n    atomSet,\n    atomFamilySet,\n    baseStore\n  })) {\n    var _scopeContext$scope;\n    (_scopeContext$scope = scopeContext.scope) == null || _scopeContext$scope.cleanup();\n    setState(initialize);\n  }\n  const {\n    cleanup\n  } = scopeContext.scope;\n  useEvent(() => cleanup, []);\n  return jsx(ScopeContext.Provider, {\n    value: scopeContext,\n    children: jsx(Provider, {\n      store: patchedStore,\n      children: children\n    })\n  });\n}\nfunction isEqualSet(a, b) {\n  return a === b || a.size === b.size && Array.from(a).every(v => b.has(v));\n}\nfunction useEvent(fn, deps) {\n  const ref = useRef(fn);\n  ref.current = fn;\n  useEffect(() => ref.current(), deps);\n}\n\nexport { ScopeProvider, createIsolation };\n//# sourceMappingURL=index.modern.mjs.map\n"],"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","createIsolation","StoreContext","createContext","useStore$1","options","store","useContext","Error","useStore","Provider","initialValues","children","storeRef","useRef","current","createStore","useHydrateAtoms","jsx","exports","value","useAtom","anAtom","useAtomValue","useSetAtom","process","env","NODE_ENV","atom","scope","undefined","baseStore"],"mappings":"gaAOA,SAASA,IAYP,OAXAA,EAAWC,OAAOC,OAASD,OAAOC,OAAOC,OAAS,SAAUC,GAC1D,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CACzC,IAAIG,EAASF,UAAUD,GACvB,IAAK,IAAII,KAAOD,EACVP,OAAOS,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,GAG1B,CACD,OAAOL,CACX,EACSJ,EAASa,MAAMC,KAAMR,UAC9B,CAEA,SAASS,IACP,MAAMC,EAAeC,EAAc,MAkBnC,MAAMC,EAAaC,IACjB,MAAMC,EAAQC,EAAWL,GACzB,IAAKI,EAAO,MAAM,IAAIE,MAAM,yCAC5B,OAAOC,EAASvB,EAAS,CACvBoB,SACCD,GAAS,EAoBd,MAAO,CACLK,SA3CF,UAAkBJ,MAChBA,EAAKK,cACLA,EAAgB,GAAEC,SAClBA,IAEA,MAAMC,EAAWC,EAAOR,GAOxB,OANKO,EAASE,UACZF,EAASE,QAAUC,KAErBC,EAAgBN,EAAe,CAC7BL,MAAOO,EAASE,UAEXG,EAAGC,QAAAD,IAAChB,EAAaQ,SAAU,CAChCU,MAAOP,EAASE,QAChBH,SAAUA,GAEb,EA4BCH,SAAUL,EACViB,QArBgB,CAACC,EAAQjB,KACzB,MAAMC,EAAQF,IACd,OAAOiB,EAAQC,EAAQpC,EAAS,CAC9BoB,SACCD,GAAS,EAkBZkB,aAhBqB,CAACD,EAAQjB,KAC9B,MAAMC,EAAQF,IACd,OAAOmB,EAAaD,EAAQpC,EAAS,CACnCoB,SACCD,GAAS,EAaZmB,WAXmB,CAACF,EAAQjB,KAC5B,MAAMC,EAAQF,IACd,OAAOoB,EAAWF,EAAQpC,EAAS,CACjCoB,SACCD,GAAS,EAShB,CAGIoB,QAAQC,IAAIC,SAuJZC,EAAK,MA+CYzB,EAAc,CACjC0B,WAAOC,EACPC,eAAWD"}