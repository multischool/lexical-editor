function t(t,n,e){if(t&&t.length){const[o,s]=n,f=Math.PI/180*e,h=Math.cos(f),a=Math.sin(f);for(const n of t){const[t,e]=n;n[0]=(t-o)*h-(e-s)*a+o,n[1]=(t-o)*a+(e-s)*h+s}}}function n(t,n){return t[0]===n[0]&&t[1]===n[1]}function e(e,o,s,f=1){const h=s,a=Math.max(o,.1),c=e[0]&&e[0][0]&&"number"==typeof e[0][0]?[e]:e,r=[0,0];if(h)for(const n of c)t(n,r,h);const x=function(t,e,o){const s=[];for(const e of t){const t=[...e];n(t[0],t[t.length-1])||t.push([t[0][0],t[0][1]]),t.length>2&&s.push(t)}const f=[];e=Math.max(e,.1);const h=[];for(const t of s)for(let n=0;n<t.length-1;n++){const e=t[n],o=t[n+1];if(e[1]!==o[1]){const t=Math.min(e[1],o[1]);h.push({ymin:t,ymax:Math.max(e[1],o[1]),x:t===e[1]?e[0]:o[0],islope:(o[0]-e[0])/(o[1]-e[1])})}}if(h.sort(((t,n)=>t.ymin<n.ymin?-1:t.ymin>n.ymin?1:t.x<n.x?-1:t.x>n.x?1:t.ymax===n.ymax?0:(t.ymax-n.ymax)/Math.abs(t.ymax-n.ymax))),!h.length)return f;let a=[],c=h[0].ymin,r=0;for(;a.length||h.length;){if(h.length){let t=-1;for(let n=0;n<h.length&&!(h[n].ymin>c);n++)t=n;h.splice(0,t+1).forEach((t=>{a.push({s:c,edge:t})}))}if(a=a.filter((t=>!(t.edge.ymax<=c))),a.sort(((t,n)=>t.edge.x===n.edge.x?0:(t.edge.x-n.edge.x)/Math.abs(t.edge.x-n.edge.x))),(1!==o||r%e==0)&&a.length>1)for(let t=0;t<a.length;t+=2){const n=t+1;if(n>=a.length)break;const e=a[t].edge,o=a[n].edge;f.push([[Math.round(e.x),c],[Math.round(o.x),c]])}c+=o,a.forEach((t=>{t.edge.x=t.edge.x+o*t.edge.islope})),r++}return f}(c,a,f);if(h){for(const n of c)t(n,r,-h);!function(n,e,o){const s=[];n.forEach((t=>s.push(...t))),t(s,e,o)}(x,r,-h)}return x}export{e as hachureLines};
//# sourceMappingURL=hachure.js.map
