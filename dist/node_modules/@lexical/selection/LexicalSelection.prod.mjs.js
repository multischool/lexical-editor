import{$isTextNode as e,$getCharacterOffsets as t,$isElementNode as n,$isRootNode as o,$getNodeByKey as r,$getPreviousSelection as s,$createTextNode as l,$isRangeSelection as i,$getSelection as c,$caretRangeFromSelection as f,$isTokenOrSegmented as a,$createRangeSelection as u,INTERNAL_$isBlock as g,$setSelection as d,$isRootOrShadowRoot as p,$hasAncestor as h,$isLeafNode as y,$caretFromPoint as m,$isExtendableTextPointCaret as S,$extendCaretToRange as T,$isChildCaret as x,$isDecoratorNode as C}from"lexical";export{$cloneWithProperties,$selectAll}from"lexical";function N(e,...t){const n=new URL("https://lexical.dev/docs/error"),o=new URLSearchParams;o.append("code",e);for(const e of t)o.append("v",e);throw n.search=o.toString(),Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}const v=new Map;function w(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function P(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function E(t,n,o,r,s){const l=n.getKey(),i=r.getKey(),c=document.createRange();let f=t.getElementByKey(l),a=t.getElementByKey(i),u=o,g=s;if(e(n)&&(f=w(f)),e(r)&&(a=w(a)),void 0===n||void 0===r||null===f||null===a)return null;"BR"===f.nodeName&&([f,u]=P(f)),"BR"===a.nodeName&&([a,g]=P(a));const d=f.firstChild;f===a&&null!=d&&"BR"===d.nodeName&&0===u&&0===g&&(g=1);try{c.setStart(f,u),c.setEnd(a,g)}catch(e){return null}return!c.collapsed||u===g&&l===i||(c.setStart(a,g),c.setEnd(f,u)),c}function F(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),r=getComputedStyle(n),s=parseFloat(r.paddingLeft)+parseFloat(r.paddingRight),l=Array.from(t.getClientRects());let i,c=l.length;l.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=l[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,r=t.width+s===o.width;n||r?(l.splice(e--,1),c--):i=t}return l}function $(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function k(e){let t=v.get(e);return void 0===t&&(t=$(e),v.set(e,t)),t}function K(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function I(e,n){const o=e.getStartEndPoints();if(n.isSelected(e)&&!n.isSegmented()&&!n.isToken()&&null!==o){const[r,s]=o,l=e.isBackward(),i=r.getNode(),c=s.getNode(),f=n.is(i),a=n.is(c);if(f||a){const[o,r]=t(e),s=i.is(c),f=n.is(l?c:i),a=n.is(l?i:c);let u,g=0;return s?(g=o>r?r:o,u=o>r?o:r):f?(g=l?r:o,u=void 0):a&&(g=0,u=l?o:r),n.__text=n.__text.slice(g,u),n}}return n}function O(e){if("text"===e.type)return e.offset===e.getNode().getTextContentSize();const t=e.getNode();return n(t)||N(177),e.offset===t.getChildrenSize()}function R(t,c,f){let a=c.getNode(),u=f;if(n(a)){const e=a.getDescendantByIndex(c.offset);null!==e&&(a=e)}for(;u>0&&null!==a;){if(n(a)){const e=a.getLastDescendant();null!==e&&(a=e)}let f=a.getPreviousSibling(),g=0;if(null===f){let e=a.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){f=null;break}t=e.getPreviousSibling()}null!==e&&(g=e.isInline()?0:2,f=t)}let d=a.getTextContent();""===d&&n(a)&&!a.isInline()&&(d="\n\n");const p=d.length;if(!e(a)||u>=p){const e=a.getParent();a.remove(),null==e||0!==e.getChildrenSize()||o(e)||e.remove(),u-=p+g,a=f}else{const n=a.getKey(),o=t.getEditorState().read((()=>{const t=r(n);return e(t)&&t.isSimpleText()?t.getTextContent():null})),f=p-u,g=d.slice(0,f);if(null!==o&&o!==d){const e=s();let t=a;if(a.isSimpleText())a.setTextContent(o);else{const e=l(o);a.replace(e),t=e}if(i(e)&&e.isCollapsed()){const n=e.anchor.offset;t.select(n,n)}}else if(a.isSimpleText()){const e=c.key===n;let t=c.offset;t<u&&(t=p);const o=e?t-u:0,r=e?t:f;if(e&&0===o){const[e]=a.splitText(o,r);e.remove()}else{const[,e]=a.splitText(o,r);e.remove()}}else{const e=l(g);a.replace(e)}u=0}}}function B(e){const t=e.getStyle(),n=$(t);v.set(t,n)}function b(t,o){(i(t)?t.isCollapsed():e(t)||n(t))||N(280);const r=k(i(t)?t.style:e(t)?t.getStyle():t.getTextStyle()),s=Object.entries(o).reduce(((e,[n,o])=>("function"==typeof o?e[n]=o(r[n],t):null===o?delete e[n]:e[n]=o,e)),{...r}),l=K(s);i(t)||e(t)?t.setStyle(l):t.setTextStyle(l),v.set(l,s)}function A(e,t){if(i(e)&&e.isCollapsed()){b(e,t);const o=e.anchor.getNode();n(o)&&o.isEmpty()&&b(o,t)}z((e=>{b(e,t)}))}function z(t){const n=c();if(!n)return;const o=new Map;if(i(n))for(const e of f(n).getTextSlices())e&&o.set(e.caret.origin.getKey(),e.getSliceIndices());const r=n.getNodes();for(const n of r){if(!e(n)||!n.canHaveFormat())continue;const[r,l]=(s=n,o.get(s.getKey())||[0,s.getTextContentSize()]);l!==r&&(a(n)||0===r&&l===n.getTextContentSize()?t(n):t(n.splitText(r,l)[0===r?0:1]))}var s;i(n)&&"text"===n.anchor.type&&"text"===n.focus.type&&n.anchor.key===n.focus.key&&M(n)}function M(e){if(e.isBackward()){const{anchor:t,focus:n}=e,{key:o,offset:r,type:s}=t;t.set(n.key,n.offset,n.type),n.set(o,r,s)}}function D(e,t){const n=e.getFormatType(),o=e.getIndent();n!==t.getFormatType()&&t.setFormat(n),o!==t.getIndent()&&t.setIndent(o)}function L(e,t,o=D){if(null===e)return;const r=e.getStartEndPoints(),s=new Map;let l=null;if(r){const[e,t]=r;l=u(),l.anchor.set(e.key,e.offset,e.type),l.focus.set(t.key,t.offset,t.type);const o=Q(e.getNode(),g),i=Q(t.getNode(),g);n(o)&&s.set(o.getKey(),o),n(i)&&s.set(i.getKey(),i)}for(const t of e.getNodes())n(t)&&g(t)&&s.set(t.getKey(),t);for(const[e,n]of s){const r=t();o(n,r),n.replace(r,!0),l&&(e===l.anchor.key&&l.anchor.set(r.getKey(),l.anchor.offset,l.anchor.type),e===l.focus.key&&l.focus.set(r.getKey(),l.focus.offset,l.focus.type))}l&&e.is(c())&&d(l)}function _(e){return e.getNode().isAttached()}function j(e){let t=e;for(;null!==t&&!p(t);){const e=t.getLatest(),n=t.getParent();0===e.getChildrenSize()&&t.remove(!0),t=n}}function U(e,t,n=null){const o=e.getStartEndPoints(),r=o?o[0]:null,s=e.getNodes(),l=s.length;if(null!==r&&(0===l||1===l&&"element"===r.type&&0===r.getNode().getChildrenSize())){const e="text"===r.type?r.getNode().getParentOrThrow():r.getNode(),o=e.getChildren();let s=t();return s.setFormat(e.getFormatType()),s.setIndent(e.getIndent()),o.forEach((e=>s.append(e))),n&&(s=n.append(s)),void e.replace(s)}let i=null,c=[];for(let o=0;o<l;o++){const r=s[o];p(r)?(H(e,c,c.length,t,n),c=[],i=r):null===i||null!==i&&h(r,i)?c.push(r):(H(e,c,c.length,t,n),c=[r])}H(e,c,c.length,t,n)}function H(e,t,o,r,l=null){if(0===t.length)return;const c=t[0],f=new Map,a=[];let u=n(c)?c:c.getParentOrThrow();u.isInline()&&(u=u.getParentOrThrow());let g=!1;for(;null!==u;){const e=u.getPreviousSibling();if(null!==e){u=e,g=!0;break}if(u=u.getParentOrThrow(),p(u))break}const h=new Set;for(let e=0;e<o;e++){const o=t[e];n(o)&&0===o.getChildrenSize()&&h.add(o.getKey())}const m=new Set;for(let e=0;e<o;e++){const o=t[e];let s=o.getParent();if(null!==s&&s.isInline()&&(s=s.getParent()),null!==s&&y(o)&&!m.has(o.getKey())){const e=s.getKey();if(void 0===f.get(e)){const t=r();t.setFormat(s.getFormatType()),t.setIndent(s.getIndent()),a.push(t),f.set(e,t),s.getChildren().forEach((e=>{t.append(e),m.add(e.getKey()),n(e)&&e.getChildrenKeys().forEach((e=>m.add(e)))})),j(s)}}else if(h.has(o.getKey())){n(o)||N(179);const e=r();e.setFormat(o.getFormatType()),e.setIndent(o.getIndent()),a.push(e),o.remove(!0)}}if(null!==l)for(let e=0;e<a.length;e++){const t=a[e];l.append(t)}let S=null;if(p(u))if(g)if(null!==l)u.insertAfter(l);else for(let e=a.length-1;e>=0;e--){const t=a[e];u.insertAfter(t)}else{const e=u.getFirstChild();if(n(e)&&(u=e),null===e)if(l)u.append(l);else for(let e=0;e<a.length;e++){const t=a[e];u.append(t),S=t}else if(null!==l)e.insertBefore(l);else for(let t=0;t<a.length;t++){const n=a[t];e.insertBefore(n),S=n}}else if(l)u.insertAfter(l);else for(let e=a.length-1;e>=0;e--){const t=a[e];u.insertAfter(t),S=t}const T=s();i(T)&&_(T.anchor)&&_(T.focus)?d(T.clone()):null!==S?S.selectEnd():e.dirty=!0}function V(e,t){const o=m(e.focus,t?"previous":"next");if(S(o))return!1;for(const e of T(o)){if(x(e))return!e.origin.isInline();if(!n(e.origin)){if(C(e.origin))return!0;break}}return!1}function W(e,t,n,o){e.modify(t?"extend":"move",n,o)}function X(e){const t=e.anchor.getNode();return"rtl"===(o(t)?t:t.getParentOrThrow()).getDirection()}function q(e,t,n){const o=X(e);W(e,t,n?!o:o,"character")}function G(e,t,n){const o=k(e.getStyle());return null!==o&&o[t]||n}function J(t,n,o=""){let r=null;const s=t.getNodes(),l=t.anchor,c=t.focus,f=t.isBackward(),a=f?c.offset:l.offset,u=f?c.getNode():l.getNode();if(i(t)&&t.isCollapsed()&&""!==t.style){const e=k(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<s.length;t++){const l=s[t];if((0===t||0!==a||!l.is(u))&&e(l)){const e=G(l,n,o);if(null===r)r=e;else if(r!==e){r="";break}}}return null===r?o:r}function Q(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}const Y=R;export{B as $addNodeStyle,D as $copyBlockFormatIndent,M as $ensureForwardRangeSelection,z as $forEachSelectedTextNode,J as $getSelectionStyleValueForProperty,O as $isAtNodeEnd,X as $isParentElementRTL,W as $moveCaretSelection,q as $moveCharacter,A as $patchStyleText,L as $setBlocksType,V as $shouldOverrideDefaultCharacterSelection,I as $sliceSelectedTextNodeContent,R as $trimTextContentFromAnchor,U as $wrapNodes,E as createDOMRange,F as createRectsFromDOMRange,K as getCSSFromStyleObject,k as getStyleObjectFromCSS,Y as trimTextContentFromAnchor};
//# sourceMappingURL=LexicalSelection.prod.mjs.js.map
