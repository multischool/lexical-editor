{"version":3,"file":"LexicalSelection.dev.mjs.js","sources":["../../../../node_modules/@lexical/selection/LexicalSelection.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $getCharacterOffsets, $isElementNode, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getSelection, $caretRangeFromSelection, $isTokenOrSegmented, $createRangeSelection, INTERNAL_$isBlock, $setSelection, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isChildCaret, $isDecoratorNode } from 'lexical';\nexport { $cloneWithProperties, $selectAll } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!($isRangeSelection(target) ? target.isCollapsed() : $isTextNode(target) || $isElementNode(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS($isRangeSelection(target) ? target.style : $isTextNode(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ($isRangeSelection(target) || $isTextNode(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ($isElementNode(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = $getSelection();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ($isRangeSelection(selection)) {\n    for (const slice of $caretRangeFromSelection(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!($isTextNode(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ($isTokenOrSegmented(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ($isRangeSelection(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = $createRangeSelection();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), INTERNAL_$isBlock);\n    if ($isElementNode(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ($isElementNode(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ($isElementNode(node) && INTERNAL_$isBlock(node)) {\n      blockMap.set(node.getKey(), node);\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is($getSelection())) {\n    $setSelection(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const focusCaret = $caretFromPoint(selection.focus, isBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of $extendCaretToRange(focusCaret)) {\n    if ($isChildCaret(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ($isElementNode(nextCaret.origin)) {\n      continue;\n    } else if ($isDecoratorNode(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\nexport { $addNodeStyle, $copyBlockFormatIndent, $ensureForwardRangeSelection, $forEachSelectedTextNode, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getCSSFromStyleObject, getStyleObjectFromCSS, trimTextContentFromAnchor };\n"],"names":["formatDevErrorMessage","message","Error","CSS_TO_STYLES","Map","getDOMTextNode","element","node","nodeType","Node","TEXT_NODE","firstChild","getDOMIndexWithinParent","parent","parentNode","Array","from","childNodes","indexOf","createDOMRange","editor","anchorNode","_anchorOffset","focusNode","_focusOffset","anchorKey","getKey","focusKey","range","document","createRange","anchorDOM","getElementByKey","focusDOM","anchorOffset","focusOffset","$isTextNode","undefined","nodeName","setStart","setEnd","e","collapsed","createRectsFromDOMRange","rootElement","getRootElement","rootRect","getBoundingClientRect","computedStyle","getComputedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","prevRect","selectionRectsLength","length","sort","a","b","top","Math","abs","left","i","selectionRect","isOverlappingRect","height","width","selectionSpansElement","splice","getStyleObjectFromRawCSS","css","styleObject","styles","split","style","key","value","trim","getStyleObjectFromCSS","get","set","Object","freeze","getCSSFromStyleObject","$sliceSelectedTextNodeContent","selection","textNode","anchorAndFocus","getStartEndPoints","isSelected","isSegmented","isToken","anchor","focus","isBackward","getNode","isAnchor","is","isFocus","$getCharacterOffsets","isSame","isFirst","isLast","endOffset","startOffset","__text","slice","$isAtNodeEnd","point","type","offset","getTextContentSize","$isElementNode","getChildrenSize","$trimTextContentFromAnchor","delCount","currentNode","remaining","descendantNode","getDescendantByIndex","lastDescendant","getLastDescendant","nextNode","getPreviousSibling","additionalElementWhitespace","getParentOrThrow","parentSibling","getParent","isInline","text","getTextContent","currentNodeSize","remove","$isRootNode","prevTextContent","getEditorState","read","prevNode","$getNodeByKey","isSimpleText","slicedText","prevSelection","$getPreviousSelection","target","setTextContent","$createTextNode","replace","$isRangeSelection","isCollapsed","prevOffset","select","splitStart","splitEnd","excessNode","splitText","$addNodeStyle","CSSText","getStyle","$patchStyle","patch","prevStyles","getTextStyle","newStyles","entries","reduce","newCSSText","setStyle","setTextStyle","$patchStyleText","emptyNode","isEmpty","$forEachSelectedTextNode","fn","$getSelection","slicedTextNodes","$caretRangeFromSelection","getTextSlices","caret","origin","getSliceIndices","selectedNodes","getNodes","selectedNode","canHaveFormat","$isTokenOrSegmented","$ensureForwardRangeSelection","$copyBlockFormatIndent","srcNode","destNode","format","getFormatType","indent","getIndent","setFormat","setIndent","$setBlocksType","$createElement","$afterCreateElement","blockMap","newSelection","$createRangeSelection","anchorBlock","$getAncestor","INTERNAL_$isBlock","focusBlock","$setSelection","isPointAttached","isAttached","$removeParentEmptyElements","startingNode","$isRootOrShadowRoot","latest","getLatest","$wrapNodes","createElement","wrappingElement","nodes","nodesLength","children","getChildren","forEach","child","append","topLevelNode","descendants","$wrapNodesImpl","$hasAncestor","push","firstNode","elementMapping","elements","targetIsPrevSibling","prevSibling","emptyElements","Set","add","movedNodes","$isLeafNode","has","parentKey","targetElement","getChildrenKeys","lastElement","insertAfter","getFirstChild","insertBefore","clone","selectEnd","dirty","$shouldOverrideDefaultCharacterSelection","focusCaret","$caretFromPoint","$isExtendableTextPointCaret","nextCaret","$extendCaretToRange","$isChildCaret","$isDecoratorNode","$moveCaretSelection","isHoldingShift","granularity","modify","$isParentElementRTL","getDirection","$moveCharacter","isRTL","$getNodeStyleValueForProperty","styleProperty","defaultValue","$getSelectionStyleValueForProperty","styleValue","endNode","nodeStyleValue","predicate","trimTextContentFromAnchor"],"mappings":"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"}