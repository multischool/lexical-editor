import{AutoLinkNode as t,$isAutoLinkNode as e,$isLinkNode as n,TOGGLE_LINK_COMMAND as r,$createAutoLinkNode as l}from"@lexical/link";import{useLexicalComposerContext as i}from"./LexicalComposerContext.mjs.js";import{mergeRegister as o}from"@lexical/utils";import{TextNode as s,$getSelection as u,$isRangeSelection as g,COMMAND_PRIORITY_LOW as c,$isTextNode as f,$isElementNode as a,$isLineBreakNode as x,$createTextNode as h,$isNodeSelection as p}from"lexical";import{useEffect as m}from"react";function d(t,e=t=>t){return n=>{const r=t.exec(n);return null===r?null:{index:r.index,length:r[0].length,text:r[0],url:e(r[0])}}}function T(t,e){for(let n=0;n<e.length;n++){const r=e[n](t);if(r)return r}return null}const C=/[.,;\s]/;function b(t){return C.test(t)}function S(t){return b(t[t.length-1])}function L(t){return b(t[0])}function U(t){let e=t.getPreviousSibling();return a(e)&&(e=e.getLastDescendant()),null===e||x(e)||f(e)&&S(e.getTextContent())}function R(t){let e=t.getNextSibling();return a(e)&&(e=e.getFirstDescendant()),null===e||x(e)||f(e)&&L(e.getTextContent())}function k(t,e,n,r){if(!(t>0?b(n[t-1]):U(r[0])))return!1;return e<n.length?b(n[e]):R(r[r.length-1])}function v(t,e,n){const r=[],l=[],i=[];let o=0,s=0;const u=[...t];for(;u.length>0;){const t=u[0],g=t.getTextContent().length,c=s;s+g<=e?(r.push(t),o+=g):c>=n?i.push(t):l.push(t),s+=g,u.shift()}return[o,r,l,i]}function N(t,e,n,r){const i=l(r.url,r.attributes);if(1===t.length){let l,o=t[0];0===e?[l,o]=o.splitText(n):[,l,o]=o.splitText(e,n);const s=h(r.text);return s.setFormat(l.getFormat()),s.setDetail(l.getDetail()),s.setStyle(l.getStyle()),i.append(s),l.replace(i),o}if(t.length>1){const r=t[0];let l,o=r.getTextContent().length;0===e?l=r:[,l]=r.splitText(e);const s=[];let c;for(let e=1;e<t.length;e++){const r=t[e],l=r.getTextContent().length,i=o;if(i<n)if(o+l<=n)s.push(r);else{const[t,e]=r.splitText(n-i);s.push(t),c=e}o+=l}const a=u(),x=a?a.getNodes().find(f):void 0,m=h(l.getTextContent());return m.setFormat(l.getFormat()),m.setDetail(l.getDetail()),m.setStyle(l.getStyle()),i.append(m,...s),x&&x===l&&(g(a)?m.select(a.anchor.offset,a.focus.offset):p(a)&&m.select(0,m.getTextContent().length)),l.replace(i),c}}function D(t,e,n){const r=t.getChildren(),l=r.length;for(let e=0;e<l;e++){const l=r[e];if(!f(l)||!l.isSimpleText())return I(t),void n(null,t.getURL())}const i=t.getTextContent(),o=T(i,e);if(null===o||o.text!==i)return I(t),void n(null,t.getURL());if(!U(t)||!R(t))return I(t),void n(null,t.getURL());const s=t.getURL();if(s!==o.url&&(t.setURL(o.url),n(o.url,s)),o.attributes){const e=t.getRel();e!==o.attributes.rel&&(t.setRel(o.attributes.rel||null),n(o.attributes.rel||null,e));const r=t.getTarget();r!==o.attributes.target&&(t.setTarget(o.attributes.target||null),n(o.attributes.target||null,r))}}function I(t){const e=t.getChildren();for(let n=e.length-1;n>=0;n--)t.insertAfter(e[n]);return t.remove(),e.map((t=>t.getLatest()))}function P(l,i,a){m((()=>{l.hasNodes([t])||function(t){throw new Error(t)}("LexicalAutoLinkPlugin: AutoLinkNode not registered on editor");const x=(t,e)=>{a&&a(t,e)};return o(l.registerNodeTransform(s,(t=>{const r=t.getParentOrThrow(),l=t.getPreviousSibling();if(e(r)&&!r.getIsUnlinked())D(r,i,x);else if(!n(r)){if(t.isSimpleText()&&(L(t.getTextContent())||!e(l))){const e=function(t){const e=[t];let n=t.getNextSibling();for(;null!==n&&f(n)&&n.isSimpleText()&&(e.push(n),!/[\s]/.test(n.getTextContent()));)n=n.getNextSibling();return e}(t);!function(t,e,n){let r=[...t];const l=r.map((t=>t.getTextContent())).join("");let i,o=l,s=0;for(;(i=T(o,e))&&null!==i;){const t=i.index,e=t+i.length;if(k(s+t,s+e,l,r)){const[l,,o,u]=v(r,s+t,s+e),g=N(o,s+t-l,s+e-l,i);r=g?[g,...u]:u,n(i.url,null),s=0}else s+=e;o=o.substring(e)}}(e,i,x)}!function(t,n,r){const l=t.getPreviousSibling(),i=t.getNextSibling(),o=t.getTextContent();var s;!e(l)||l.getIsUnlinked()||L(o)&&(s=o,!(l.isEmailURI()?/^\.[a-zA-Z]{2,}/.test(s):/^\.[a-zA-Z0-9]{1,}/.test(s)))||(l.append(t),D(l,n,r),r(null,l.getURL())),!e(i)||i.getIsUnlinked()||S(o)||(I(i),D(i,n,r),r(null,i.getURL()))}(t,i,x)}})),l.registerCommand(r,(t=>{const n=u();if(null!==t||!g(n))return!1;return n.extract().forEach((t=>{const n=t.getParent();if(e(n))return n.setIsUnlinked(!n.getIsUnlinked()),n.markDirty(),!0})),!1}),c))}),[l,i,a])}function y({matchers:t,onChange:e}){const[n]=i();return P(n,t,e),null}export{y as AutoLinkPlugin,d as createLinkMatcherWithRegExp};
//# sourceMappingURL=LexicalAutoLinkPlugin.dev.mjs.js.map
