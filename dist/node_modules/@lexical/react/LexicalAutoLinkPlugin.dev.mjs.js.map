{"version":3,"file":"LexicalAutoLinkPlugin.dev.mjs.js","sources":["../../../../node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { AutoLinkNode, $isAutoLinkNode, $isLinkNode, TOGGLE_LINK_COMMAND, $createAutoLinkNode } from '@lexical/link';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { mergeRegister } from '@lexical/utils';\nimport { TextNode, $getSelection, $isRangeSelection, COMMAND_PRIORITY_LOW, $isTextNode, $isElementNode, $isLineBreakNode, $createTextNode, $isNodeSelection } from 'lexical';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) {\n      return null;\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent, isEmail) {\n  if (isEmail) {\n    return /^\\.[a-zA-Z]{2,}/.test(textContent);\n  } else {\n    return /^\\.[a-zA-Z0-9]{1,}/.test(textContent);\n  }\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction $createAutoLinkNode_(nodes, startIndex, endIndex, match) {\n  const linkNode = $createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = $createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    textNode.setStyle(linkTextNode.getStyle());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = $getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined;\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    textNode.setStyle(firstLinkTextNode.getStyle());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction $handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  const initialText = currentNodes.map(node => node.getTextContent()).join('');\n  let text = initialText;\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nfunction useAutoLink(editor, matchers, onChange) {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      {\n        formatDevErrorMessage(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n    return mergeRegister(editor.registerNodeTransform(TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n      if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {\n          const textNodesToMatch = getTextNodesToMatch(textNode);\n          $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped);\n        }\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }), editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n      const selection = $getSelection();\n      if (payload !== null || !$isRangeSelection(selection)) {\n        return false;\n      }\n      const nodes = selection.extract();\n      nodes.forEach(node => {\n        const parent = node.getParent();\n        if ($isAutoLinkNode(parent)) {\n          // invert the value\n          parent.setIsUnlinked(!parent.getIsUnlinked());\n          parent.markDirty();\n          return true;\n        }\n      });\n      return false;\n    }, COMMAND_PRIORITY_LOW));\n  }, [editor, matchers, onChange]);\n}\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexport { AutoLinkPlugin, createLinkMatcherWithRegExp };\n"],"names":["createLinkMatcherWithRegExp","regExp","urlTransformer","text","match","exec","index","length","url","findFirstMatch","matchers","i","PUNCTUATION_OR_SPACE","isSeparator","char","test","endsWithSeparator","textContent","startsWithSeparator","isPreviousNodeValid","node","previousNode","getPreviousSibling","$isElementNode","getLastDescendant","$isLineBreakNode","$isTextNode","getTextContent","isNextNodeValid","nextNode","getNextSibling","getFirstDescendant","isContentAroundIsValid","matchStart","matchEnd","nodes","extractMatchingNodes","startIndex","endIndex","unmodifiedBeforeNodes","matchingNodes","unmodifiedAfterNodes","matchingOffset","currentOffset","currentNodes","currentNode","currentNodeLength","currentNodeStart","push","shift","$createAutoLinkNode_","linkNode","$createAutoLinkNode","attributes","linkTextNode","remainingTextNode","splitText","textNode","$createTextNode","setFormat","getFormat","setDetail","getDetail","setStyle","getStyle","append","replace","firstTextNode","firstLinkTextNode","offset","linkNodes","endNode","selection","$getSelection","selectedTextNode","getNodes","find","undefined","$isRangeSelection","select","anchor","focus","$isNodeSelection","handleLinkEdit","onChange","children","getChildren","childrenLength","child","isSimpleText","replaceWithChildren","getURL","setURL","rel","getRel","setRel","target","getTarget","setTarget","j","insertAfter","remove","map","getLatest","useAutoLink","editor","useEffect","hasNodes","AutoLinkNode","message","Error","formatDevErrorMessage","onChangeWrapped","prevUrl","mergeRegister","registerNodeTransform","TextNode","parent","getParentOrThrow","previous","$isAutoLinkNode","getIsUnlinked","$isLinkNode","textNodesToMatch","nextSibling","getTextNodesToMatch","initialText","join","invalidMatchEnd","substring","$handleLinkCreation","previousSibling","isEmailURI","handleBadNeighbors","registerCommand","TOGGLE_LINK_COMMAND","payload","extract","forEach","getParent","setIsUnlinked","markDirty","COMMAND_PRIORITY_LOW","AutoLinkPlugin","useLexicalComposerContext"],"mappings":"+eA4BA,SAASA,EAA4BC,EAAQC,EAAiBC,GAAQA,GACpE,OAAOA,IACL,MAAMC,EAAQH,EAAOI,KAAKF,GAC1B,OAAc,OAAVC,EACK,KAEF,CACLE,MAAOF,EAAME,MACbC,OAAQH,EAAM,GAAGG,OACjBJ,KAAMC,EAAM,GACZI,IAAKN,EAAeE,EAAM,IAC3B,CAEL,CACA,SAASK,EAAeN,EAAMO,GAC5B,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAASH,OAAQI,IAAK,CACxC,MAAMP,EAAQM,EAASC,GAAGR,GAC1B,GAAIC,EACF,OAAOA,CAEV,CACD,OAAO,IACT,CACA,MAAMQ,EAAuB,UAC7B,SAASC,EAAYC,GACnB,OAAOF,EAAqBG,KAAKD,EACnC,CACA,SAASE,EAAkBC,GACzB,OAAOJ,EAAYI,EAAYA,EAAYV,OAAS,GACtD,CACA,SAASW,EAAoBD,GAC3B,OAAOJ,EAAYI,EAAY,GACjC,CAgBA,SAASE,EAAoBC,GAC3B,IAAIC,EAAeD,EAAKE,qBAIxB,OAHIC,EAAeF,KACjBA,EAAeA,EAAaG,qBAEN,OAAjBH,GAAyBI,EAAiBJ,IAAiBK,EAAYL,IAAiBL,EAAkBK,EAAaM,iBAChI,CACA,SAASC,EAAgBR,GACvB,IAAIS,EAAWT,EAAKU,iBAIpB,OAHIP,EAAeM,KACjBA,EAAWA,EAASE,sBAEF,OAAbF,GAAqBJ,EAAiBI,IAAaH,EAAYG,IAAaX,EAAoBW,EAASF,iBAClH,CACA,SAASK,EAAuBC,EAAYC,EAAU/B,EAAMgC,GAE1D,KAD6BF,EAAa,EAAIpB,EAAYV,EAAK8B,EAAa,IAAMd,EAAoBgB,EAAM,KAE1G,OAAO,EAGT,OAD4BD,EAAW/B,EAAKI,OAASM,EAAYV,EAAK+B,IAAaN,EAAgBO,EAAMA,EAAM5B,OAAS,GAE1H,CACA,SAAS6B,EAAqBD,EAAOE,EAAYC,GAC/C,MAAMC,EAAwB,GACxBC,EAAgB,GAChBC,EAAuB,GAC7B,IAAIC,EAAiB,EACjBC,EAAgB,EACpB,MAAMC,EAAe,IAAIT,GACzB,KAAOS,EAAarC,OAAS,GAAG,CAC9B,MAAMsC,EAAcD,EAAa,GAE3BE,EADkBD,EAAYlB,iBACMpB,OACpCwC,EAAmBJ,EACFA,EAAgBG,GACjBT,GACpBE,EAAsBS,KAAKH,GAC3BH,GAAkBI,GACTC,GAAoBT,EAC7BG,EAAqBO,KAAKH,GAE1BL,EAAcQ,KAAKH,GAErBF,GAAiBG,EACjBF,EAAaK,OACd,CACD,MAAO,CAACP,EAAgBH,EAAuBC,EAAeC,EAChE,CACA,SAASS,EAAqBf,EAAOE,EAAYC,EAAUlC,GACzD,MAAM+C,EAAWC,EAAoBhD,EAAMI,IAAKJ,EAAMiD,YACtD,GAAqB,IAAjBlB,EAAM5B,OAAc,CACtB,IACI+C,EADAC,EAAoBpB,EAAM,GAEX,IAAfE,GACDiB,EAAcC,GAAqBA,EAAkBC,UAAUlB,IAE7D,CAAAgB,EAAcC,GAAqBA,EAAkBC,UAAUnB,EAAYC,GAEhF,MAAMmB,EAAWC,EAAgBtD,EAAMD,MAMvC,OALAsD,EAASE,UAAUL,EAAaM,aAChCH,EAASI,UAAUP,EAAaQ,aAChCL,EAASM,SAAST,EAAaU,YAC/Bb,EAASc,OAAOR,GAChBH,EAAaY,QAAQf,GACdI,CACX,CAAS,GAAIpB,EAAM5B,OAAS,EAAG,CAC3B,MAAM4D,EAAgBhC,EAAM,GAC5B,IACIiC,EADAC,EAASF,EAAcxC,iBAAiBpB,OAEzB,IAAf8B,EACF+B,EAAoBD,GAEpB,CAAGC,GAAqBD,EAAcX,UAAUnB,GAElD,MAAMiC,EAAY,GAClB,IAAIf,EACJ,IAAK,IAAI5C,EAAI,EAAGA,EAAIwB,EAAM5B,OAAQI,IAAK,CACrC,MAAMkC,EAAcV,EAAMxB,GAEpBmC,EADkBD,EAAYlB,iBACMpB,OACpCwC,EAAmBsB,EAEzB,GAAItB,EAAmBT,EACrB,GAFqB+B,EAASvB,GAERR,EACpBgC,EAAUtB,KAAKH,OACV,CACL,MAAOS,EAAciB,GAAW1B,EAAYW,UAAUlB,EAAWS,GACjEuB,EAAUtB,KAAKM,GACfC,EAAoBgB,CACrB,CAEHF,GAAUvB,CACX,CACD,MAAM0B,EAAYC,IACZC,EAAmBF,EAAYA,EAAUG,WAAWC,KAAKlD,QAAemD,EACxEpB,EAAWC,EAAgBU,EAAkBzC,kBAenD,OAdA8B,EAASE,UAAUS,EAAkBR,aACrCH,EAASI,UAAUO,EAAkBN,aACrCL,EAASM,SAASK,EAAkBJ,YACpCb,EAASc,OAAOR,KAAaa,GAGzBI,GAAoBA,IAAqBN,IACvCU,EAAkBN,GACpBf,EAASsB,OAAOP,EAAUQ,OAAOX,OAAQG,EAAUS,MAAMZ,QAChDa,EAAiBV,IAC1Bf,EAASsB,OAAO,EAAGtB,EAAS9B,iBAAiBpB,SAGjD6D,EAAkBF,QAAQf,GACnBI,CACR,CAEH,CA0BA,SAAS4B,EAAehC,EAAUzC,EAAU0E,GAE1C,MAAMC,EAAWlC,EAASmC,cACpBC,EAAiBF,EAAS9E,OAChC,IAAK,IAAII,EAAI,EAAGA,EAAI4E,EAAgB5E,IAAK,CACvC,MAAM6E,EAAQH,EAAS1E,GACvB,IAAKe,EAAY8D,KAAWA,EAAMC,eAGhC,OAFAC,EAAoBvC,QACpBiC,EAAS,KAAMjC,EAASwC,SAG3B,CAGD,MAAMxF,EAAOgD,EAASxB,iBAChBvB,EAAQK,EAAeN,EAAMO,GACnC,GAAc,OAAVN,GAAkBA,EAAMD,OAASA,EAGnC,OAFAuF,EAAoBvC,QACpBiC,EAAS,KAAMjC,EAASwC,UAK1B,IAAKxE,EAAoBgC,KAAcvB,EAAgBuB,GAGrD,OAFAuC,EAAoBvC,QACpBiC,EAAS,KAAMjC,EAASwC,UAG1B,MAAMnF,EAAM2C,EAASwC,SAKrB,GAJInF,IAAQJ,EAAMI,MAChB2C,EAASyC,OAAOxF,EAAMI,KACtB4E,EAAShF,EAAMI,IAAKA,IAElBJ,EAAMiD,WAAY,CACpB,MAAMwC,EAAM1C,EAAS2C,SACjBD,IAAQzF,EAAMiD,WAAWwC,MAC3B1C,EAAS4C,OAAO3F,EAAMiD,WAAWwC,KAAO,MACxCT,EAAShF,EAAMiD,WAAWwC,KAAO,KAAMA,IAEzC,MAAMG,EAAS7C,EAAS8C,YACpBD,IAAW5F,EAAMiD,WAAW2C,SAC9B7C,EAAS+C,UAAU9F,EAAMiD,WAAW2C,QAAU,MAC9CZ,EAAShF,EAAMiD,WAAW2C,QAAU,KAAMA,GAE7C,CACH,CAmBA,SAASN,EAAoBtE,GAC3B,MAAMiE,EAAWjE,EAAKkE,cAEtB,IAAK,IAAIa,EADcd,EAAS9E,OACF,EAAG4F,GAAK,EAAGA,IACvC/E,EAAKgF,YAAYf,EAASc,IAG5B,OADA/E,EAAKiF,SACEhB,EAASiB,KAAId,GAASA,EAAMe,aACrC,CAcA,SAASC,EAAYC,EAAQ/F,EAAU0E,GACrCsB,GAAU,KACHD,EAAOE,SAAS,CAACC,KAvR1B,SAA+BC,GAC7B,MAAM,IAAIC,MAAMD,EAClB,CAuRQE,CAAsB,gEAG1B,MAAMC,EAAkB,CAACxG,EAAKyG,KACxB7B,GACFA,EAAS5E,EAAKyG,EACf,EAEH,OAAOC,EAAcT,EAAOU,sBAAsBC,GAAU3D,IAC1D,MAAM4D,EAAS5D,EAAS6D,mBAClBC,EAAW9D,EAASnC,qBAC1B,GAAIkG,EAAgBH,KAAYA,EAAOI,gBACrCtC,EAAekC,EAAQ3G,EAAUsG,QAC5B,IAAKU,EAAYL,GAAS,CAC/B,GAAI5D,EAASgC,iBAAmBvE,EAAoBuC,EAAS9B,oBAAsB6F,EAAgBD,IAAY,CAC7G,MAAMI,EAhChB,SAA6BlE,GAE3B,MAAMkE,EAAmB,CAAClE,GAC1B,IAAImE,EAAcnE,EAAS3B,iBAC3B,KAAuB,OAAhB8F,GAAwBlG,EAAYkG,IAAgBA,EAAYnC,iBACrEkC,EAAiB3E,KAAK4E,IAClB,OAAO7G,KAAK6G,EAAYjG,oBAG5BiG,EAAcA,EAAY9F,iBAE5B,OAAO6F,CACT,CAoBmCE,CAAoBpE,IAlIvD,SAA6BtB,EAAOzB,EAAU0E,GAC5C,IAAIxC,EAAe,IAAIT,GACvB,MAAM2F,EAAclF,EAAa0D,KAAIlF,GAAQA,EAAKO,mBAAkBoG,KAAK,IACzE,IACI3H,EADAD,EAAO2H,EAEPE,EAAkB,EACtB,MAAQ5H,EAAQK,EAAeN,EAAMO,KAAwB,OAAVN,GAAgB,CACjE,MAAM6B,EAAa7B,EAAME,MAEnB4B,EAAWD,EADG7B,EAAMG,OAG1B,GADgByB,EAAuBgG,EAAkB/F,EAAY+F,EAAkB9F,EAAU4F,EAAalF,GACjG,CACX,MAAOF,EAAc,CAAGF,EAAeC,GAAwBL,EAAqBQ,EAAcoF,EAAkB/F,EAAY+F,EAAkB9F,GAG5IqB,EAAoBL,EAAqBV,EAFtBwF,EAAkB/F,EAAaS,EACjCsF,EAAkB9F,EAAWQ,EAC4CtC,GAChGwC,EAAeW,EAAoB,CAACA,KAAsBd,GAAwBA,EAClF2C,EAAShF,EAAMI,IAAK,MACpBwH,EAAkB,CACxB,MACMA,GAAmB9F,EAErB/B,EAAOA,EAAK8H,UAAU/F,EACvB,CACH,CA2GUgG,CAAoBP,EAAkBjH,EAAUsG,EACjD,EA1DT,SAA4BvD,EAAU/C,EAAU0E,GAC9C,MAAM+C,EAAkB1E,EAASnC,qBAC3BsG,EAAcnE,EAAS3B,iBACvB3B,EAAOsD,EAAS9B,iBAtMxB,IAAuBV,GAuMjBuG,EAAgBW,IAAqBA,EAAgBV,iBAAqBvG,EAAoBf,KAvM7Ec,EAuMoGd,IAAMgI,EAAgBC,aArMtI,kBAAkBrH,KAAKE,GAEvB,qBAAqBF,KAAKE,OAoMjCkH,EAAgBlE,OAAOR,GACvB0B,EAAegD,EAAiBzH,EAAU0E,GAC1CA,EAAS,KAAM+C,EAAgBxC,YAE7B6B,EAAgBI,IAAiBA,EAAYH,iBAAoBzG,EAAkBb,KACrFuF,EAAoBkC,GACpBzC,EAAeyC,EAAalH,EAAU0E,GACtCA,EAAS,KAAMwC,EAAYjC,UAE/B,CA6CQ0C,CAAmB5E,EAAU/C,EAAUsG,EACxC,KACCP,EAAO6B,gBAAgBC,GAAqBC,IAC9C,MAAMhE,EAAYC,IAClB,GAAgB,OAAZ+D,IAAqB1D,EAAkBN,GACzC,OAAO,EAYT,OAVcA,EAAUiE,UAClBC,SAAQtH,IACZ,MAAMiG,EAASjG,EAAKuH,YACpB,GAAInB,EAAgBH,GAIlB,OAFAA,EAAOuB,eAAevB,EAAOI,iBAC7BJ,EAAOwB,aACA,CACR,KAEI,CAAK,GACXC,GAAsB,GACxB,CAACrC,EAAQ/F,EAAU0E,GACxB,CACA,SAAS2D,GAAerI,SACtBA,EAAQ0E,SACRA,IAEA,MAAOqB,GAAUuC,IAEjB,OADAxC,EAAYC,EAAQ/F,EAAU0E,GACvB,IACT"}