{"version":3,"file":"LexicalDraggableBlockPlugin.dev.mjs.js","sources":["../../../../node_modules/@lexical/react/LexicalDraggableBlockPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { eventFiles } from '@lexical/rich-text';\nimport { mergeRegister, isHTMLElement, calculateZoomLevel } from '@lexical/utils';\nimport { DRAGOVER_COMMAND, COMMAND_PRIORITY_LOW, DROP_COMMAND, COMMAND_PRIORITY_HIGH, $getNodeByKey, $getNearestNodeFromDOMNode, $getRoot } from 'lexical';\nimport { useRef, useState, useCallback, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { jsxs, Fragment, jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(x, y) {\n    this._x = x;\n    this._y = y;\n  }\n  get x() {\n    return this._x;\n  }\n  get y() {\n    return this._y;\n  }\n  equals({\n    x,\n    y\n  }) {\n    return this.x === x && this.y === y;\n  }\n  calcDeltaXTo({\n    x\n  }) {\n    return this.x - x;\n  }\n  calcDeltaYTo({\n    y\n  }) {\n    return this.y - y;\n  }\n  calcHorizontalDistanceTo(point) {\n    return Math.abs(this.calcDeltaXTo(point));\n  }\n  calcVerticalDistance(point) {\n    return Math.abs(this.calcDeltaYTo(point));\n  }\n  calcDistanceTo(point) {\n    return Math.sqrt(Math.pow(this.calcDeltaXTo(point), 2) + Math.pow(this.calcDeltaYTo(point), 2));\n  }\n}\nfunction isPoint(x) {\n  return x instanceof Point;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Rectangle {\n  constructor(left, top, right, bottom) {\n    const [physicTop, physicBottom] = top <= bottom ? [top, bottom] : [bottom, top];\n    const [physicLeft, physicRight] = left <= right ? [left, right] : [right, left];\n    this._top = physicTop;\n    this._right = physicRight;\n    this._left = physicLeft;\n    this._bottom = physicBottom;\n  }\n  get top() {\n    return this._top;\n  }\n  get right() {\n    return this._right;\n  }\n  get bottom() {\n    return this._bottom;\n  }\n  get left() {\n    return this._left;\n  }\n  get width() {\n    return Math.abs(this._left - this._right);\n  }\n  get height() {\n    return Math.abs(this._bottom - this._top);\n  }\n  equals({\n    top,\n    left,\n    bottom,\n    right\n  }) {\n    return top === this._top && bottom === this._bottom && left === this._left && right === this._right;\n  }\n  contains(target) {\n    if (isPoint(target)) {\n      const {\n        x,\n        y\n      } = target;\n      const isOnTopSide = y < this._top;\n      const isOnBottomSide = y > this._bottom;\n      const isOnLeftSide = x < this._left;\n      const isOnRightSide = x > this._right;\n      const result = !isOnTopSide && !isOnBottomSide && !isOnLeftSide && !isOnRightSide;\n      return {\n        reason: {\n          isOnBottomSide,\n          isOnLeftSide,\n          isOnRightSide,\n          isOnTopSide\n        },\n        result\n      };\n    } else {\n      const {\n        top,\n        left,\n        bottom,\n        right\n      } = target;\n      return top >= this._top && top <= this._bottom && bottom >= this._top && bottom <= this._bottom && left >= this._left && left <= this._right && right >= this._left && right <= this._right;\n    }\n  }\n  intersectsWith(rect) {\n    const {\n      left: x1,\n      top: y1,\n      width: w1,\n      height: h1\n    } = rect;\n    const {\n      left: x2,\n      top: y2,\n      width: w2,\n      height: h2\n    } = this;\n    const maxX = x1 + w1 >= x2 + w2 ? x1 + w1 : x2 + w2;\n    const maxY = y1 + h1 >= y2 + h2 ? y1 + h1 : y2 + h2;\n    const minX = x1 <= x2 ? x1 : x2;\n    const minY = y1 <= y2 ? y1 : y2;\n    return maxX - minX <= w1 + w2 && maxY - minY <= h1 + h2;\n  }\n  generateNewRect({\n    left = this.left,\n    top = this.top,\n    right = this.right,\n    bottom = this.bottom\n  }) {\n    return new Rectangle(left, top, right, bottom);\n  }\n  static fromLTRB(left, top, right, bottom) {\n    return new Rectangle(left, top, right, bottom);\n  }\n  static fromLWTH(left, width, top, height) {\n    return new Rectangle(left, top, left + width, top + height);\n  }\n  static fromPoints(startPoint, endPoint) {\n    const {\n      y: top,\n      x: left\n    } = startPoint;\n    const {\n      y: bottom,\n      x: right\n    } = endPoint;\n    return Rectangle.fromLTRB(left, top, right, bottom);\n  }\n  static fromDOM(dom) {\n    const {\n      top,\n      width,\n      left,\n      height\n    } = dom.getBoundingClientRect();\n    return Rectangle.fromLWTH(left, width, top, height);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SPACE = 4;\nconst TARGET_LINE_HALF_HEIGHT = 2;\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block';\nconst TEXT_BOX_HORIZONTAL_PADDING = 28;\nconst Downward = 1;\nconst Upward = -1;\nconst Indeterminate = 0;\nlet prevIndex = Infinity;\nfunction getCurrentIndex(keysLength) {\n  if (keysLength === 0) {\n    return Infinity;\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex;\n  }\n  return Math.floor(keysLength / 2);\n}\nfunction getTopLevelNodeKeys(editor) {\n  return editor.getEditorState().read(() => $getRoot().getChildrenKeys());\n}\nfunction getCollapsedMargins(elem) {\n  const getMargin = (element, margin) => element ? parseFloat(window.getComputedStyle(element)[margin]) : 0;\n  const {\n    marginTop,\n    marginBottom\n  } = window.getComputedStyle(elem);\n  const prevElemSiblingMarginBottom = getMargin(elem.previousElementSibling, 'marginBottom');\n  const nextElemSiblingMarginTop = getMargin(elem.nextElementSibling, 'marginTop');\n  const collapsedTopMargin = Math.max(parseFloat(marginTop), prevElemSiblingMarginBottom);\n  const collapsedBottomMargin = Math.max(parseFloat(marginBottom), nextElemSiblingMarginTop);\n  return {\n    marginBottom: collapsedBottomMargin,\n    marginTop: collapsedTopMargin\n  };\n}\nfunction getBlockElement(anchorElem, editor, event, useEdgeAsDefault = false) {\n  const anchorElementRect = anchorElem.getBoundingClientRect();\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor);\n  let blockElem = null;\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const [firstNode, lastNode] = [editor.getElementByKey(topLevelNodeKeys[0]), editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1])];\n      const [firstNodeRect, lastNodeRect] = [firstNode != null ? firstNode.getBoundingClientRect() : undefined, lastNode != null ? lastNode.getBoundingClientRect() : undefined];\n      if (firstNodeRect && lastNodeRect) {\n        const firstNodeZoom = calculateZoomLevel(firstNode);\n        const lastNodeZoom = calculateZoomLevel(lastNode);\n        if (event.y / firstNodeZoom < firstNodeRect.top) {\n          blockElem = firstNode;\n        } else if (event.y / lastNodeZoom > lastNodeRect.bottom) {\n          blockElem = lastNode;\n        }\n        if (blockElem) {\n          return;\n        }\n      }\n    }\n    let index = getCurrentIndex(topLevelNodeKeys.length);\n    let direction = Indeterminate;\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index];\n      const elem = editor.getElementByKey(key);\n      if (elem === null) {\n        break;\n      }\n      const zoom = calculateZoomLevel(elem);\n      const point = new Point(event.x / zoom, event.y / zoom);\n      const domRect = Rectangle.fromDOM(elem);\n      const {\n        marginTop,\n        marginBottom\n      } = getCollapsedMargins(elem);\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop\n      });\n      const {\n        result,\n        reason: {\n          isOnTopSide,\n          isOnBottomSide\n        }\n      } = rect.contains(point);\n      if (result) {\n        blockElem = elem;\n        prevIndex = index;\n        break;\n      }\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward;\n        } else if (isOnBottomSide) {\n          direction = Downward;\n        } else {\n          // stop search block element\n          direction = Infinity;\n        }\n      }\n      index += direction;\n    }\n  });\n  return blockElem;\n}\nfunction setMenuPosition(targetElem, floatingElem, anchorElem) {\n  if (!targetElem) {\n    floatingElem.style.opacity = '0';\n    floatingElem.style.transform = 'translate(-10000px, -10000px)';\n    return;\n  }\n  const targetRect = targetElem.getBoundingClientRect();\n  const targetStyle = window.getComputedStyle(targetElem);\n  const floatingElemRect = floatingElem.getBoundingClientRect();\n  const anchorElementRect = anchorElem.getBoundingClientRect();\n\n  // top left\n  let targetCalculateHeight = parseInt(targetStyle.lineHeight, 10);\n  if (isNaN(targetCalculateHeight)) {\n    // middle\n    targetCalculateHeight = targetRect.bottom - targetRect.top;\n  }\n  const top = targetRect.top + (targetCalculateHeight - floatingElemRect.height) / 2 - anchorElementRect.top;\n  const left = SPACE;\n  floatingElem.style.opacity = '1';\n  floatingElem.style.transform = `translate(${left}px, ${top}px)`;\n}\nfunction setDragImage(dataTransfer, draggableBlockElem) {\n  const {\n    transform\n  } = draggableBlockElem.style;\n\n  // Remove dragImage borders\n  draggableBlockElem.style.transform = 'translateZ(0)';\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0);\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform;\n  });\n}\nfunction setTargetLine(targetLineElem, targetBlockElem, mouseY, anchorElem) {\n  const {\n    top: targetBlockElemTop,\n    height: targetBlockElemHeight\n  } = targetBlockElem.getBoundingClientRect();\n  const {\n    top: anchorTop,\n    width: anchorWidth\n  } = anchorElem.getBoundingClientRect();\n  const {\n    marginTop,\n    marginBottom\n  } = getCollapsedMargins(targetBlockElem);\n  let lineTop = targetBlockElemTop;\n  if (mouseY >= targetBlockElemTop) {\n    lineTop += targetBlockElemHeight + marginBottom / 2;\n  } else {\n    lineTop -= marginTop / 2;\n  }\n  const top = lineTop - anchorTop - TARGET_LINE_HALF_HEIGHT;\n  const left = TEXT_BOX_HORIZONTAL_PADDING - SPACE;\n  targetLineElem.style.transform = `translate(${left}px, ${top}px)`;\n  targetLineElem.style.width = `${anchorWidth - (TEXT_BOX_HORIZONTAL_PADDING - SPACE) * 2}px`;\n  targetLineElem.style.opacity = '.4';\n}\nfunction hideTargetLine(targetLineElem) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0';\n    targetLineElem.style.transform = 'translate(-10000px, -10000px)';\n  }\n}\nfunction useDraggableBlockMenu(editor, anchorElem, menuRef, targetLineRef, isEditable, menuComponent, targetLineComponent, isOnMenu, onElementChanged) {\n  const scrollerElem = anchorElem.parentElement;\n  const isDraggingBlockRef = useRef(false);\n  const [draggableBlockElem, setDraggableBlockElemState] = useState(null);\n  const setDraggableBlockElem = useCallback(elem => {\n    setDraggableBlockElemState(elem);\n    if (onElementChanged) {\n      onElementChanged(elem);\n    }\n  }, [onElementChanged]);\n  useEffect(() => {\n    function onMouseMove(event) {\n      const target = event.target;\n      if (!isHTMLElement(target)) {\n        setDraggableBlockElem(null);\n        return;\n      }\n      if (isOnMenu(target)) {\n        return;\n      }\n      const _draggableBlockElem = getBlockElement(anchorElem, editor, event);\n      setDraggableBlockElem(_draggableBlockElem);\n    }\n    function onMouseLeave() {\n      setDraggableBlockElem(null);\n    }\n    if (scrollerElem != null) {\n      scrollerElem.addEventListener('mousemove', onMouseMove);\n      scrollerElem.addEventListener('mouseleave', onMouseLeave);\n    }\n    return () => {\n      if (scrollerElem != null) {\n        scrollerElem.removeEventListener('mousemove', onMouseMove);\n        scrollerElem.removeEventListener('mouseleave', onMouseLeave);\n      }\n    };\n  }, [scrollerElem, anchorElem, editor, isOnMenu, setDraggableBlockElem]);\n  useEffect(() => {\n    if (menuRef.current) {\n      setMenuPosition(draggableBlockElem, menuRef.current, anchorElem);\n    }\n  }, [anchorElem, draggableBlockElem, menuRef]);\n  useEffect(() => {\n    function onDragover(event) {\n      if (!isDraggingBlockRef.current) {\n        return false;\n      }\n      const [isFileTransfer] = eventFiles(event);\n      if (isFileTransfer) {\n        return false;\n      }\n      const {\n        pageY,\n        target\n      } = event;\n      if (!isHTMLElement(target)) {\n        return false;\n      }\n      const targetBlockElem = getBlockElement(anchorElem, editor, event, true);\n      const targetLineElem = targetLineRef.current;\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false;\n      }\n      setTargetLine(targetLineElem, targetBlockElem, pageY / calculateZoomLevel(target), anchorElem);\n      // Prevent default event to be able to trigger onDrop events\n      event.preventDefault();\n      return true;\n    }\n    function $onDrop(event) {\n      if (!isDraggingBlockRef.current) {\n        return false;\n      }\n      const [isFileTransfer] = eventFiles(event);\n      if (isFileTransfer) {\n        return false;\n      }\n      const {\n        target,\n        dataTransfer,\n        pageY\n      } = event;\n      const dragData = dataTransfer != null ? dataTransfer.getData(DRAG_DATA_FORMAT) : '';\n      const draggedNode = $getNodeByKey(dragData);\n      if (!draggedNode) {\n        return false;\n      }\n      if (!isHTMLElement(target)) {\n        return false;\n      }\n      const targetBlockElem = getBlockElement(anchorElem, editor, event, true);\n      if (!targetBlockElem) {\n        return false;\n      }\n      const targetNode = $getNearestNodeFromDOMNode(targetBlockElem);\n      if (!targetNode) {\n        return false;\n      }\n      if (targetNode === draggedNode) {\n        return true;\n      }\n      const targetBlockElemTop = targetBlockElem.getBoundingClientRect().top;\n      if (pageY / calculateZoomLevel(target) >= targetBlockElemTop) {\n        targetNode.insertAfter(draggedNode);\n      } else {\n        targetNode.insertBefore(draggedNode);\n      }\n      setDraggableBlockElem(null);\n      return true;\n    }\n    return mergeRegister(editor.registerCommand(DRAGOVER_COMMAND, event => {\n      return onDragover(event);\n    }, COMMAND_PRIORITY_LOW), editor.registerCommand(DROP_COMMAND, event => {\n      return $onDrop(event);\n    }, COMMAND_PRIORITY_HIGH));\n  }, [anchorElem, editor, targetLineRef, setDraggableBlockElem]);\n  function onDragStart(event) {\n    const dataTransfer = event.dataTransfer;\n    if (!dataTransfer || !draggableBlockElem) {\n      return;\n    }\n    setDragImage(dataTransfer, draggableBlockElem);\n    let nodeKey = '';\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem);\n      if (node) {\n        nodeKey = node.getKey();\n      }\n    });\n    isDraggingBlockRef.current = true;\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey);\n  }\n  function onDragEnd() {\n    isDraggingBlockRef.current = false;\n    hideTargetLine(targetLineRef.current);\n  }\n  return /*#__PURE__*/createPortal(/*#__PURE__*/jsxs(Fragment, {\n    children: [/*#__PURE__*/jsx(\"div\", {\n      draggable: true,\n      onDragStart: onDragStart,\n      onDragEnd: onDragEnd,\n      children: isEditable && menuComponent\n    }), targetLineComponent]\n  }), anchorElem);\n}\nfunction DraggableBlockPlugin_EXPERIMENTAL({\n  anchorElem = document.body,\n  menuRef,\n  targetLineRef,\n  menuComponent,\n  targetLineComponent,\n  isOnMenu,\n  onElementChanged\n}) {\n  const [editor] = useLexicalComposerContext();\n  return useDraggableBlockMenu(editor, anchorElem, menuRef, targetLineRef, editor._editable, menuComponent, targetLineComponent, isOnMenu, onElementChanged);\n}\n\nexport { DraggableBlockPlugin_EXPERIMENTAL };\n"],"names":["Point","constructor","x","y","this","_x","_y","equals","calcDeltaXTo","calcDeltaYTo","calcHorizontalDistanceTo","point","Math","abs","calcVerticalDistance","calcDistanceTo","sqrt","pow","Rectangle","left","top","right","bottom","physicTop","physicBottom","physicLeft","physicRight","_top","_right","_left","_bottom","width","height","contains","target","isOnTopSide","isOnBottomSide","isOnLeftSide","isOnRightSide","reason","result","intersectsWith","rect","x1","y1","w1","h1","x2","y2","w2","h2","generateNewRect","fromLTRB","fromLWTH","fromPoints","startPoint","endPoint","fromDOM","dom","getBoundingClientRect","DRAG_DATA_FORMAT","prevIndex","Infinity","getCollapsedMargins","elem","getMargin","element","margin","parseFloat","window","getComputedStyle","marginTop","marginBottom","prevElemSiblingMarginBottom","previousElementSibling","nextElemSiblingMarginTop","nextElementSibling","collapsedTopMargin","max","getBlockElement","anchorElem","editor","event","useEdgeAsDefault","anchorElementRect","topLevelNodeKeys","getEditorState","read","$getRoot","getChildrenKeys","getTopLevelNodeKeys","blockElem","firstNode","lastNode","getElementByKey","length","firstNodeRect","lastNodeRect","undefined","firstNodeZoom","calculateZoomLevel","lastNodeZoom","index","keysLength","floor","direction","key","zoom","domRect","useDraggableBlockMenu","menuRef","targetLineRef","isEditable","menuComponent","targetLineComponent","isOnMenu","onElementChanged","scrollerElem","parentElement","isDraggingBlockRef","useRef","draggableBlockElem","setDraggableBlockElemState","useState","setDraggableBlockElem","useCallback","useEffect","onMouseMove","isHTMLElement","_draggableBlockElem","onMouseLeave","addEventListener","removeEventListener","current","targetElem","floatingElem","style","opacity","transform","targetRect","targetStyle","floatingElemRect","targetCalculateHeight","parseInt","lineHeight","isNaN","setMenuPosition","onDragover","isFileTransfer","eventFiles","pageY","targetBlockElem","targetLineElem","mouseY","targetBlockElemTop","targetBlockElemHeight","anchorTop","anchorWidth","lineTop","setTargetLine","preventDefault","mergeRegister","registerCommand","DRAGOVER_COMMAND","COMMAND_PRIORITY_LOW","DROP_COMMAND","dataTransfer","dragData","getData","draggedNode","$getNodeByKey","targetNode","$getNearestNodeFromDOMNode","insertAfter","insertBefore","$onDrop","COMMAND_PRIORITY_HIGH","createPortal","jsxs","exports","Fragment","children","jsx","draggable","onDragStart","setDragImage","setTimeout","nodeKey","update","node","getKey","setData","onDragEnd","DraggableBlockPlugin_EXPERIMENTAL","document","body","useLexicalComposerContext","_editable"],"mappings":"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"}