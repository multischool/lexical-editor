import{useCollaborationContext as e}from"./LexicalCollaborationContext.mjs.js";import{LexicalComposerContext as t,createLexicalComposerContext as o}from"./LexicalComposerContext.mjs.js";import{useRef as i,useContext as n,useMemo as r,useEffect as s}from"react";import"../../react/jsx-runtime.js";import{j as a}from"../../../_virtual/jsx-runtime.js";function c(e){{let t=!1;return()=>{t||console.warn(e),t=!0}}}function l(e){const t=e.transform();return new Set(t?[t]:[])}const d=c("LexicalNestedComposer initialNodes is deprecated and will be removed in v0.32.0, it has never worked correctly.\nYou can configure your editor's nodes with createEditor({nodes: [], parentEditor: $getEditor()})"),p=c("LexicalNestedComposer initialEditor should explicitly initialize its namespace when the node configuration differs from the parentEditor. For backwards compatibility, the namespace will be initialized from parentEditor until v0.32.0, but this has always had incorrect copy/paste behavior when the configuration differed.\nYou can configure your editor's namespace with createEditor({namespace: 'nested-editor-namespace', nodes: [], parentEditor: $getEditor()}).");function m({initialEditor:c,children:m,initialNodes:f,initialTheme:u,skipCollabChecks:h,skipEditableListener:g}){const x=i(!1),E=n(t);null==E&&function(e){throw new Error(e)}("Unexpected parent context null on a nested composer");const[w,{getTheme:_}]=E,b=r((()=>{const e=u||_()||void 0,t=o(E,e);void 0!==e&&(c._config.theme=e),c._parentEditor=c._parentEditor||w;const i=c._createEditorArgs,n=i&&i.namespace;if(f){d(),n||(p(),c._config.namespace=w._config.namespace);for(let e of f){let t=null,o=null;if("function"!=typeof e){const i=e;e=i.replace,t=i.with,o=i.withKlass||null}const i=c._nodes.get(e.getType());c._nodes.set(e.getType(),{exportDOM:i?i.exportDOM:void 0,klass:e,replace:t,replaceWithKlass:o,transforms:l(e)})}}else if(i&&i.nodes)n||(p(),c._config.namespace=w._config.namespace);else{const e=c._nodes=new Map(w._nodes);n||(c._config.namespace=w._config.namespace);for(const[t,o]of e)c._nodes.set(t,{exportDOM:o.exportDOM,klass:o.klass,replace:o.replace,replaceWithKlass:o.replaceWithKlass,transforms:l(o.klass)})}return[c,t]}),[]),{isCollabActive:v,yjsDocMap:y}=e(),j=h||x.current||y.has(c.getKey());return s((()=>{j&&(x.current=!0)}),[j]),s((()=>{if(!g){const e=e=>c.setEditable(e);return e(w.isEditable()),w.registerEditableListener(e)}}),[c,w,g]),a.exports.jsx(t.Provider,{value:b,children:!v||j?m:null})}export{m as LexicalNestedComposer};
//# sourceMappingURL=LexicalNestedComposer.dev.mjs.js.map
