{"version":3,"file":"LexicalCharacterLimitPlugin.dev.mjs.js","sources":["../../../../node_modules/@lexical/react/LexicalCharacterLimitPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useEffect, useState, useMemo } from 'react';\nimport { OverflowNode, $isOverflowNode, $createOverflowNode } from '@lexical/overflow';\nimport { $rootTextContent } from '@lexical/text';\nimport { mergeRegister, $dfs, $unwrapNode } from '@lexical/utils';\nimport { DELETE_CHARACTER_COMMAND, $getSelection, $isRangeSelection, $isElementNode, COMMAND_PRIORITY_LOW, $isTextNode, $isLeafNode, $setSelection } from 'lexical';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nfunction useCharacterLimit(editor, maxCharacters, optional = Object.freeze({})) {\n  const {\n    strlen = input => input.length,\n    // UTF-16\n    remainingCharacters = () => {\n      return;\n    }\n  } = optional;\n  useEffect(() => {\n    if (!editor.hasNodes([OverflowNode])) {\n      {\n        formatDevErrorMessage(`useCharacterLimit: OverflowNode not registered on editor`);\n      }\n    }\n  }, [editor]);\n  useEffect(() => {\n    let text = editor.getEditorState().read($rootTextContent);\n    let lastComputedTextLength = 0;\n    return mergeRegister(editor.registerTextContentListener(currentText => {\n      text = currentText;\n    }), editor.registerUpdateListener(({\n      dirtyLeaves,\n      dirtyElements\n    }) => {\n      const isComposing = editor.isComposing();\n      const hasContentChanges = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (isComposing || !hasContentChanges) {\n        return;\n      }\n      const textLength = strlen(text);\n      const textLengthAboveThreshold = textLength > maxCharacters || lastComputedTextLength !== null && lastComputedTextLength > maxCharacters;\n      const diff = maxCharacters - textLength;\n      remainingCharacters(diff);\n      if (lastComputedTextLength === null || textLengthAboveThreshold) {\n        const offset = findOffset(text, maxCharacters, strlen);\n        editor.update(() => {\n          $wrapOverflowedNodes(offset);\n        }, {\n          tag: 'history-merge'\n        });\n      }\n      lastComputedTextLength = textLength;\n    }), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const overflow = anchorNode.getParent();\n      const overflowParent = overflow ? overflow.getParent() : null;\n      const parentNext = overflowParent ? overflowParent.getNextSibling() : null;\n      selection.deleteCharacter(isBackward);\n      if (overflowParent && overflowParent.isEmpty()) {\n        overflowParent.remove();\n      } else if ($isElementNode(parentNext) && parentNext.isEmpty()) {\n        parentNext.remove();\n      }\n      return true;\n    }, COMMAND_PRIORITY_LOW));\n  }, [editor, maxCharacters, remainingCharacters, strlen]);\n}\nfunction findOffset(text, maxCharacters, strlen) {\n  const Segmenter = Intl.Segmenter;\n  let offsetUtf16 = 0;\n  let offset = 0;\n  if (typeof Segmenter === 'function') {\n    const segmenter = new Segmenter();\n    const graphemes = segmenter.segment(text);\n    for (const {\n      segment: grapheme\n    } of graphemes) {\n      const nextOffset = offset + strlen(grapheme);\n      if (nextOffset > maxCharacters) {\n        break;\n      }\n      offset = nextOffset;\n      offsetUtf16 += grapheme.length;\n    }\n  } else {\n    const codepoints = Array.from(text);\n    const codepointsLength = codepoints.length;\n    for (let i = 0; i < codepointsLength; i++) {\n      const codepoint = codepoints[i];\n      const nextOffset = offset + strlen(codepoint);\n      if (nextOffset > maxCharacters) {\n        break;\n      }\n      offset = nextOffset;\n      offsetUtf16 += codepoint.length;\n    }\n  }\n  return offsetUtf16;\n}\nfunction $wrapOverflowedNodes(offset) {\n  const dfsNodes = $dfs();\n  const dfsNodesLength = dfsNodes.length;\n  let accumulatedLength = 0;\n  for (let i = 0; i < dfsNodesLength; i += 1) {\n    const {\n      node\n    } = dfsNodes[i];\n    if ($isOverflowNode(node)) {\n      const previousLength = accumulatedLength;\n      const nextLength = accumulatedLength + node.getTextContentSize();\n      if (nextLength <= offset) {\n        const parent = node.getParent();\n        const previousSibling = node.getPreviousSibling();\n        const nextSibling = node.getNextSibling();\n        $unwrapNode(node);\n        const selection = $getSelection();\n\n        // Restore selection when the overflow children are removed\n        if ($isRangeSelection(selection) && (!selection.anchor.getNode().isAttached() || !selection.focus.getNode().isAttached())) {\n          if ($isTextNode(previousSibling)) {\n            previousSibling.select();\n          } else if ($isTextNode(nextSibling)) {\n            nextSibling.select();\n          } else if (parent !== null) {\n            parent.select();\n          }\n        }\n      } else if (previousLength < offset) {\n        const descendant = node.getFirstDescendant();\n        const descendantLength = descendant !== null ? descendant.getTextContentSize() : 0;\n        const previousPlusDescendantLength = previousLength + descendantLength;\n        // For simple text we can redimension the overflow into a smaller and more accurate\n        // container\n        const firstDescendantIsSimpleText = $isTextNode(descendant) && descendant.isSimpleText();\n        const firstDescendantDoesNotOverflow = previousPlusDescendantLength <= offset;\n        if (firstDescendantIsSimpleText || firstDescendantDoesNotOverflow) {\n          $unwrapNode(node);\n        }\n      }\n    } else if ($isLeafNode(node)) {\n      const previousAccumulatedLength = accumulatedLength;\n      accumulatedLength += node.getTextContentSize();\n      if (accumulatedLength > offset && !$isOverflowNode(node.getParent())) {\n        const previousSelection = $getSelection();\n        let overflowNode;\n\n        // For simple text we can improve the limit accuracy by splitting the TextNode\n        // on the split point\n        if (previousAccumulatedLength < offset && $isTextNode(node) && node.isSimpleText()) {\n          const [, overflowedText] = node.splitText(offset - previousAccumulatedLength);\n          overflowNode = $wrapNode(overflowedText);\n        } else {\n          overflowNode = $wrapNode(node);\n        }\n        if (previousSelection !== null) {\n          $setSelection(previousSelection);\n        }\n        $mergePrevious(overflowNode);\n      }\n    }\n  }\n}\nfunction $wrapNode(node) {\n  const overflowNode = $createOverflowNode();\n  node.replace(overflowNode);\n  overflowNode.append(node);\n  return overflowNode;\n}\nfunction $mergePrevious(overflowNode) {\n  const previousNode = overflowNode.getPreviousSibling();\n  if (!$isOverflowNode(previousNode)) {\n    return;\n  }\n  const firstChild = overflowNode.getFirstChild();\n  const previousNodeChildren = previousNode.getChildren();\n  const previousNodeChildrenLength = previousNodeChildren.length;\n  if (firstChild === null) {\n    overflowNode.append(...previousNodeChildren);\n  } else {\n    for (let i = 0; i < previousNodeChildrenLength; i++) {\n      firstChild.insertBefore(previousNodeChildren[i]);\n    }\n  }\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const anchorNode = anchor.getNode();\n    const focus = selection.focus;\n    const focusNode = anchor.getNode();\n    if (anchorNode.is(previousNode)) {\n      anchor.set(overflowNode.getKey(), anchor.offset, 'element');\n    } else if (anchorNode.is(overflowNode)) {\n      anchor.set(overflowNode.getKey(), previousNodeChildrenLength + anchor.offset, 'element');\n    }\n    if (focusNode.is(previousNode)) {\n      focus.set(overflowNode.getKey(), focus.offset, 'element');\n    } else if (focusNode.is(overflowNode)) {\n      focus.set(overflowNode.getKey(), previousNodeChildrenLength + focus.offset, 'element');\n    }\n  }\n  previousNode.remove();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CHARACTER_LIMIT = 5;\nlet textEncoderInstance = null;\nfunction textEncoder() {\n  if (window.TextEncoder === undefined) {\n    return null;\n  }\n  if (textEncoderInstance === null) {\n    textEncoderInstance = new window.TextEncoder();\n  }\n  return textEncoderInstance;\n}\nfunction utf8Length(text) {\n  const currentTextEncoder = textEncoder();\n  if (currentTextEncoder === null) {\n    // http://stackoverflow.com/a/5515960/210370\n    const m = encodeURIComponent(text).match(/%[89ABab]/g);\n    return text.length + (m ? m.length : 0);\n  }\n  return currentTextEncoder.encode(text).length;\n}\nfunction DefaultRenderer({\n  remainingCharacters\n}) {\n  return /*#__PURE__*/jsx(\"span\", {\n    className: `characters-limit ${remainingCharacters < 0 ? 'characters-limit-exceeded' : ''}`,\n    children: remainingCharacters\n  });\n}\nfunction CharacterLimitPlugin({\n  charset = 'UTF-16',\n  maxLength = CHARACTER_LIMIT,\n  renderer = DefaultRenderer\n}) {\n  const [editor] = useLexicalComposerContext();\n  const [remainingCharacters, setRemainingCharacters] = useState(maxLength);\n  const characterLimitProps = useMemo(() => ({\n    remainingCharacters: setRemainingCharacters,\n    strlen: text => {\n      if (charset === 'UTF-8') {\n        return utf8Length(text);\n      } else if (charset === 'UTF-16') {\n        return text.length;\n      } else {\n        throw new Error('Unrecognized charset');\n      }\n    }\n  }), [charset]);\n  useCharacterLimit(editor, maxLength, characterLimitProps);\n  return renderer({\n    remainingCharacters\n  });\n}\n\nexport { CharacterLimitPlugin };\n"],"names":["useCharacterLimit","editor","maxCharacters","optional","Object","freeze","strlen","input","length","remainingCharacters","useEffect","hasNodes","OverflowNode","message","Error","formatDevErrorMessage","text","getEditorState","read","$rootTextContent","lastComputedTextLength","mergeRegister","registerTextContentListener","currentText","registerUpdateListener","dirtyLeaves","dirtyElements","isComposing","hasContentChanges","size","textLength","textLengthAboveThreshold","offset","Segmenter","Intl","offsetUtf16","graphemes","segment","grapheme","nextOffset","codepoints","Array","from","codepointsLength","i","codepoint","findOffset","update","dfsNodes","$dfs","dfsNodesLength","accumulatedLength","node","$isOverflowNode","previousLength","getTextContentSize","parent","getParent","previousSibling","getPreviousSibling","nextSibling","getNextSibling","$unwrapNode","selection","$getSelection","$isRangeSelection","anchor","getNode","isAttached","focus","$isTextNode","select","descendant","getFirstDescendant","previousPlusDescendantLength","isSimpleText","$isLeafNode","previousAccumulatedLength","previousSelection","overflowNode","overflowedText","splitText","$wrapNode","$setSelection","$mergePrevious","$wrapOverflowedNodes","tag","registerCommand","DELETE_CHARACTER_COMMAND","isBackward","overflow","overflowParent","parentNext","deleteCharacter","isEmpty","remove","$isElementNode","COMMAND_PRIORITY_LOW","$createOverflowNode","replace","append","previousNode","firstChild","getFirstChild","previousNodeChildren","getChildren","previousNodeChildrenLength","insertBefore","anchorNode","focusNode","is","set","getKey","textEncoderInstance","utf8Length","currentTextEncoder","undefined","window","TextEncoder","m","encodeURIComponent","match","encode","DefaultRenderer","jsx","className","children","CharacterLimitPlugin","charset","maxLength","renderer","useLexicalComposerContext","setRemainingCharacters","useState","useMemo"],"mappings":"opBA8BA,SAASA,EAAkBC,EAAQC,EAAeC,EAAWC,OAAOC,OAAO,CAAA,IACzE,MAAMC,OACJA,EAASC,GAASA,EAAMC,OAAMC,oBAE9BA,EAAsB,KACb,GAEPN,EACJO,GAAU,KACHT,EAAOU,SAAS,CAACC,KAb1B,SAA+BC,GAC7B,MAAM,IAAIC,MAAMD,EAClB,CAaQE,CAAsB,2DAEzB,GACA,CAACd,IACJS,GAAU,KACR,IAAIM,EAAOf,EAAOgB,iBAAiBC,KAAKC,GACpCC,EAAyB,EAC7B,OAAOC,EAAcpB,EAAOqB,6BAA4BC,IACtDP,EAAOO,CAAW,IAChBtB,EAAOuB,wBAAuB,EAChCC,cACAC,oBAEA,MAAMC,EAAc1B,EAAO0B,cACrBC,EAAoBH,EAAYI,KAAO,GAAKH,EAAcG,KAAO,EACvE,GAAIF,IAAgBC,EAClB,OAEF,MAAME,EAAaxB,EAAOU,GACpBe,EAA2BD,EAAa5B,GAA4C,OAA3BkB,GAAmCA,EAAyBlB,EAG3H,GADAO,EADaP,EAAgB4B,GAEE,OAA3BV,GAAmCW,EAA0B,CAC/D,MAAMC,EA2Bd,SAAoBhB,EAAMd,EAAeI,GACvC,MAAM2B,EAAYC,KAAKD,UACvB,IAAIE,EAAc,EACdH,EAAS,EACb,GAAyB,mBAAdC,EAA0B,CACnC,MACMG,GADY,IAAIH,GACMI,QAAQrB,GACpC,IAAK,MACHqB,QAASC,KACNF,EAAW,CACd,MAAMG,EAAaP,EAAS1B,EAAOgC,GACnC,GAAIC,EAAarC,EACf,MAEF8B,EAASO,EACTJ,GAAeG,EAAS9B,MACzB,CACL,KAAS,CACL,MAAMgC,EAAaC,MAAMC,KAAK1B,GACxB2B,EAAmBH,EAAWhC,OACpC,IAAK,IAAIoC,EAAI,EAAGA,EAAID,EAAkBC,IAAK,CACzC,MAAMC,EAAYL,EAAWI,GACvBL,EAAaP,EAAS1B,EAAOuC,GACnC,GAAIN,EAAarC,EACf,MAEF8B,EAASO,EACTJ,GAAeU,EAAUrC,MAC1B,CACF,CACD,OAAO2B,CACT,CA1DuBW,CAAW9B,EAAMd,EAAeI,GAC/CL,EAAO8C,QAAO,MA0DtB,SAA8Bf,GAC5B,MAAMgB,EAAWC,IACXC,EAAiBF,EAASxC,OAChC,IAAI2C,EAAoB,EACxB,IAAK,IAAIP,EAAI,EAAGA,EAAIM,EAAgBN,GAAK,EAAG,CAC1C,MAAMQ,KACJA,GACEJ,EAASJ,GACb,GAAIS,EAAgBD,GAAO,CACzB,MAAME,EAAiBH,EAEvB,GADmBA,EAAoBC,EAAKG,sBAC1BvB,EAAQ,CACxB,MAAMwB,EAASJ,EAAKK,YACdC,EAAkBN,EAAKO,qBACvBC,EAAcR,EAAKS,iBACzBC,EAAYV,GACZ,MAAMW,EAAYC,KAGdC,EAAkBF,IAAgBA,EAAUG,OAAOC,UAAUC,cAAiBL,EAAUM,MAAMF,UAAUC,eACtGE,EAAYZ,GACdA,EAAgBa,SACPD,EAAYV,GACrBA,EAAYW,SACQ,OAAXf,GACTA,EAAOe,SAGnB,MAAa,GAAIjB,EAAiBtB,EAAQ,CAClC,MAAMwC,EAAapB,EAAKqB,qBAElBC,EAA+BpB,GADG,OAAfkB,EAAsBA,EAAWjB,qBAAuB,IAI7Ce,EAAYE,IAAeA,EAAWG,gBACnCD,GAAgC1C,IAErE8B,EAAYV,EAEf,CACP,MAAW,GAAIwB,EAAYxB,GAAO,CAC5B,MAAMyB,EAA4B1B,EAElC,GADAA,GAAqBC,EAAKG,qBACtBJ,EAAoBnB,IAAWqB,EAAgBD,EAAKK,aAAc,CACpE,MAAMqB,EAAoBd,IAC1B,IAAIe,EAIJ,GAAIF,EAA4B7C,GAAUsC,EAAYlB,IAASA,EAAKuB,eAAgB,CAClF,MAAM,CAAGK,GAAkB5B,EAAK6B,UAAUjD,EAAS6C,GACnDE,EAAeG,EAAUF,EACnC,MACUD,EAAeG,EAAU9B,GAED,OAAtB0B,GACFK,EAAcL,GAEhBM,EAAeL,EAChB,CACF,CACF,CACH,CAvHUM,CAAqBrD,EAAO,GAC3B,CACDsD,IAAK,iBAER,CACDlE,EAAyBU,CAAU,IACjC7B,EAAOsF,gBAAgBC,GAA0BC,IACnD,MAAM1B,EAAYC,IAClB,IAAKC,EAAkBF,GACrB,OAAO,EAET,MACM2B,EADa3B,EAAUG,OAAOC,UACRV,YACtBkC,EAAiBD,EAAWA,EAASjC,YAAc,KACnDmC,EAAaD,EAAiBA,EAAe9B,iBAAmB,KAOtE,OANAE,EAAU8B,gBAAgBJ,GACtBE,GAAkBA,EAAeG,UACnCH,EAAeI,SACNC,EAAeJ,IAAeA,EAAWE,WAClDF,EAAWG,UAEN,CAAI,GACVE,GAAsB,GACxB,CAAChG,EAAQC,EAAeO,EAAqBH,GAClD,CAgGA,SAAS4E,EAAU9B,GACjB,MAAM2B,EAAemB,IAGrB,OAFA9C,EAAK+C,QAAQpB,GACbA,EAAaqB,OAAOhD,GACb2B,CACT,CACA,SAASK,EAAeL,GACtB,MAAMsB,EAAetB,EAAapB,qBAClC,IAAKN,EAAgBgD,GACnB,OAEF,MAAMC,EAAavB,EAAawB,gBAC1BC,EAAuBH,EAAaI,cACpCC,EAA6BF,EAAqBhG,OACxD,GAAmB,OAAf8F,EACFvB,EAAaqB,UAAUI,QAEvB,IAAK,IAAI5D,EAAI,EAAGA,EAAI8D,EAA4B9D,IAC9C0D,EAAWK,aAAaH,EAAqB5D,IAGjD,MAAMmB,EAAYC,IAClB,GAAIC,EAAkBF,GAAY,CAChC,MAAMG,EAASH,EAAUG,OACnB0C,EAAa1C,EAAOC,UACpBE,EAAQN,EAAUM,MAClBwC,EAAY3C,EAAOC,UACrByC,EAAWE,GAAGT,GAChBnC,EAAO6C,IAAIhC,EAAaiC,SAAU9C,EAAOlC,OAAQ,WACxC4E,EAAWE,GAAG/B,IACvBb,EAAO6C,IAAIhC,EAAaiC,SAAUN,EAA6BxC,EAAOlC,OAAQ,WAE5E6E,EAAUC,GAAGT,GACfhC,EAAM0C,IAAIhC,EAAaiC,SAAU3C,EAAMrC,OAAQ,WACtC6E,EAAUC,GAAG/B,IACtBV,EAAM0C,IAAIhC,EAAaiC,SAAUN,EAA6BrC,EAAMrC,OAAQ,UAE/E,CACDqE,EAAaN,QACf,CAWA,IAAIkB,EAAsB,KAU1B,SAASC,EAAWlG,GAClB,MAAMmG,OATqBC,IAAvBC,OAAOC,YACF,MAEmB,OAAxBL,IACFA,EAAsB,IAAII,OAAOC,aAE5BL,GAIP,GAA2B,OAAvBE,EAA6B,CAE/B,MAAMI,EAAIC,mBAAmBxG,GAAMyG,MAAM,cACzC,OAAOzG,EAAKR,QAAU+G,EAAIA,EAAE/G,OAAS,EACtC,CACD,OAAO2G,EAAmBO,OAAO1G,GAAMR,MACzC,CACA,SAASmH,GAAgBlH,oBACvBA,IAEA,OAAoBmH,EAAAA,QAAAA,IAAI,OAAQ,CAC9BC,UAAW,qBAAoBpH,EAAsB,EAAI,4BAA8B,IACvFqH,SAAUrH,GAEd,CACA,SAASsH,GAAqBC,QAC5BA,EAAU,SAAQC,UAClBA,EA9BsB,EA8BKC,SAC3BA,EAAWP,IAEX,MAAO1H,GAAUkI,KACV1H,EAAqB2H,GAA0BC,EAASJ,GAc/D,OADAjI,EAAkBC,EAAQgI,EAZEK,GAAQ,KAAO,CACzC7H,oBAAqB2H,EACrB9H,OAAQU,IACN,GAAgB,UAAZgH,EACF,OAAOd,EAAWlG,GACb,GAAgB,WAAZgH,EACT,OAAOhH,EAAKR,OAEZ,MAAM,IAAIM,MAAM,uBACjB,KAED,CAACkH,KAEEE,EAAS,CACdzH,uBAEJ"}