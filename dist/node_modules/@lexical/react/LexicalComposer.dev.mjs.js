import{createLexicalComposerContext as e,LexicalComposerContext as t}from"./LexicalComposerContext.mjs.js";import{createEditor as o,$getRoot as n,$createParagraphNode as i,$getSelection as r}from"lexical";import{useMemo as s,useLayoutEffect as a,useEffect as l}from"react";import"../../react/jsx-runtime.js";import{j as c}from"../../../_virtual/jsx-runtime.js";const d="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,m=d?a:l,u={tag:"history-merge"};function p({initialConfig:a,children:l}){const p=s((()=>{const{theme:t,namespace:s,nodes:l,onError:c,editorState:m,html:p}=a,f=e(null,t),E=o({editable:a.editable,html:p,namespace:s,nodes:l,onError:e=>c(e,E),theme:t});return function(e,t){if(null===t)return;if(void 0===t)e.update((()=>{const t=n();if(t.isEmpty()){const o=i();t.append(o);const n=d?document.activeElement:null;(null!==r()||null!==n&&n===e.getRootElement())&&o.select()}}),u);else if(null!==t)switch(typeof t){case"string":{const o=e.parseEditorState(t);e.setEditorState(o,u);break}case"object":e.setEditorState(t,u);break;case"function":e.update((()=>{n().isEmpty()&&t(e)}),u)}}(E,m),[E,f]}),[]);return m((()=>{const e=a.editable,[t]=p;t.setEditable(void 0===e||e)}),[]),c.exports.jsx(t.Provider,{value:p,children:l})}export{p as LexicalComposer};
//# sourceMappingURL=LexicalComposer.dev.mjs.js.map
