{"version":3,"file":"LexicalComposer.dev.mjs.js","sources":["../../../../node_modules/@lexical/react/LexicalComposer.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createLexicalComposerContext, LexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEditor, $getRoot, $createParagraphNode, $getSelection } from 'lexical';\nimport { useLayoutEffect, useEffect, useMemo } from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = useMemo(() => {\n    const {\n      theme,\n      namespace,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = createLexicalComposerContext(null, theme);\n    const editor = createEditor({\n      editable: initialConfig.editable,\n      html,\n      namespace,\n      nodes,\n      onError: error => onError(error, editor),\n      theme\n    });\n    initializeEditor(editor, initialEditorState);\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/jsx(LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = $getRoot();\n      if (root.isEmpty()) {\n        const paragraph = $createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ($getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = $getRoot();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexport { LexicalComposer };\n"],"names":["CAN_USE_DOM","window","document","createElement","useLayoutEffectImpl","useLayoutEffect","useEffect","HISTORY_MERGE_OPTIONS","tag","LexicalComposer","initialConfig","children","composerContext","useMemo","theme","namespace","nodes","onError","editorState","initialEditorState","html","context","createLexicalComposerContext","editor","createEditor","editable","error","undefined","update","root","$getRoot","isEmpty","paragraph","$createParagraphNode","append","activeElement","$getSelection","getRootElement","select","parsedEditorState","parseEditorState","setEditorState","initializeEditor","isEditable","setEditable","jsx","exports","LexicalComposerContext","Provider","value"],"mappings":"yWAqBA,MAAMA,EAAgC,oBAAXC,aAAqD,IAApBA,OAAOC,eAAqE,IAAlCD,OAAOC,SAASC,cAchHC,EAAsBJ,EAAcK,EAAkBC,EAUtDC,EAAwB,CAC5BC,IAAK,iBAEP,SAASC,GAAgBC,cACvBA,EAAaC,SACbA,IAEA,MAAMC,EAAkBC,GAAQ,KAC9B,MAAMC,MACJA,EAAKC,UACLA,EAASC,MACTA,EAAKC,QACLA,EACAC,YAAaC,EAAkBC,KAC/BA,GACEV,EACEW,EAAUC,EAA6B,KAAMR,GAC7CS,EAASC,EAAa,CAC1BC,SAAUf,EAAce,SACxBL,OACAL,YACAC,QACAC,QAASS,GAAST,EAAQS,EAAOH,GACjCT,UAGF,OAkBJ,SAA0BS,EAAQJ,GAChC,GAA2B,OAAvBA,EACF,OACK,QAA2BQ,IAAvBR,EACTI,EAAOK,QAAO,KACZ,MAAMC,EAAOC,IACb,GAAID,EAAKE,UAAW,CAClB,MAAMC,EAAYC,IAClBJ,EAAKK,OAAOF,GACZ,MAAMG,EAAgBnC,EAAcE,SAASiC,cAAgB,MACrC,OAApBC,KAA8C,OAAlBD,GAA0BA,IAAkBZ,EAAOc,mBACjFL,EAAUM,QAEb,IACA/B,QACE,GAA2B,OAAvBY,EACT,cAAeA,GACb,IAAK,SACH,CACE,MAAMoB,EAAoBhB,EAAOiB,iBAAiBrB,GAClDI,EAAOkB,eAAeF,EAAmBhC,GACzC,KACD,CACH,IAAK,SAEDgB,EAAOkB,eAAetB,EAAoBZ,GAC1C,MAEJ,IAAK,WAEDgB,EAAOK,QAAO,KACCE,IACJC,WACPZ,EAAmBI,EACpB,GACAhB,GAKb,CA3DImC,CAAiBnB,EAAQJ,GAClB,CAACI,EAAQF,EAAQ,GAI1B,IASA,OARAjB,GAAoB,KAClB,MAAMuC,EAAajC,EAAce,UAC1BF,GAAUX,EACjBW,EAAOqB,iBAA2BjB,IAAfgB,GAA2BA,EAAkB,GAI/D,IACiBE,EAAGC,QAAAD,IAACE,EAAuBC,SAAU,CACvDC,MAAOrC,EACPD,SAAUA,GAEd"}