{"version":3,"file":"LexicalHtml.dev.mjs.js","sources":["../../../../node_modules/@lexical/html/LexicalHtml.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],"names":["$generateNodesFromDOM","editor","dom","elements","body","childNodes","lexicalNodes","allArtificialNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","node","getNextSibling","ArtificialNode__DO_NOT_USE","insertAfter","$createLineBreakNode","children","getChildren","child","insertBefore","remove","$unwrapArtificalNodes","$generateHtmlFromNodes","selection","document","window","global","Error","container","createElement","topLevelChildren","$getRoot","$appendNodesToHTML","innerHTML","currentNode","parentElement","shouldInclude","isSelected","shouldExclude","$isElementNode","excludeFromCopy","target","clone","$cloneWithProperties","$isTextNode","$sliceSelectedTextNodeContent","registeredNode","_nodes","get","getType","exportOutput","undefined","exportDOM","after","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","isHTMLElement","isDocumentFragment","append","newElement","call","replaceChildren","replaceWith","Set","hasBlockAncestorLexicalNode","forChildMap","Map","parentLexicalNode","currentLexicalNode","transformFunction","domNode","cachedConversions","_htmlConversions","toLowerCase","currentConversion","cachedConversion","domConversion","priority","conversion","getConversionFunction","transformOutput","postTransform","transformNodes","Array","isArray","forChildFunction","push","forChild","set","childLexicalNodes","hasBlockAncestorLexicalNodeForChildren","$isRootOrShadowRoot","$isBlockElementNode","isBlockDomNode","wrapContinuousInlines","artificialNode","$createParagraphNode","nextSibling","previousSibling","isInlineDomNode","isDomNodeBetweenTwoInlineNodes","nodes","createWrapperFn","textAlign","style","out","continuousInlines","getFormat","setFormat","wrapper"],"mappings":"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"}