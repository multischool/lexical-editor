import{$sliceSelectedTextNodeContent as e}from"../selection/LexicalSelection.mjs.js";import{isHTMLElement as n,isBlockDomNode as t}from"@lexical/utils";import{ArtificialNode__DO_NOT_USE as o,$createLineBreakNode as l,$getRoot as r,$isElementNode as i,$cloneWithProperties as s,$isTextNode as c,isDocumentFragment as u,$isRootOrShadowRoot as a,$isBlockElementNode as f,isInlineDomNode as d,$createParagraphNode as p}from"lexical";function h(e,n){const t=n.body?n.body.childNodes:[];let r=[];const i=[];for(let n=0;n<t.length;n++){const o=t[n];if(!x.has(o.nodeName)){const n=y(o,e,i,!1);null!==n&&(r=r.concat(n))}}return function(e){for(const n of e)n.getNextSibling()instanceof o&&n.insertAfter(l());for(const n of e){const e=n.getChildren();for(const t of e)n.insertBefore(t);n.remove()}}(i),r}function m(e,n){if("undefined"==typeof document||"undefined"==typeof window&&void 0===global.window)throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");const t=document.createElement("div"),o=r().getChildren();for(let l=0;l<o.length;l++)g(e,o[l],t,n);return t.innerHTML}function g(t,o,l,r=null){let a=null===r||o.isSelected(r);const f=i(o)&&o.excludeFromCopy("html");let d=o;if(null!==r){let n=s(o);n=c(n)&&null!==r?e(r,n):n,d=n}const p=i(d)?d.getChildren():[],h=t._nodes.get(d.getType());let m;m=h&&void 0!==h.exportDOM?h.exportDOM(t,d):d.exportDOM(t);const{element:x,after:y}=m;if(!x)return!1;const w=document.createDocumentFragment();for(let e=0;e<p.length;e++){const n=p[e],l=g(t,n,w,r);!a&&i(o)&&l&&o.extractWithChild(n,r,"html")&&(a=!0)}if(a&&!f){if((n(x)||u(x))&&x.append(w),l.append(x),y){const e=y.call(d,x);e&&(u(x)?x.replaceChildren(e):x.replaceWith(e))}}else l.append(w);return a}const x=new Set(["STYLE","SCRIPT"]);function y(e,n,r,s,c=new Map,u){let h=[];if(x.has(e.nodeName))return h;let m=null;const g=function(e,n){const{nodeName:t}=e,o=n._htmlConversions.get(t.toLowerCase());let l=null;if(void 0!==o)for(const n of o){const t=n(e);null!==t&&(null===l||(l.priority||0)<=(t.priority||0))&&(l=t)}return null!==l?l.conversion:null}(e,n),w=g?g(e):null;let b=null;if(null!==w){b=w.after;const n=w.node;if(m=Array.isArray(n)?n[n.length-1]:n,null!==m){for(const[,e]of c)if(m=e(m,u),!m)break;m&&h.push(...Array.isArray(n)?n:[m])}null!=w.forChild&&c.set(e.nodeName,w.forChild)}const C=e.childNodes;let S=[];const N=(null==m||!a(m))&&(null!=m&&f(m)||s);for(let e=0;e<C.length;e++)S.push(...y(C[e],n,r,N,new Map(c),m));return null!=b&&(S=b(S)),t(e)&&(S=function(e,n,t){const o=e.style.textAlign,l=[];let r=[];for(let e=0;e<n.length;e++){const i=n[e];if(f(i))o&&!i.getFormat()&&i.setFormat(o),l.push(i);else if(r.push(i),e===n.length-1||e<n.length-1&&f(n[e+1])){const e=t();e.setFormat(o),e.append(...r),l.push(e),r=[]}}return l}(e,S,N?()=>{const e=new o;return r.push(e),e}:p)),null==m?S.length>0?h=h.concat(S):t(e)&&function(e){return null!=e.nextSibling&&null!=e.previousSibling&&(d(e.nextSibling)&&d(e.previousSibling))}(e)&&(h=h.concat(l())):i(m)&&m.append(...S),h}export{m as $generateHtmlFromNodes,h as $generateNodesFromDOM};
//# sourceMappingURL=LexicalHtml.prod.mjs.js.map
