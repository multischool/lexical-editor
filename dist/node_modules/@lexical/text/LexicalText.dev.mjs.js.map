{"version":3,"file":"LexicalText.dev.mjs.js","sources":["../../../../node_modules/@lexical/text/LexicalText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        formatDevErrorMessage(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n"],"names":["$rootTextContent","$getRoot","getTextContent","$isRootTextContentEmpty","isEditorComposing","trim","text","$isRootTextContentEmptyCurry","$canShowPlaceholder","isComposing","children","getChildren","childrenLength","length","i","topBlock","$isDecoratorNode","$isElementNode","$isParagraphNode","__indent","topBlockChildren","topBlockChildrenLength","s","child","$isTextNode","$canShowPlaceholderCurry","$findTextIntersectionFromCharacters","root","targetCharacters","node","getFirstChild","currentCharacters","mainLoop","characters","getTextContentSize","offset","sibling","getNextSibling","parent","getParent","parentSibling","formatDevErrorMessage","message","Error","registerLexicalTextEntity","editor","getMatch","targetNode","createNode","isTargetNode","$replaceWithSimpleText","textNode","$createTextNode","setFormat","getFormat","replace","registerNodeTransform","TextNode","isSimpleText","match","prevSibling","getPreviousSibling","currentNode","previousText","prevMatch","getLatest","__mode","getMode","diff","end","newTextContent","slice","select","setTextContent","remove","remainingText","start","prevMatchLengthToSkip","nodeToReplace","nextText","nextSibling","nextMatch","markDirty","isTextEntity","splitText","undefined","replacementNode"],"mappings":"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"}