{"version":3,"file":"LexicalHistory.dev.mjs.js","sources":["../../../../node_modules/@lexical/history/LexicalHistory.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { mergeRegister } from '@lexical/utils';\nimport { UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexport { createEmptyHistoryState, registerHistory };\n"],"names":["getChangeType","prevEditorState","nextEditorState","dirtyLeavesSet","dirtyElementsSet","isComposing","size","nextSelection","_selection","prevSelection","$isRangeSelection","isCollapsed","dirtyNodes","editorState","dirtyLeaves","dirtyElements","nodeMap","_nodeMap","nodes","dirtyLeafKey","dirtyLeaf","get","undefined","push","dirtyElementKey","intentionallyMarkedAsDirty","dirtyElement","$isRootNode","getDirtyNodes","length","nextNodeMap","nextAnchorNode","anchor","key","prevAnchorNode","has","__key","$isTextNode","__text","offset","nextDirtyNode","prevDirtyNode","__mode","prevText","nextText","nextAnchor","prevAnchor","type","nextAnchorOffset","prevAnchorOffset","textDiff","createMergeActionGetter","editor","delay","prevChangeTime","Date","now","prevChangeType","currentHistoryEntry","tags","changeTime","changeType","mergeAction","isSameEditor","shouldPushHistory","selection","prevNode","nextNode","focus","__parent","JSON","stringify","read","exportJSON","isTextNodeUnchanged","Array","from","clearHistory","historyState","undoStack","redoStack","current","registerHistory","getMergeAction","unregister","mergeRegister","registerCommand","UNDO_COMMAND","historyStateEntry","pop","dispatchCommand","CAN_REDO_COMMAND","CAN_UNDO_COMMAND","setEditorState","tag","undo","COMMAND_PRIORITY_EDITOR","REDO_COMMAND","redo","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","registerUpdateListener","currentEditorState","createEmptyHistoryState"],"mappings":"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"}