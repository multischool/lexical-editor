{"version":3,"file":"index.js","sources":["../../../../node_modules/fractional-indexing/src/index.js"],"sourcesContent":["// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_62_DIGITS =\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0];\n  if (b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error(\"trailing zero\");\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a[n] || zero) === b[n]) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0;\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return digits[midDigit];\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error(\"invalid integer part of order key: \" + int);\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= \"a\" && head <= \"z\") {\n    return head.charCodeAt(0) - \"a\".charCodeAt(0) + 2;\n  } else if (head >= \"A\" && head <= \"Z\") {\n    return \"Z\".charCodeAt(0) - head.charCodeAt(0) + 2;\n  } else {\n    throw new Error(\"invalid order key head: \" + head);\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0]);\n  if (integerPartLength > key.length) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  return key.slice(0, integerPartLength);\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === \"A\" + digits[0].repeat(26)) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key);\n  const f = key.slice(i.length);\n  if (f.slice(-1) === digits[0]) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let carry = true;\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1;\n    if (d === digits.length) {\n      digs[i] = digits[0];\n    } else {\n      digs[i] = digits[d];\n      carry = false;\n    }\n  }\n  if (carry) {\n    if (head === \"Z\") {\n      return \"a\" + digits[0];\n    }\n    if (head === \"z\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\n    if (h > \"a\") {\n      digs.push(digits[0]);\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let borrow = true;\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1;\n    if (d === -1) {\n      digs[i] = digits.slice(-1);\n    } else {\n      digs[i] = digits[d];\n      borrow = false;\n    }\n  }\n  if (borrow) {\n    if (head === \"a\") {\n      return \"Z\" + digits.slice(-1);\n    }\n    if (head === \"A\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\n    if (h < \"Z\") {\n      digs.push(digits.slice(-1));\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits);\n  }\n  if (b != null) {\n    validateOrderKey(b, digits);\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a == null) {\n    if (b == null) {\n      return \"a\" + digits[0];\n    }\n\n    const ib = getIntegerPart(b);\n    const fb = b.slice(ib.length);\n    if (ib === \"A\" + digits[0].repeat(26)) {\n      return ib + midpoint(\"\", fb, digits);\n    }\n    if (ib < b) {\n      return ib;\n    }\n    const res = decrementInteger(ib, digits);\n    if (res == null) {\n      throw new Error(\"cannot decrement any more\");\n    }\n    return res;\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a);\n    const fa = a.slice(ia.length);\n    const i = incrementInteger(ia, digits);\n    return i == null ? ia + midpoint(fa, null, digits) : i;\n  }\n\n  const ia = getIntegerPart(a);\n  const fa = a.slice(ia.length);\n  const ib = getIntegerPart(b);\n  const fb = b.slice(ib.length);\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits);\n  }\n  const i = incrementInteger(ia, digits);\n  if (i == null) {\n    throw new Error(\"cannot increment any more\");\n  }\n  if (i < b) {\n    return i;\n  }\n  return ia + midpoint(fa, null, digits);\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)];\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits);\n      result.push(c);\n    }\n    return result;\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits);\n      result.push(c);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const c = generateKeyBetween(a, b, digits);\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ];\n}\n"],"names":["BASE_62_DIGITS","midpoint","a","b","digits","zero","Error","slice","n","digitA","indexOf","digitB","length","Math","round","validateInteger","int","getIntegerLength","head","charCodeAt","getIntegerPart","key","integerPartLength","validateOrderKey","repeat","i","incrementInteger","x","digs","split","carry","d","h","String","fromCharCode","push","pop","join","generateKeyBetween","ib","fb","res","borrow","decrementInteger","ia","fa","generateNKeysBetween","c","result","reverse","mid","floor"],"mappings":"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"}