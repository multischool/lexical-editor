import{evaluate as e,getPaddingObject as t,getAlignmentAxis as n,min as i,clamp as r,getAlignment as o,placements as a,getAlignmentSides as l,getSide as s,getSideAxis as f,getOppositePlacement as c,getExpandedPlacements as m,getOppositeAxisPlacements as u,rectToClientRect as d,max as g,getAxisLength as p,getOppositeAlignmentPlacement as h,sides as y,getOppositeAxis as w}from"../../utils/dist/floating-ui.utils.mjs.js";export{rectToClientRect}from"../../utils/dist/floating-ui.utils.mjs.js";function x(e,t,i){let{reference:r,floating:a}=e;const l=f(t),c=n(t),m=p(c),u=s(t),d="y"===l,g=r.x+r.width/2-a.width/2,h=r.y+r.height/2-a.height/2,y=r[m]/2-a[m]/2;let w;switch(u){case"top":w={x:g,y:r.y-a.height};break;case"bottom":w={x:g,y:r.y+r.height};break;case"right":w={x:r.x+r.width,y:h};break;case"left":w={x:r.x-a.width,y:h};break;default:w={x:r.x,y:r.y}}switch(o(t)){case"start":w[c]-=y*(i&&d?-1:1);break;case"end":w[c]+=y*(i&&d?-1:1)}return w}const v=async(e,t,n)=>{const{placement:i="bottom",strategy:r="absolute",middleware:o=[],platform:a}=n,l=o.filter(Boolean),s=await(null==a.isRTL?void 0:a.isRTL(t));let f=await a.getElementRects({reference:e,floating:t,strategy:r}),{x:c,y:m}=x(f,i,s),u=i,d={},g=0;for(let n=0;n<l.length;n++){const{name:o,fn:p}=l[n],{x:h,y:y,data:w,reset:v}=await p({x:c,y:m,initialPlacement:i,placement:u,strategy:r,middlewareData:d,rects:f,platform:a,elements:{reference:e,floating:t}});c=null!=h?h:c,m=null!=y?y:m,d={...d,[o]:{...d[o],...w}},v&&g<=50&&(g++,"object"==typeof v&&(v.placement&&(u=v.placement),v.rects&&(f=!0===v.rects?await a.getElementRects({reference:e,floating:t,strategy:r}):v.rects),({x:c,y:m}=x(f,u,s))),n=-1)}return{x:c,y:m,placement:u,strategy:r,middlewareData:d}};async function b(n,i){var r;void 0===i&&(i={});const{x:o,y:a,platform:l,rects:s,elements:f,strategy:c}=n,{boundary:m="clippingAncestors",rootBoundary:u="viewport",elementContext:g="floating",altBoundary:p=!1,padding:h=0}=e(i,n),y=t(h),w=f[p?"floating"===g?"reference":"floating":g],x=d(await l.getClippingRect({element:null==(r=await(null==l.isElement?void 0:l.isElement(w)))||r?w:w.contextElement||await(null==l.getDocumentElement?void 0:l.getDocumentElement(f.floating)),boundary:m,rootBoundary:u,strategy:c})),v="floating"===g?{x:o,y:a,width:s.floating.width,height:s.floating.height}:s.reference,b=await(null==l.getOffsetParent?void 0:l.getOffsetParent(f.floating)),A=await(null==l.isElement?void 0:l.isElement(b))&&await(null==l.getScale?void 0:l.getScale(b))||{x:1,y:1},R=d(l.convertOffsetParentRelativeRectToViewportRelativeRect?await l.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:v,offsetParent:b,strategy:c}):v);return{top:(x.top-R.top+y.top)/A.y,bottom:(R.bottom-x.bottom+y.bottom)/A.y,left:(x.left-R.left+y.left)/A.x,right:(R.right-x.right+y.right)/A.x}}const A=a=>({name:"arrow",options:a,async fn(l){const{x:s,y:f,placement:c,rects:m,platform:u,elements:d,middlewareData:g}=l,{element:h,padding:y=0}=e(a,l)||{};if(null==h)return{};const w=t(y),x={x:s,y:f},v=n(c),b=p(v),A=await u.getDimensions(h),R="y"===v,D=R?"top":"left",P=R?"bottom":"right",T=R?"clientHeight":"clientWidth",E=m.reference[b]+m.reference[v]-x[v]-m.floating[b],O=x[v]-m.reference[v],L=await(null==u.getOffsetParent?void 0:u.getOffsetParent(h));let k=L?L[T]:0;k&&await(null==u.isElement?void 0:u.isElement(L))||(k=d.floating[T]||m.floating[b]);const C=E/2-O/2,B=k/2-A[b]/2-1,H=i(w[D],B),j=i(w[P],B),S=H,F=k-A[b]-j,V=k/2-A[b]/2+C,W=r(S,V,F),z=!g.arrow&&null!=o(c)&&V!==W&&m.reference[b]/2-(V<S?H:j)-A[b]/2<0,q=z?V<S?V-S:V-F:0;return{[v]:x[v]+q,data:{[v]:W,centerOffset:V-W-q,...z&&{alignmentOffset:q}},reset:z}}});const R=function(t){return void 0===t&&(t={}),{name:"autoPlacement",options:t,async fn(n){var i,r,f;const{rects:c,middlewareData:m,placement:u,platform:d,elements:g}=n,{crossAxis:p=!1,alignment:y,allowedPlacements:w=a,autoAlignment:x=!0,...v}=e(t,n),A=void 0!==y||w===a?function(e,t,n){return(e?[...n.filter((t=>o(t)===e)),...n.filter((t=>o(t)!==e))]:n.filter((e=>s(e)===e))).filter((n=>!e||o(n)===e||!!t&&h(n)!==n))}(y||null,x,w):w,R=await b(n,v),D=(null==(i=m.autoPlacement)?void 0:i.index)||0,P=A[D];if(null==P)return{};const T=l(P,c,await(null==d.isRTL?void 0:d.isRTL(g.floating)));if(u!==P)return{reset:{placement:A[0]}};const E=[R[s(P)],R[T[0]],R[T[1]]],O=[...(null==(r=m.autoPlacement)?void 0:r.overflows)||[],{placement:P,overflows:E}],L=A[D+1];if(L)return{data:{index:D+1,overflows:O},reset:{placement:L}};const k=O.map((e=>{const t=o(e.placement);return[e.placement,t&&p?e.overflows.slice(0,2).reduce(((e,t)=>e+t),0):e.overflows[0],e.overflows]})).sort(((e,t)=>e[1]-t[1])),C=(null==(f=k.filter((e=>e[2].slice(0,o(e[0])?2:3).every((e=>e<=0))))[0])?void 0:f[0])||k[0][0];return C!==u?{data:{index:D+1,overflows:O},reset:{placement:C}}:{}}}},D=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(n){var i,r;const{placement:o,middlewareData:a,rects:d,initialPlacement:g,platform:p,elements:h}=n,{mainAxis:y=!0,crossAxis:w=!0,fallbackPlacements:x,fallbackStrategy:v="bestFit",fallbackAxisSideDirection:A="none",flipAlignment:R=!0,...D}=e(t,n);if(null!=(i=a.arrow)&&i.alignmentOffset)return{};const P=s(o),T=f(g),E=s(g)===g,O=await(null==p.isRTL?void 0:p.isRTL(h.floating)),L=x||(E||!R?[c(g)]:m(g)),k="none"!==A;!x&&k&&L.push(...u(g,R,A,O));const C=[g,...L],B=await b(n,D),H=[];let j=(null==(r=a.flip)?void 0:r.overflows)||[];if(y&&H.push(B[P]),w){const e=l(o,d,O);H.push(B[e[0]],B[e[1]])}if(j=[...j,{placement:o,overflows:H}],!H.every((e=>e<=0))){var S,F;const e=((null==(S=a.flip)?void 0:S.index)||0)+1,t=C[e];if(t)return{data:{index:e,overflows:j},reset:{placement:t}};let n=null==(F=j.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:F.placement;if(!n)switch(v){case"bestFit":{var V;const e=null==(V=j.filter((e=>{if(k){const t=f(e.placement);return t===T||"y"===t}return!0})).map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:V[0];e&&(n=e);break}case"initialPlacement":n=g}if(o!==n)return{reset:{placement:n}}}return{}}}};function P(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function T(e){return y.some((t=>e[t]>=0))}const E=function(t){return void 0===t&&(t={}),{name:"hide",options:t,async fn(n){const{rects:i}=n,{strategy:r="referenceHidden",...o}=e(t,n);switch(r){case"referenceHidden":{const e=P(await b(n,{...o,elementContext:"reference"}),i.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:T(e)}}}case"escaped":{const e=P(await b(n,{...o,altBoundary:!0}),i.floating);return{data:{escapedOffsets:e,escaped:T(e)}}}default:return{}}}}};function O(e){const t=i(...e.map((e=>e.left))),n=i(...e.map((e=>e.top)));return{x:t,y:n,width:g(...e.map((e=>e.right)))-t,height:g(...e.map((e=>e.bottom)))-n}}const L=function(n){return void 0===n&&(n={}),{name:"inline",options:n,async fn(r){const{placement:o,elements:a,rects:l,platform:c,strategy:m}=r,{padding:u=2,x:p,y:h}=e(n,r),y=Array.from(await(null==c.getClientRects?void 0:c.getClientRects(a.reference))||[]),w=function(e){const t=e.slice().sort(((e,t)=>e.y-t.y)),n=[];let i=null;for(let e=0;e<t.length;e++){const r=t[e];!i||r.y-i.y>i.height/2?n.push([r]):n[n.length-1].push(r),i=r}return n.map((e=>d(O(e))))}(y),x=d(O(y)),v=t(u);const b=await c.getElementRects({reference:{getBoundingClientRect:function(){if(2===w.length&&w[0].left>w[1].right&&null!=p&&null!=h)return w.find((e=>p>e.left-v.left&&p<e.right+v.right&&h>e.top-v.top&&h<e.bottom+v.bottom))||x;if(w.length>=2){if("y"===f(o)){const e=w[0],t=w[w.length-1],n="top"===s(o),i=e.top,r=t.bottom,a=n?e.left:t.left,l=n?e.right:t.right;return{top:i,bottom:r,left:a,right:l,width:l-a,height:r-i,x:a,y:i}}const e="left"===s(o),t=g(...w.map((e=>e.right))),n=i(...w.map((e=>e.left))),r=w.filter((i=>e?i.left===n:i.right===t)),a=r[0].top,l=r[r.length-1].bottom;return{top:a,bottom:l,left:n,right:t,width:t-n,height:l-a,x:n,y:a}}return x}},floating:a.floating,strategy:m});return l.reference.x!==b.reference.x||l.reference.y!==b.reference.y||l.reference.width!==b.reference.width||l.reference.height!==b.reference.height?{reset:{rects:b}}:{}}}};const k=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(n){var i,r;const{x:a,y:l,placement:c,middlewareData:m}=n,u=await async function(t,n){const{placement:i,platform:r,elements:a}=t,l=await(null==r.isRTL?void 0:r.isRTL(a.floating)),c=s(i),m=o(i),u="y"===f(i),d=["left","top"].includes(c)?-1:1,g=l&&u?-1:1,p=e(n,t);let{mainAxis:h,crossAxis:y,alignmentAxis:w}="number"==typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:p.mainAxis||0,crossAxis:p.crossAxis||0,alignmentAxis:p.alignmentAxis};return m&&"number"==typeof w&&(y="end"===m?-1*w:w),u?{x:y*g,y:h*d}:{x:h*d,y:y*g}}(n,t);return c===(null==(i=m.offset)?void 0:i.placement)&&null!=(r=m.arrow)&&r.alignmentOffset?{}:{x:a+u.x,y:l+u.y,data:{...u,placement:c}}}}},C=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(n){const{x:i,y:o,placement:a}=n,{mainAxis:l=!0,crossAxis:c=!1,limiter:m={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...u}=e(t,n),d={x:i,y:o},g=await b(n,u),p=f(s(a)),h=w(p);let y=d[h],x=d[p];if(l){const e="y"===h?"bottom":"right",t=y+g["y"===h?"top":"left"],n=y-g[e];y=r(t,y,n)}if(c){const e="y"===p?"bottom":"right",t=x+g["y"===p?"top":"left"],n=x-g[e];x=r(t,x,n)}const v=m.fn({...n,[h]:y,[p]:x});return{...v,data:{x:v.x-i,y:v.y-o,enabled:{[h]:l,[p]:c}}}}}},B=function(t){return void 0===t&&(t={}),{options:t,fn(n){const{x:i,y:r,placement:o,rects:a,middlewareData:l}=n,{offset:c=0,mainAxis:m=!0,crossAxis:u=!0}=e(t,n),d={x:i,y:r},g=f(o),p=w(g);let h=d[p],y=d[g];const x=e(c,n),v="number"==typeof x?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const e="y"===p?"height":"width",t=a.reference[p]-a.floating[e]+v.mainAxis,n=a.reference[p]+a.reference[e]-v.mainAxis;h<t?h=t:h>n&&(h=n)}if(u){var b,A;const e="y"===p?"width":"height",t=["top","left"].includes(s(o)),n=a.reference[g]-a.floating[e]+(t&&(null==(b=l.offset)?void 0:b[g])||0)+(t?0:v.crossAxis),i=a.reference[g]+a.reference[e]+(t?0:(null==(A=l.offset)?void 0:A[g])||0)-(t?v.crossAxis:0);y<n?y=n:y>i&&(y=i)}return{[p]:h,[g]:y}}}},H=function(t){return void 0===t&&(t={}),{name:"size",options:t,async fn(n){var r,a;const{placement:l,rects:c,platform:m,elements:u}=n,{apply:d=()=>{},...p}=e(t,n),h=await b(n,p),y=s(l),w=o(l),x="y"===f(l),{width:v,height:A}=c.floating;let R,D;"top"===y||"bottom"===y?(R=y,D=w===(await(null==m.isRTL?void 0:m.isRTL(u.floating))?"start":"end")?"left":"right"):(D=y,R="end"===w?"top":"bottom");const P=A-h.top-h.bottom,T=v-h.left-h.right,E=i(A-h[R],P),O=i(v-h[D],T),L=!n.middlewareData.shift;let k=E,C=O;if(null!=(r=n.middlewareData.shift)&&r.enabled.x&&(C=T),null!=(a=n.middlewareData.shift)&&a.enabled.y&&(k=P),L&&!w){const e=g(h.left,0),t=g(h.right,0),n=g(h.top,0),i=g(h.bottom,0);x?C=v-2*(0!==e||0!==t?e+t:g(h.left,h.right)):k=A-2*(0!==n||0!==i?n+i:g(h.top,h.bottom))}await d({...n,availableWidth:C,availableHeight:k});const B=await m.getDimensions(u.floating);return v!==B.width||A!==B.height?{reset:{rects:!0}}:{}}}};export{A as arrow,R as autoPlacement,v as computePosition,b as detectOverflow,D as flip,E as hide,L as inline,B as limitShift,k as offset,C as shift,H as size};
//# sourceMappingURL=floating-ui.core.mjs.js.map
