{"version":3,"file":"parser.js","sources":["../../../../node_modules/path-data-parser/lib/parser.js"],"sourcesContent":["const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n"],"names":["PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","isType","token","type","parsePath","d","segments","tokens","Array","match","substr","RegExp","$1","length","text","parseFloat","tokenize","mode","index","paramsCount","params","Error","i","numbeToken","segment","key","data","push"],"mappings":"AAAA,MAGMA,EAAS,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAsBtI,SAASC,EAAOC,EAAOC,GACnB,OAAOD,EAAMC,OAASA,CAC1B,CACO,SAASC,EAAUC,GACtB,MAAMC,EAAW,GACXC,EA1BV,SAAkBF,GACd,MAAME,EAAS,IAAIC,MACnB,KAAa,KAANH,GACH,GAAIA,EAAEI,MAAM,kBACRJ,EAAIA,EAAEK,OAAOC,OAAOC,GAAGC,aAEtB,GAAIR,EAAEI,MAAM,6BACbF,EAAOA,EAAOM,QAAU,CAAEV,KAXtB,EAWqCW,KAAMH,OAAOC,IACtDP,EAAIA,EAAEK,OAAOC,OAAOC,GAAGC,YAEtB,KAAIR,EAAEI,MAAM,+DAKb,MAAO,GAJPF,EAAOA,EAAOM,QAAU,CAAEV,KAdvB,EAcqCW,KAAM,GAAGC,WAAWJ,OAAOC,OACnEP,EAAIA,EAAEK,OAAOC,OAAOC,GAAGC,OAI1B,CAGL,OADAN,EAAOA,EAAOM,QAAU,CAAEV,KApBlB,EAoB6BW,KAAM,IACpCP,CACX,CAMmBS,CAASX,GACxB,IAAIY,EAAO,MACPC,EAAQ,EACRhB,EAAQK,EAAOW,GACnB,MAAQjB,EAAOC,EAhCP,IAgCoB,CACxB,IAAIiB,EAAc,EAClB,MAAMC,EAAS,GACf,GAAa,QAATH,EAAgB,CAChB,GAAmB,MAAff,EAAMY,MAA+B,MAAfZ,EAAMY,KAM5B,OAAOV,EAAU,OAASC,GAL1Ba,IACAC,EAAcvC,EAAOsB,EAAMY,MAC3BG,EAAOf,EAAMY,IAKpB,MACQb,EAAOC,EA9CT,GA+CHiB,EAAcvC,EAAOqC,IAGrBC,IACAC,EAAcvC,EAAOsB,EAAMY,MAC3BG,EAAOf,EAAMY,MAEjB,KAAKI,EAAQC,EAAeZ,EAAOM,QAyB/B,MAAM,IAAIQ,MAAM,yBAxBhB,IAAK,IAAIC,EAAIJ,EAAOI,EAAIJ,EAAQC,EAAaG,IAAK,CAC9C,MAAMC,EAAahB,EAAOe,GAC1B,IAAIrB,EAAOsB,EAzDZ,GA6DK,MAAM,IAAIF,MAAM,uBAAyBJ,EAAO,IAAMM,EAAWT,MAHjEM,EAAOA,EAAOP,SAAWU,EAAWT,IAK3C,CACD,GAA4B,iBAAjBlC,EAAOqC,GAWd,MAAM,IAAII,MAAM,gBAAkBJ,GAXA,CAClC,MAAMO,EAAU,CAAEC,IAAKR,EAAMS,KAAMN,GACnCd,EAASqB,KAAKH,GACdN,GAASC,EACTjB,EAAQK,EAAOW,GACF,MAATD,IACAA,EAAO,KACE,MAATA,IACAA,EAAO,IACd,CAQR,CACD,OAAOX,CACX"}