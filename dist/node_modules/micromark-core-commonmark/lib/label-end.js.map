{"version":3,"file":"label-end.js","sources":["../../../../node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n"],"names":["labelEnd","name","tokenize","effects","ok","nok","self","this","labelStart","defined","index","events","length","type","_balanced","code","_inactive","labelEndNok","parser","includes","normalizeIdentifier","sliceSerialize","start","end","now","enter","consume","exit","after","attempt","resourceConstruct","labelEndOk","referenceFullConstruct","referenceNotFull","referenceCollapsedConstruct","resolveTo","context","token","open","close","media","offset","group","Object","assign","label","text","push","slice","resolveAll","constructs","insideSpan","null","splice","resourceBefore","markdownLineEndingOrSpace","factoryWhitespace","resourceOpen","resourceEnd","factoryDestination","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","factoryTitle","resourceTitleAfter","factoryLabel","call","referenceFullAfter","referenceFullMissing","referenceCollapsedOpen"],"mappings":"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"}