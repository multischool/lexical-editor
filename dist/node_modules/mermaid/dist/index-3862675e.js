import{Graph as e}from"../../dagre-d3-es/src/graphlib/graph.js";import{layout as t}from"../../dagre-d3-es/src/dagre/layout.js";import"../../dagre-d3-es/src/dagre/rank/network-simplex.js";import{write as n}from"../../dagre-d3-es/src/graphlib/json.js";import{a as r,u as i,s as a,e as s,f as d,g as o,p as c,h as l,j as h,b as g,d as f,c as u,i as w}from"./edges-e0da2a9e.js";import{l as p,c as m,m as y}from"./mermaid-b5860b54.js";import{a as x}from"./createText-2e5e7dd3.js";import"../../d3-transition/src/selection/index.js";import"../../d3-zoom/src/transform.js";import v from"../../d3-selection/src/select.js";let b={},E={},N={};const X=(e,t)=>(p.trace("In isDescendant",t," ",e," = ",E[t].includes(e)),!!E[t].includes(e)),C=(e,t,n,r)=>{p.warn("Copying children of ",e,"root",r,"data",t.node(e),r);const i=t.children(e)||[];e!==r&&i.push(e),p.warn("Copying (nodes) clusterId",e,"nodes",i),i.forEach((i=>{if(t.children(i).length>0)C(i,t,n,r);else{const a=t.node(i);p.info("cp ",i," to ",r," with parent ",e),n.setNode(i,a),r!==t.parent(i)&&(p.warn("Setting parent",i,t.parent(i)),n.setParent(i,t.parent(i))),e!==r&&i!==e?(p.debug("Setting parent",i,e),n.setParent(i,e)):(p.info("In copy ",e,"root",r,"data",t.node(e),r),p.debug("Not Setting parent for node=",i,"cluster!==rootId",e!==r,"node!==clusterId",i!==e));const s=t.edges(i);p.debug("Copying Edges",s),s.forEach((i=>{p.info("Edge",i);const a=t.edge(i.v,i.w,i.name);p.info("Edge data",a,r);try{((e,t)=>(p.info("Descendants of ",t," is ",E[t]),p.info("Edge is ",e),e.v!==t&&e.w!==t&&(E[t]?E[t].includes(e.v)||X(e.v,t)||X(e.w,t)||E[t].includes(e.w):(p.debug("Tilt, ",t,",not in descendants"),!1))))(i,r)?(p.info("Copying as ",i.v,i.w,a,i.name),n.setEdge(i.v,i.w,a,i.name),p.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):p.info("Skipping copy of edge ",i.v,"--\x3e",i.w," rootId: ",r," clusterId:",e)}catch(e){p.error(e)}}))}p.debug("Removing node",i),t.removeNode(i)}))},S=(e,t)=>{const n=t.children(e);let r=[...n];for(const i of n)N[i]=e,r=[...r,...S(i,t)];return r},T=(e,t)=>{p.trace("Searching",e);const n=t.children(e);if(p.trace("Searching children of id ",e,n),n.length<1)return p.trace("This is a valid node",e),e;for(const r of n){const n=T(r,t);if(n)return p.trace("Found replacement for",e," => ",n),n}},B=e=>b[e]&&b[e].externalConnections&&b[e]?b[e].id:e,D=(t,r)=>{if(p.warn("extractor - ",r,n(t),t.children("D")),r>10)return void p.error("Bailing out");let i=t.nodes(),a=!1;for(const e of i){const n=t.children(e);a=a||n.length>0}if(a){p.debug("Nodes = ",i,r);for(const a of i)if(p.debug("Extracting node",a,b,b[a]&&!b[a].externalConnections,!t.parent(a),t.node(a),t.children("D")," Depth ",r),b[a])if(!b[a].externalConnections&&t.children(a)&&t.children(a).length>0){p.warn("Cluster without external connections, without a parent and with children",a,r);let i="TB"===t.graph().rankdir?"LR":"TB";b[a]&&b[a].clusterData&&b[a].clusterData.dir&&(i=b[a].clusterData.dir,p.warn("Fixing dir",b[a].clusterData.dir,i));const s=new e({multigraph:!0,compound:!0}).setGraph({rankdir:i,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}}));p.warn("Old graph before copy",n(t)),C(a,t,s,a),t.setNode(a,{clusterNode:!0,id:a,clusterData:b[a].clusterData,labelText:b[a].labelText,graph:s}),p.warn("New graph after copy node: (",a,")",n(s)),p.debug("Old graph after copy",n(t))}else p.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!b[a].externalConnections," no parent: ",!t.parent(a)," children ",t.children(a)&&t.children(a).length>0,t.children("D"),r),p.debug(b);else p.debug("Not a cluster",a,r);i=t.nodes(),p.warn("New list of nodes",i);for(const e of i){const n=t.node(e);p.warn(" Now next level",e,n),n.clusterNode&&D(n.graph,r+1)}}else p.debug("Done, no node has children",t.nodes())},O=(e,t)=>{if(0===t.length)return[];let n=Object.assign(t);return t.forEach((t=>{const r=e.children(t),i=O(e,r);n=[...n,...i]})),n},j={rect:(e,t)=>{p.info("Creating subgraph rect for ",t.id,t);const n=m(),r=e.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),i=r.insert("rect",":first-child"),a=y(n.flowchart.htmlLabels),s=r.insert("g").attr("class","cluster-label"),d="markdown"===t.labelType?x(s,t.labelText,{style:t.labelStyle,useHtmlLabels:a}):s.node().appendChild(u(t.labelText,t.labelStyle,void 0,!0));let c=d.getBBox();if(y(n.flowchart.htmlLabels)){const e=d.children[0],t=v(d);c=e.getBoundingClientRect(),t.attr("width",c.width),t.attr("height",c.height)}const l=0*t.padding,h=l/2,g=t.width<=c.width+l?c.width+l:t.width;t.width<=c.width+l?t.diff=(c.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,p.trace("Data ",t,JSON.stringify(t)),i.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-g/2).attr("y",t.y-t.height/2-h).attr("width",g).attr("height",t.height+l);const{subGraphTitleTopMargin:f}=o(n);a?s.attr("transform",`translate(${t.x-c.width/2}, ${t.y-t.height/2+f})`):s.attr("transform",`translate(${t.x}, ${t.y-t.height/2+f})`);const b=i.node().getBBox();return t.width=b.width,t.height=b.height,t.intersect=function(e){return w(t,e)},r},roundedWithTitle:(e,t)=>{const n=m(),r=e.insert("g").attr("class",t.classes).attr("id",t.id),i=r.insert("rect",":first-child"),a=r.insert("g").attr("class","cluster-label"),s=r.append("rect"),d=a.node().appendChild(u(t.labelText,t.labelStyle,void 0,!0));let c=d.getBBox();if(y(n.flowchart.htmlLabels)){const e=d.children[0],t=v(d);c=e.getBoundingClientRect(),t.attr("width",c.width),t.attr("height",c.height)}c=d.getBBox();const l=0*t.padding,h=l/2,g=t.width<=c.width+t.padding?c.width+t.padding:t.width;t.width<=c.width+t.padding?t.diff=(c.width+0*t.padding-t.width)/2:t.diff=-t.padding/2,i.attr("class","outer").attr("x",t.x-g/2-h).attr("y",t.y-t.height/2-h).attr("width",g+l).attr("height",t.height+l),s.attr("class","inner").attr("x",t.x-g/2-h).attr("y",t.y-t.height/2-h+c.height-1).attr("width",g+l).attr("height",t.height+l-c.height-3);const{subGraphTitleTopMargin:f}=o(n);a.attr("transform",`translate(${t.x-c.width/2}, ${t.y-t.height/2-t.padding/3+(y(n.flowchart.htmlLabels)?5:3)+f})`);const p=i.node().getBBox();return t.height=p.height,t.intersect=function(e){return w(t,e)},r},noteGroup:(e,t)=>{const n=e.insert("g").attr("class","note-cluster").attr("id",t.id),r=n.insert("rect",":first-child"),i=0*t.padding,a=i/2;r.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2-a).attr("width",t.width+i).attr("height",t.height+i).attr("fill","none");const s=r.node().getBBox();return t.width=s.width,t.height=s.height,t.intersect=function(e){return w(t,e)},n},divider:(e,t)=>{const n=e.insert("g").attr("class",t.classes).attr("id",t.id),r=n.insert("rect",":first-child"),i=0*t.padding,a=i/2;r.attr("class","divider").attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2).attr("width",t.width+i).attr("height",t.height+i);const s=r.node().getBBox();return t.width=s.width,t.height=s.height,t.diff=-t.padding/2,t.intersect=function(e){return w(t,e)},n}};let J={};const G=async(e,r,g,f,u,w)=>{p.info("Graph in recursive render: XXX",n(r),u);const m=r.graph().rankdir;p.trace("Dir in recursive render - dir:",m);const y=e.insert("g").attr("class","root");r.nodes()?p.info("Recursive render XXX",r.nodes()):p.info("No nodes found for",r),r.edges().length>0&&p.trace("Recursive edges",r.edge(r.edges()[0]));const x=y.insert("g").attr("class","clusters"),v=y.insert("g").attr("class","edgePaths"),E=y.insert("g").attr("class","edgeLabels"),N=y.insert("g").attr("class","nodes");await Promise.all(r.nodes().map((async function(e){const t=r.node(e);if(void 0!==u){const t=JSON.parse(JSON.stringify(u.clusterData));p.info("Setting data for cluster XXX (",e,") ",t,u),r.setNode(u.id,t),r.parent(e)||(p.trace("Setting parent",e,u.id),r.setParent(e,u.id,t))}if(p.info("(Insert) Node XXX"+e+": "+JSON.stringify(r.node(e))),t&&t.clusterNode){p.info("Cluster identified",e,t.width,r.node(e));const n=await G(N,t.graph,g,f,r.node(e),w),s=n.elem;i(t,s),t.diff=n.diff||0,p.info("Node bounds (abc123)",e,t,t.width,t.x,t.y),a(s,t),p.warn("Recursive render complete ",s,t)}else r.children(e).length>0?(p.info("Cluster - the non recursive path XXX",e,t.id,t,r),p.info(T(t.id,r)),b[t.id]={id:T(t.id,r),node:t}):(p.info("Node - the non recursive path",e,t.id,t),await s(N,r.node(e),m))}))),r.edges().forEach((function(e){const t=r.edge(e.v,e.w,e.name);p.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),p.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(r.edge(e))),p.info("Fix",b,"ids:",e.v,e.w,"Translating: ",b[e.v],b[e.w]),d(E,t)})),r.edges().forEach((function(e){p.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e))})),p.info("#############################################"),p.info("###                Layout                 ###"),p.info("#############################################"),p.info(r),t(r),p.info("Graph after layout:",n(r));let X=0;const{subGraphTitleTotalMargin:C}=o(w);return(e=>O(e,e.children()))(r).forEach((function(e){const t=r.node(e);p.info("Position "+e+": "+JSON.stringify(r.node(e))),p.info("Position "+e+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t&&t.clusterNode?(t.y+=C,c(t)):r.children(e).length>0?(t.height+=C,((e,t)=>{p.trace("Inserting cluster");const n=t.shape||"rect";J[t.id]=j[n](e,t)})(x,t),b[t.id].node=t):(t.y+=C/2,c(t))})),r.edges().forEach((function(e){const t=r.edge(e);p.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(t),t),t.points.forEach((e=>e.y+=C/2));const n=l(v,e,t,b,g,r,f);h(t,n)})),r.nodes().forEach((function(e){const t=r.node(e);p.info(e,t.type,t.diff),"group"===t.type&&(X=t.diff)})),{elem:y,diff:X}},k=async(e,t,i,a,s)=>{r(e,i,a,s),g(),f(),J={},E={},N={},b={},p.warn("Graph at first:",JSON.stringify(n(t))),((e,t)=>{if(!e||t>10)p.debug("Opting out, no graph ");else{p.debug("Opting in, graph "),e.nodes().forEach((function(t){e.children(t).length>0&&(p.warn("Cluster identified",t," Replacement id in edges: ",T(t,e)),E[t]=S(t,e),b[t]={id:T(t,e),clusterData:e.node(t)})})),e.nodes().forEach((function(t){const n=e.children(t),r=e.edges();n.length>0?(p.debug("Cluster identified",t,E),r.forEach((e=>{e.v!==t&&e.w!==t&&X(e.v,t)^X(e.w,t)&&(p.warn("Edge: ",e," leaves cluster ",t),p.warn("Descendants of XXX ",t,": ",E[t]),b[t].externalConnections=!0)}))):p.debug("Not a cluster ",t,E)}));for(let t of Object.keys(b)){const n=b[t].id,r=e.parent(n);r!==t&&b[r]&&!b[r].externalConnections&&(b[t].id=r)}e.edges().forEach((function(t){const n=e.edge(t);p.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),p.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let r=t.v,i=t.w;if(p.warn("Fix XXX",b,"ids:",t.v,t.w,"Translating: ",b[t.v]," --- ",b[t.w]),b[t.v]&&b[t.w]&&b[t.v]===b[t.w]){p.warn("Fixing and trixing link to self - removing XXX",t.v,t.w,t.name),p.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),r=B(t.v),i=B(t.w),e.removeEdge(t.v,t.w,t.name);const a=t.w+"---"+t.v;e.setNode(a,{domId:a,id:a,labelStyle:"",labelText:n.label,padding:0,shape:"labelRect",style:""});const s=structuredClone(n),d=structuredClone(n);s.label="",s.arrowTypeEnd="none",d.label="",s.fromCluster=t.v,d.toCluster=t.v,e.setEdge(r,a,s,t.name+"-cyclic-special"),e.setEdge(a,i,d,t.name+"-cyclic-special")}else if(b[t.v]||b[t.w]){if(p.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),r=B(t.v),i=B(t.w),e.removeEdge(t.v,t.w,t.name),r!==t.v){const i=e.parent(r);b[i].externalConnections=!0,n.fromCluster=t.v}if(i!==t.w){const r=e.parent(i);b[r].externalConnections=!0,n.toCluster=t.w}p.warn("Fix Replacing with XXX",r,i,t.name),e.setEdge(r,i,n,t.name)}})),p.warn("Adjusted Graph",n(e)),D(e,0),p.trace(b)}})(t),p.warn("Graph after:",JSON.stringify(n(t)));const d=m();await G(e,t,a,s,void 0,d)};export{k as r};
//# sourceMappingURL=index-3862675e.js.map
