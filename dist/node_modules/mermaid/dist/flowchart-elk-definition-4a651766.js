import{d as e,p as t}from"./flowDb-956e92f1.js";import"../../d3-transition/src/selection/index.js";import"../../d3-zoom/src/transform.js";import{a as o,e as n,l as r,f as a,k as i,m as l}from"./edges-e0da2a9e.js";import{l as s,F as d,o as c,k as h,n as p,e as u}from"./mermaid-b5860b54.js";import b from"../../elkjs/lib/elk.bundled.js";import"../../dayjs/dayjs.min.js";import"../../@braintree/sanitize-url/dist/index.js";import"../../dompurify/dist/purify.es.mjs.js";import y from"../../d3-selection/src/select.js";import g from"../../d3-shape/src/curve/linear.js";import f from"../../d3-shape/src/line.js";const w=new b;let k={};const x={};let m={};const v=(e,t,o)=>{const n={TB:{in:{north:"north"},out:{south:"west",west:"east",east:"south"}},LR:{in:{west:"west"},out:{east:"south",south:"north",north:"east"}},RL:{in:{east:"east"},out:{west:"north",north:"south",south:"west"}},BT:{in:{south:"south"},out:{north:"east",east:"west",west:"north"}}};return n.TD=n.TB,n[o][t][e]},T=(e,t,o)=>{if(s.info("getNextPort",{node:e,edgeDirection:t,graphDirection:o}),!k[e])switch(o){case"TB":case"TD":k[e]={inPosition:"north",outPosition:"south"};break;case"BT":k[e]={inPosition:"south",outPosition:"north"};break;case"RL":k[e]={inPosition:"east",outPosition:"west"};break;case"LR":k[e]={inPosition:"west",outPosition:"east"}}const n="in"===t?k[e].inPosition:k[e].outPosition;return"in"===t?k[e].inPosition=v(k[e].inPosition,t,o):k[e].outPosition=v(k[e].outPosition,t,o),n},$=function(e,t,o,n){s.info("abc78 edges = ",e);const r=n.insert("g").attr("class","edgeLabels");let i,l,d={},c=t.db.getDirection();if(void 0!==e.defaultStyle){const t=h(e.defaultStyle);i=t.style,l=t.labelStyle}return e.forEach((function(t){const n="L-"+t.start+"-"+t.end;void 0===d[n]?(d[n]=0,s.info("abc78 new entry",n,d[n])):(d[n]++,s.info("abc78 new entry",n,d[n]));let b=n+"-"+d[n];s.info("abc78 new link id to be used is",n,b,d[n]);const y="LS-"+t.start,f="LE-"+t.end,w={style:"",labelStyle:""};switch(w.minlen=t.length||1,"arrow_open"===t.type?w.arrowhead="none":w.arrowhead="normal",w.arrowTypeStart="arrow_open",w.arrowTypeEnd="arrow_open",t.type){case"double_arrow_cross":w.arrowTypeStart="arrow_cross";case"arrow_cross":w.arrowTypeEnd="arrow_cross";break;case"double_arrow_point":w.arrowTypeStart="arrow_point";case"arrow_point":w.arrowTypeEnd="arrow_point";break;case"double_arrow_circle":w.arrowTypeStart="arrow_circle";case"arrow_circle":w.arrowTypeEnd="arrow_circle"}let k="",v="";switch(t.stroke){case"normal":k="fill:none;",void 0!==i&&(k=i),void 0!==l&&(v=l),w.thickness="normal",w.pattern="solid";break;case"dotted":w.thickness="normal",w.pattern="dotted",w.style="fill:none;stroke-width:2px;stroke-dasharray:3;";break;case"thick":w.thickness="thick",w.pattern="solid",w.style="stroke-width: 3.5px;fill:none;"}if(void 0!==t.style){const e=h(t.style);k=e.style,v=e.labelStyle}w.style=w.style+=k,w.labelStyle=w.labelStyle+=v,void 0!==t.interpolate?w.curve=p(t.interpolate,g):void 0!==e.defaultInterpolate?w.curve=p(e.defaultInterpolate,g):w.curve=p(x.curve,g),void 0===t.text?void 0!==t.style&&(w.arrowheadStyle="fill: #333"):(w.arrowheadStyle="fill: #333",w.labelpos="c"),w.labelType=t.labelType,w.label=t.text.replace(u.lineBreakRegex,"\n"),void 0===t.style&&(w.style=w.style||"stroke: #333; stroke-width: 1.5px;fill:none;"),w.labelStyle=w.labelStyle.replace("color:","fill:"),w.id=b,w.classes="flowchart-link "+y+" "+f;const $=a(r,w),{source:I,target:_,sourceId:B,targetId:E}=((e,t)=>{let o=e.start,n=e.end;const r=o,a=n,i=m[o],l=m[n];return i&&l?("diamond"===i.type&&(o=`${o}-${T(o,"out",t)}`),"diamond"===l.type&&(n=`${n}-${T(n,"in",t)}`),{source:o,target:n,sourceId:r,targetId:a}):{source:o,target:n}})(t,c);s.debug("abc78 source and target",I,_),o.edges.push({id:"e"+t.start+t.end,sources:[I],targets:[_],sourceId:B,targetId:E,labelEl:$,labels:[{width:w.width,height:w.height,orgWidth:w.width,orgHeight:w.height,text:w.label,layoutOptions:{"edgeLabels.inline":"true","edgeLabels.placement":"CENTER"}}],edgeData:w})})),o},I=function(e,t,o){const n=((e,t,o)=>{const{parentById:n}=o,r=new Set;let a=e;for(;a;){if(r.add(a),a===t)return a;a=n[a]}for(a=t;a;){if(r.has(a))return a;a=n[a]}return"root"})(e,t,o);if(void 0===n||"root"===n)return{x:0,y:0};const r=m[n].offset;return{x:r.posX,y:r.posY}},_=function(e,t,o,n,r,a){const s=I(t.sourceId,t.targetId,r),d=t.sections[0].startPoint,c=t.sections[0].endPoint,h=(t.sections[0].bendPoints?t.sections[0].bendPoints:[]).map((e=>[e.x+s.x,e.y+s.y])),p=[[d.x+s.x,d.y+s.y],...h,[c.x+s.x,c.y+s.y]],{x:u,y:b}=i(t.edgeData),w=f().x(u).y(b).curve(g),k=e.insert("path").attr("d",w(p)).attr("class","path "+o.classes).attr("fill","none"),x=e.insert("g").attr("class","edgeLabel"),m=y(x.node().appendChild(t.labelEl)),v=m.node().firstChild.getBoundingClientRect();m.attr("width",v.width),m.attr("height",v.height),x.attr("transform",`translate(${t.labels[0].x+s.x}, ${t.labels[0].y+s.y})`),function(e,t,o,n,r){let a="";n&&(a=window.location.protocol+"//"+window.location.host+window.location.pathname+window.location.search,a=a.replace(/\(/g,"\\("),a=a.replace(/\)/g,"\\)")),l(e,t,a,r,o)}(k,o,n.type,n.arrowMarkerAbsolute,a)},B=(e,t)=>{e.forEach((e=>{e.children||(e.children=[]);const o=t.childrenById[e.id];o&&o.forEach((t=>{e.children.push(m[t])})),B(e.children,t)}))},E=(e,t,o,n,r,a,i)=>{o.forEach((function(o){if(o)if(m[o.id].offset={posX:o.x+e,posY:o.y+t,x:e,y:t,depth:i,width:o.width,height:o.height},"group"===o.type){const n=r.insert("g").attr("class","subgraph");n.insert("rect").attr("class","subgraph subgraph-lvl-"+i%5+" node").attr("x",o.x+e).attr("y",o.y+t).attr("width",o.width).attr("height",o.height);const a=n.insert("g").attr("class","label"),l=d().flowchart.htmlLabels?o.labelData.width/2:0;a.attr("transform",`translate(${o.labels[0].x+e+o.x+l}, ${o.labels[0].y+t+o.y+3})`),a.node().appendChild(o.labelData.labelNode),s.info("Id (UGH)= ",o.type,o.labels)}else s.info("Id (UGH)= ",o.id),o.el.attr("transform",`translate(${o.x+e+o.width/2}, ${o.y+t+o.height/2})`)})),o.forEach((function(o){o&&"group"===o.type&&E(e+o.x,t+o.y,o.children,n,r,a,i+1)}))},S={db:e,renderer:{getClasses:function(e,t){return s.info("Extracting classes"),t.db.getClasses()},draw:async function(e,t,a,i){var l;i.db.clear(),m={},k={},i.db.setGen("gen-2"),i.parser.parse(e);const p=y("body").append("div").attr("style","height:400px").attr("id","cy");let u={id:"root",layoutOptions:{"elk.hierarchyHandling":"INCLUDE_CHILDREN","org.eclipse.elk.padding":"[top=100, left=100, bottom=110, right=110]","elk.layered.spacing.edgeNodeBetweenLayers":"30","elk.direction":"DOWN"},children:[],edges:[]};switch(s.info("Drawing flowchart using v3 renderer",w),i.db.getDirection()){case"BT":u.layoutOptions["elk.direction"]="UP";break;case"TB":u.layoutOptions["elk.direction"]="DOWN";break;case"LR":u.layoutOptions["elk.direction"]="RIGHT";break;case"RL":u.layoutOptions["elk.direction"]="LEFT"}const{securityLevel:b,flowchart:g}=d();let f;"sandbox"===b&&(f=y("#i"+t));const x=y("sandbox"===b?f.nodes()[0].contentDocument.body:"body"),v="sandbox"===b?f.nodes()[0].contentDocument:document,T=x.select(`[id="${t}"]`);o(T,["point","circle","cross"],i.type,t);const I=i.db.getVertices();let S;const C=i.db.getSubGraphs();s.info("Subgraphs - ",C);for(let e=C.length-1;e>=0;e--)S=C[e],i.db.addVertex(S.id,{text:S.title,type:S.labelType},"group",void 0,S.classes,S.dir);const D=T.insert("g").attr("class","subgraphs"),P=function(e){const t={parentById:{},childrenById:{}},o=e.getSubGraphs();return s.info("Subgraphs - ",o),o.forEach((function(e){e.nodes.forEach((function(o){t.parentById[o]=e.id,void 0===t.childrenById[e.id]&&(t.childrenById[e.id]=[]),t.childrenById[e.id].push(o)}))})),o.forEach((function(e){e.id,void 0!==t.parentById[e.id]&&t.parentById[e.id]})),t}(i.db);u=await async function(e,t,o,a,i,l,s){const c=o.select(`[id="${t}"]`).insert("g").attr("class","nodes"),p=Object.keys(e);return await Promise.all(p.map((async function(t){const o=e[t];let s="default";o.classes.length>0&&(s=o.classes.join(" ")),s+=" flowchart-label";const p=h(o.styles);let u=void 0!==o.text?o.text:o.id;const b={width:0,height:0},y=[{id:o.id+"-west",layoutOptions:{"port.side":"WEST"}},{id:o.id+"-east",layoutOptions:{"port.side":"EAST"}},{id:o.id+"-south",layoutOptions:{"port.side":"SOUTH"}},{id:o.id+"-north",layoutOptions:{"port.side":"NORTH"}}];let g=0,f="",w={};switch(o.type){case"round":g=5,f="rect";break;case"square":case"group":default:f="rect";break;case"diamond":f="question",w={portConstraints:"FIXED_SIDE"};break;case"hexagon":f="hexagon";break;case"odd":case"odd_right":f="rect_left_inv_arrow";break;case"lean_right":f="lean_right";break;case"lean_left":f="lean_left";break;case"trapezoid":f="trapezoid";break;case"inv_trapezoid":f="inv_trapezoid";break;case"circle":f="circle";break;case"ellipse":f="ellipse";break;case"stadium":f="stadium";break;case"subroutine":f="subroutine";break;case"cylinder":f="cylinder";break;case"doublecircle":f="doublecircle"}const k={labelStyle:p.labelStyle,shape:f,labelText:u,labelType:o.labelType,rx:g,ry:g,class:s,style:p.style,id:o.id,link:o.link,linkTarget:o.linkTarget,tooltip:i.db.getTooltip(o.id)||"",domId:i.db.lookUpDomId(o.id),haveCallback:o.haveCallback,width:"group"===o.type?500:void 0,dir:o.dir,type:o.type,props:o.props,padding:d().flowchart.padding};let x,v;if("group"!==k.type)v=await n(c,k,o.dir),x=v.node().getBBox();else{a.createElementNS("http://www.w3.org/2000/svg","text");const{shapeSvg:e,bbox:t}=await r(c,k,void 0,!0);b.width=t.width,b.wrappingWidth=d().flowchart.wrappingWidth,b.height=t.height,b.labelNode=e.node(),k.labelData=b}const T={id:o.id,ports:"diamond"===o.type?y:[],layoutOptions:w,labelText:u,labelData:b,domId:i.db.lookUpDomId(o.id),width:null==x?void 0:x.width,height:null==x?void 0:x.height,type:o.type,el:v,parent:l.parentById[o.id]};m[k.id]=T}))),s}(I,t,x,v,i,P,u);const L=T.insert("g").attr("class","edges edgePath"),O=i.db.getEdges();u=$(O,i,u,T);Object.keys(m).forEach((e=>{const t=m[e];t.parent||u.children.push(t),void 0!==P.childrenById[e]&&(t.labels=[{text:t.labelText,layoutOptions:{"nodeLabels.placement":"[H_CENTER, V_TOP, INSIDE]"},width:t.labelData.width,height:t.labelData.height}],delete t.x,delete t.y,delete t.width,delete t.height)})),B(u.children,P),s.info("after layout",JSON.stringify(u,null,2));const j=await w.layout(u);E(0,0,j.children,T,D,i,0),s.info("after layout",j),null==(l=j.edges)||l.map((e=>{_(L,e,e.edgeData,i,P,t)})),c({},T,g.diagramPadding,g.useMaxWidth),p.remove()}},parser:t,styles:e=>`.label {\n    font-family: ${e.fontFamily};\n    color: ${e.nodeTextColor||e.textColor};\n  }\n  .cluster-label text {\n    fill: ${e.titleColor};\n  }\n  .cluster-label span {\n    color: ${e.titleColor};\n  }\n\n  .label text,span {\n    fill: ${e.nodeTextColor||e.textColor};\n    color: ${e.nodeTextColor||e.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${e.mainBkg};\n    stroke: ${e.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${e.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${e.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${e.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${e.edgeLabelBackground};\n    rect {\n      opacity: 0.85;\n      background-color: ${e.edgeLabelBackground};\n      fill: ${e.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${e.clusterBkg};\n    stroke: ${e.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${e.titleColor};\n  }\n\n  .cluster span {\n    color: ${e.titleColor};\n  }\n  /* .cluster div {\n    color: ${e.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${e.fontFamily};\n    font-size: 12px;\n    background: ${e.tertiaryColor};\n    border: 1px solid ${e.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${e.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n\n  .flowchart-label text {\n    text-anchor: middle;\n  }\n\n  ${(e=>{let t="";for(let o=0;o<5;o++)t+=`\n      .subgraph-lvl-${o} {\n        fill: ${e[`surface${o}`]};\n        stroke: ${e[`surfacePeer${o}`]};\n      }\n    `;return t})(e)}\n`};export{S as diagram};
//# sourceMappingURL=flowchart-elk-definition-4a651766.js.map
