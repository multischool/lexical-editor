{"version":3,"file":"index.js","sources":["../../../../node_modules/points-on-path/lib/index.js"],"sourcesContent":["import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n"],"names":["pointsOnPath","path","tolerance","distance","segments","parsePath","normalized","normalize","absolutize","sets","currentPoints","start","pendingCurve","appendPendingCurve","length","push","pointsOnBezierCurves","appendPendingPoints","key","data","lastPoint","out","set","simplifiedSet","simplify"],"mappings":"6SAEO,SAASA,EAAaC,EAAMC,EAAWC,GAC1C,MAAMC,EAAWC,EAAUJ,GACrBK,EAAaC,EAAUC,EAAWJ,IAClCK,EAAO,GACb,IAAIC,EAAgB,GAChBC,EAAQ,CAAC,EAAG,GACZC,EAAe,GACnB,MAAMC,EAAqB,KACnBD,EAAaE,QAAU,GACvBJ,EAAcK,QAAQC,EAAqBJ,EAAcV,IAE7DU,EAAe,EAAE,EAEfK,EAAsB,KACxBJ,IACIH,EAAcI,SACdL,EAAKM,KAAKL,GACVA,EAAgB,GACnB,EAEL,IAAK,MAAMQ,IAAEA,EAAGC,KAAEA,KAAUb,EACxB,OAAQY,GACJ,IAAK,IACDD,IACAN,EAAQ,CAACQ,EAAK,GAAIA,EAAK,IACvBT,EAAcK,KAAKJ,GACnB,MACJ,IAAK,IACDE,IACAH,EAAcK,KAAK,CAACI,EAAK,GAAIA,EAAK,KAClC,MACJ,IAAK,IACD,IAAKP,EAAaE,OAAQ,CACtB,MAAMM,EAAYV,EAAcI,OAASJ,EAAcA,EAAcI,OAAS,GAAKH,EACnFC,EAAaG,KAAK,CAACK,EAAU,GAAIA,EAAU,IAC9C,CACDR,EAAaG,KAAK,CAACI,EAAK,GAAIA,EAAK,KACjCP,EAAaG,KAAK,CAACI,EAAK,GAAIA,EAAK,KACjCP,EAAaG,KAAK,CAACI,EAAK,GAAIA,EAAK,KACjC,MACJ,IAAK,IACDN,IACAH,EAAcK,KAAK,CAACJ,EAAM,GAAIA,EAAM,KAKhD,GADAM,KACKd,EACD,OAAOM,EAEX,MAAMY,EAAM,GACZ,IAAK,MAAMC,KAAOb,EAAM,CACpB,MAAMc,EAAgBC,EAASF,EAAKnB,GAChCoB,EAAcT,QACdO,EAAIN,KAAKQ,EAEhB,CACD,OAAOF,CACX"}