{"version":3,"file":"Menu.jsx","sourceRoot":"","sources":["Menu.tsx"],"names":[],"mappings":"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","sourcesContent":["import { MenuTextMatch } from \"@lexical/react/LexicalTypeaheadMenuPlugin\";\nimport { $getSelection, $isRangeSelection, TextNode } from \"lexical\";\nimport { RefObject } from \"react\";\nimport { BeautifulMentionsItemData } from \"./BeautifulMentionsPluginProps\";\nimport { getTextContent } from \"./mention-utils\";\n\nexport class MenuOption {\n  /**\n   * Unique key to iterate over options. Equals to `data` if provided, otherwise\n   * `value` is used.\n   */\n  readonly key: string;\n  /**\n   * Ref to the DOM element of the option.\n   */\n  ref?: RefObject<HTMLElement | null>;\n\n  constructor(\n    /**\n     * The menu item value. For example: \"John\".\n     */\n    public readonly value: string,\n    /**\n     * The value to be displayed. Normally the same as `value` but can be\n     * used to display a different value. For example: \"Add 'John'\".\n     */\n    public readonly displayValue: string,\n    /**\n     * Additional data belonging to the option. For example: `{ id: 1 }`.\n     */\n    public readonly data?: Record<string, BeautifulMentionsItemData>,\n  ) {\n    this.key = !data ? value : JSON.stringify({ ...data, value });\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    this.displayValue = displayValue ?? value;\n    this.ref = { current: null };\n    this.setRefElement = this.setRefElement.bind(this);\n  }\n\n  setRefElement(element: HTMLElement | null) {\n    this.ref = { current: element };\n  }\n}\n\n/**\n * Split Lexical TextNode and return a new TextNode only containing matched text.\n * Common use cases include: removing the node, replacing with a new node.\n */\nexport function $splitNodeContainingQuery(\n  match: MenuTextMatch,\n): TextNode | null {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return null;\n  }\n  const anchor = selection.anchor;\n  if (anchor.type !== \"text\") {\n    return null;\n  }\n  const anchorNode = anchor.getNode();\n  if (!anchorNode.isSimpleText()) {\n    return null;\n  }\n  const selectionOffset = anchor.offset;\n  const textContent = getTextContent(anchorNode).slice(0, selectionOffset);\n  const characterOffset = match.replaceableString.length;\n  const queryOffset = getFullMatchOffset(\n    textContent,\n    match.matchingString,\n    characterOffset,\n  );\n  const startOffset = selectionOffset - queryOffset;\n  if (startOffset < 0) {\n    return null;\n  }\n  let newNode;\n  if (startOffset === 0) {\n    [newNode] = anchorNode.splitText(selectionOffset);\n  } else {\n    [, newNode] = anchorNode.splitText(startOffset, selectionOffset);\n  }\n  return newNode;\n}\n\n/**\n * Walk backwards along user input and forward through entity title to try\n * and replace more of the user's text with entity.\n */\nfunction getFullMatchOffset(\n  documentText: string,\n  entryText: string,\n  offset: number,\n): number {\n  let triggerOffset = offset;\n  for (let i = triggerOffset; i <= entryText.length; i++) {\n    if (documentText.substring(-i) === entryText.substring(0, i)) {\n      triggerOffset = i;\n    }\n  }\n  return triggerOffset;\n}\n"]}