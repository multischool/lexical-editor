{"version":3,"file":"doc-serialization.js","sourceRoot":"","sources":["doc-serialization.ts"],"names":[],"mappings":"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","sourcesContent":["import { SerializedDocument } from '@lexical/file'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function* generateReader<T = any>(\n  reader: ReadableStreamDefaultReader<T>\n) {\n  let done = false\n  while (!done) {\n    const res = await reader.read()\n    const { value } = res\n    if (value !== undefined) {\n      yield value\n    }\n    done = res.done\n  }\n}\n\nasync function readBytestoString(\n  reader: ReadableStreamDefaultReader\n): Promise<string> {\n  const output = []\n  const chunkSize = 0x8000\n  for await (const value of generateReader(reader)) {\n    for (let i = 0; i < value.length; i += chunkSize) {\n      output.push(String.fromCharCode(...value.subarray(i, i + chunkSize)))\n    }\n  }\n  return output.join('')\n}\n\nexport async function docToHash(doc: SerializedDocument): Promise<string> {\n  const cs = new CompressionStream('gzip')\n  const writer = cs.writable.getWriter()\n  const [, output] = await Promise.all([\n    writer\n      .write(new TextEncoder().encode(JSON.stringify(doc)))\n      .then(() => writer.close()),\n    readBytestoString(cs.readable.getReader()),\n  ])\n  return `#doc=${btoa(output)\n    .replace(/\\//g, '_')\n    .replace(/\\+/g, '-')\n    .replace(/=+$/, '')}`\n}\n\nexport async function docFromHash(\n  hash: string\n): Promise<SerializedDocument | null> {\n  const m = /^#doc=(.*)$/.exec(hash)\n  if (!m) {\n    return null\n  }\n  const ds = new DecompressionStream('gzip')\n  const writer = ds.writable.getWriter()\n  const b64 = atob(m[1].replace(/_/g, '/').replace(/-/g, '+'))\n  const array = new Uint8Array(b64.length)\n  for (let i = 0; i < b64.length; i++) {\n    array[i] = b64.charCodeAt(i)\n  }\n  const closed = writer.write(array).then(() => writer.close())\n  const output = []\n  for await (const chunk of generateReader(\n    ds.readable.pipeThrough(new TextDecoderStream()).getReader()\n  )) {\n    output.push(chunk)\n  }\n  await closed\n  return JSON.parse(output.join(''))\n}\n"]}