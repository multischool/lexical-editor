{"version":3,"file":"markdown-table-transformer.js","sourceRoot":"","sources":["markdown-table-transformer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAe,MAAM,SAAS,CAAA;AACpE,OAAO,EACL,0BAA0B,EAC1B,wBAAwB,EAExB,UAAU,EACV,oBAAoB,EACpB,8BAA8B,EAC9B,wBAAwB,EACxB,uBAAuB,GACxB,MAAM,mBAAmB,CAAA;AAC1B,OAAO,EACL,oBAAoB,EACpB,gBAAgB,EAChB,mBAAmB,EACnB,gBAAgB,EAChB,YAAY,EACZ,eAAe,EACf,qBAAqB,EACrB,aAAa,EACb,SAAS,EACT,YAAY,GACb,MAAM,gBAAgB,CAAA;AAEvB,OAAO,EAAE,KAAK,EAAE,MAAM,4CAA4C,CAAA;AAClE,OAAO,EAAE,QAAQ,EAAE,MAAM,+CAA+C,CAAA;AACxE,OAAO,EAAE,EAAE,EAAE,MAAM,yCAAyC,CAAA;AAC5D,OAAO,EAAE,KAAK,EAAE,MAAM,4CAA4C,CAAA;AAClE,OAAO,EAAE,KAAK,EAAE,MAAM,4CAA4C,CAAA;AAElE,6BAA6B;AAC7B,MAAM,iBAAiB,GAAG,uBAAuB,CAAA;AACjD,MAAM,yBAAyB,GAAG,wBAAwB,CAAA;AAE1D,MAAM,2BAA2B,GAAG;IAClC,EAAE;IACF,KAAK;IACL,KAAK;IACL,QAAQ;IACR,KAAK;IACL,UAAU;IACV,GAAG,oBAAoB;IACvB,GAAG,8BAA8B;IACjC,GAAG,wBAAwB;IAC3B,GAAG,uBAAuB;CAC3B,CAAA;AAED,MAAM,CAAC,MAAM,KAAK,GAAuB;IACvC,YAAY,EAAE,CAAC,SAAS,EAAE,YAAY,EAAE,aAAa,CAAC;IACtD,MAAM,EAAE,CAAC,IAAiB,EAAE,EAAE;QAC5B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACxB,OAAO,IAAI,CAAA;QACb,CAAC;QAED,MAAM,MAAM,GAAa,EAAE,CAAA;QAE3B,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC;YACrC,MAAM,SAAS,GAAG,EAAE,CAAA;YACpB,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC1B,SAAQ;YACV,CAAC;YAED,IAAI,WAAW,GAAG,KAAK,CAAA;YACvB,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,WAAW,EAAE,EAAE,CAAC;gBACrC,qDAAqD;gBACrD,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC3B,SAAS,CAAC,IAAI,CACZ,wBAAwB,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC,OAAO,CACjE,KAAK,EACL,KAAK,CACN,CACF,CAAA;oBACD,IAAI,IAAI,CAAC,aAAa,KAAK,qBAAqB,CAAC,GAAG,EAAE,CAAC;wBACrD,WAAW,GAAG,IAAI,CAAA;oBACpB,CAAC;gBACH,CAAC;YACH,CAAC;YAED,MAAM,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;YAC3C,IAAI,WAAW,EAAE,CAAC;gBAChB,MAAM,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;YAC/D,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC1B,CAAC;IACD,MAAM,EAAE,iBAAiB;IACzB,OAAO,EAAE,CAAC,UAAU,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE;QACjC,aAAa;QACb,IAAI,yBAAyB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAC7C,MAAM,KAAK,GAAG,UAAU,CAAC,kBAAkB,EAAE,CAAA;YAC7C,IAAI,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;gBACnC,OAAM;YACR,CAAC;YAED,MAAM,IAAI,GAAG,KAAK,CAAC,WAAW,EAAE,CAAA;YAChC,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;YACrC,IAAI,CAAC,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC1C,OAAM;YACR,CAAC;YAED,gCAAgC;YAChC,OAAO,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBACrC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC5B,OAAM;gBACR,CAAC;gBACD,IAAI,CAAC,eAAe,CAClB,qBAAqB,CAAC,GAAG,EACzB,qBAAqB,CAAC,GAAG,CAC1B,CAAA;YACH,CAAC,CAAC,CAAA;YAEF,cAAc;YACd,UAAU,CAAC,MAAM,EAAE,CAAA;YACnB,OAAM;QACR,CAAC;QAED,MAAM,UAAU,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;QAE5C,IAAI,UAAU,IAAI,IAAI,EAAE,CAAC;YACvB,OAAM;QACR,CAAC;QAED,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC,CAAA;QACzB,IAAI,OAAO,GAAG,UAAU,CAAC,kBAAkB,EAAE,CAAA;QAC7C,IAAI,QAAQ,GAAG,UAAU,CAAC,MAAM,CAAA;QAEhC,OAAO,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC/B,MAAK;YACP,CAAC;YAED,IAAI,OAAO,CAAC,eAAe,EAAE,KAAK,CAAC,EAAE,CAAC;gBACpC,MAAK;YACP,CAAC;YAED,MAAM,UAAU,GAAG,OAAO,CAAC,aAAa,EAAE,CAAA;YAE1C,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE,CAAC;gBAC7B,MAAK;YACP,CAAC;YAED,MAAM,KAAK,GAAG,eAAe,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,CAAA;YAE1D,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;gBAClB,MAAK;YACP,CAAC;YAED,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,CAAA;YAC3C,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;YACnB,MAAM,eAAe,GAAG,OAAO,CAAC,kBAAkB,EAAE,CAAA;YACpD,OAAO,CAAC,MAAM,EAAE,CAAA;YAChB,OAAO,GAAG,eAAe,CAAA;QAC3B,CAAC;QAED,MAAM,KAAK,GAAG,gBAAgB,EAAE,CAAA;QAEhC,KAAK,MAAM,KAAK,IAAI,IAAI,EAAE,CAAC;YACzB,MAAM,QAAQ,GAAG,mBAAmB,EAAE,CAAA;YACtC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;YAEtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE,CAAC;gBAClC,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAA;YACrE,CAAC;QACH,CAAC;QAED,MAAM,eAAe,GAAG,UAAU,CAAC,kBAAkB,EAAE,CAAA;QACvD,IACE,YAAY,CAAC,eAAe,CAAC;YAC7B,mBAAmB,CAAC,eAAe,CAAC,KAAK,QAAQ,EACjD,CAAC;YACD,eAAe,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,WAAW,EAAE,CAAC,CAAA;YAC9C,UAAU,CAAC,MAAM,EAAE,CAAA;QACrB,CAAC;aAAM,CAAC;YACN,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;QAC3B,CAAC;QAED,KAAK,CAAC,SAAS,EAAE,CAAA;IACnB,CAAC;IACD,IAAI,EAAE,SAAS;CAChB,CAAA;AAED,SAAS,mBAAmB,CAAC,KAAgB;IAC3C,MAAM,GAAG,GAAG,KAAK,CAAC,aAAa,EAAE,CAAA;IACjC,OAAO,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,CAAC,CAAA;AACzD,CAAC;AAED,MAAM,gBAAgB,GAAG,CAAC,WAAmB,EAAiB,EAAE;IAC9D,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;IAC/C,MAAM,IAAI,GAAG,oBAAoB,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAA;IAClE,0BAA0B,CAAC,WAAW,EAAE,2BAA2B,EAAE,IAAI,CAAC,CAAA;IAC1E,OAAO,IAAI,CAAA;AACb,CAAC,CAAA;AAED,MAAM,eAAe,GAAG,CAAC,WAAmB,EAA+B,EAAE;IAC3E,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAA;IAClD,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;QACxB,OAAO,IAAI,CAAA;IACb,CAAC;IACD,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAA;AAClE,CAAC,CAAA","sourcesContent":["import { $isParagraphNode, $isTextNode, LexicalNode } from 'lexical'\nimport {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n  ElementTransformer,\n  CHECK_LIST,\n  ELEMENT_TRANSFORMERS,\n  MULTILINE_ELEMENT_TRANSFORMERS,\n  TEXT_FORMAT_TRANSFORMERS,\n  TEXT_MATCH_TRANSFORMERS,\n} from '@lexical/markdown'\nimport {\n  $createTableCellNode,\n  $createTableNode,\n  $createTableRowNode,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  TableCellHeaderStates,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n} from '@lexical/table'\n\nimport { EMOJI } from '../transformers/markdown-emoji-transformer'\nimport { EQUATION } from '../transformers/markdown-equation-transofrmer'\nimport { HR } from '../transformers/markdown-hr-transformer'\nimport { IMAGE } from '../transformers/markdown-image-transformer'\nimport { TWEET } from '../transformers/markdown-tweet-transformer'\n\n// Very primitive table setup\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/\n\nconst OTHER_MARKDOWN_TRANSFORMERS = [\n  HR,\n  IMAGE,\n  EMOJI,\n  EQUATION,\n  TWEET,\n  CHECK_LIST,\n  ...ELEMENT_TRANSFORMERS,\n  ...MULTILINE_ELEMENT_TRANSFORMERS,\n  ...TEXT_FORMAT_TRANSFORMERS,\n  ...TEXT_MATCH_TRANSFORMERS,\n]\n\nexport const TABLE: ElementTransformer = {\n  dependencies: [TableNode, TableRowNode, TableCellNode],\n  export: (node: LexicalNode) => {\n    if (!$isTableNode(node)) {\n      return null\n    }\n\n    const output: string[] = []\n\n    for (const row of node.getChildren()) {\n      const rowOutput = []\n      if (!$isTableRowNode(row)) {\n        continue\n      }\n\n      let isHeaderRow = false\n      for (const cell of row.getChildren()) {\n        // It's TableCellNode so it's just to make flow happy\n        if ($isTableCellNode(cell)) {\n          rowOutput.push(\n            $convertToMarkdownString(OTHER_MARKDOWN_TRANSFORMERS, cell).replace(\n              /\\n/g,\n              '\\\\n'\n            )\n          )\n          if (cell.__headerState === TableCellHeaderStates.ROW) {\n            isHeaderRow = true\n          }\n        }\n      }\n\n      output.push(`| ${rowOutput.join(' | ')} |`)\n      if (isHeaderRow) {\n        output.push(`| ${rowOutput.map((_) => '---').join(' | ')} |`)\n      }\n    }\n\n    return output.join('\\n')\n  },\n  regExp: TABLE_ROW_REG_EXP,\n  replace: (parentNode, _1, match) => {\n    // Header row\n    if (TABLE_ROW_DIVIDER_REG_EXP.test(match[0])) {\n      const table = parentNode.getPreviousSibling()\n      if (!table || !$isTableNode(table)) {\n        return\n      }\n\n      const rows = table.getChildren()\n      const lastRow = rows[rows.length - 1]\n      if (!lastRow || !$isTableRowNode(lastRow)) {\n        return\n      }\n\n      // Add header state to row cells\n      lastRow.getChildren().forEach((cell) => {\n        if (!$isTableCellNode(cell)) {\n          return\n        }\n        cell.setHeaderStyles(\n          TableCellHeaderStates.ROW,\n          TableCellHeaderStates.ROW\n        )\n      })\n\n      // Remove line\n      parentNode.remove()\n      return\n    }\n\n    const matchCells = mapToTableCells(match[0])\n\n    if (matchCells == null) {\n      return\n    }\n\n    const rows = [matchCells]\n    let sibling = parentNode.getPreviousSibling()\n    let maxCells = matchCells.length\n\n    while (sibling) {\n      if (!$isParagraphNode(sibling)) {\n        break\n      }\n\n      if (sibling.getChildrenSize() !== 1) {\n        break\n      }\n\n      const firstChild = sibling.getFirstChild()\n\n      if (!$isTextNode(firstChild)) {\n        break\n      }\n\n      const cells = mapToTableCells(firstChild.getTextContent())\n\n      if (cells == null) {\n        break\n      }\n\n      maxCells = Math.max(maxCells, cells.length)\n      rows.unshift(cells)\n      const previousSibling = sibling.getPreviousSibling()\n      sibling.remove()\n      sibling = previousSibling\n    }\n\n    const table = $createTableNode()\n\n    for (const cells of rows) {\n      const tableRow = $createTableRowNode()\n      table.append(tableRow)\n\n      for (let i = 0; i < maxCells; i++) {\n        tableRow.append(i < cells.length ? cells[i] : $createTableCell(''))\n      }\n    }\n\n    const previousSibling = parentNode.getPreviousSibling()\n    if (\n      $isTableNode(previousSibling) &&\n      getTableColumnsSize(previousSibling) === maxCells\n    ) {\n      previousSibling.append(...table.getChildren())\n      parentNode.remove()\n    } else {\n      parentNode.replace(table)\n    }\n\n    table.selectEnd()\n  },\n  type: 'element',\n}\n\nfunction getTableColumnsSize(table: TableNode) {\n  const row = table.getFirstChild()\n  return $isTableRowNode(row) ? row.getChildrenSize() : 0\n}\n\nconst $createTableCell = (textContent: string): TableCellNode => {\n  textContent = textContent.replace(/\\\\n/g, '\\n')\n  const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS)\n  $convertFromMarkdownString(textContent, OTHER_MARKDOWN_TRANSFORMERS, cell)\n  return cell\n}\n\nconst mapToTableCells = (textContent: string): Array<TableCellNode> | null => {\n  const match = textContent.match(TABLE_ROW_REG_EXP)\n  if (!match || !match[1]) {\n    return null\n  }\n  return match[1].split('|').map((text) => $createTableCell(text))\n}\n"]}