{"version":3,"file":"mention-converter.js","sourceRoot":"","sources":["mention-converter.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  $createTextNode,\n  $getRoot,\n  $isElementNode,\n  $isTextNode,\n  LexicalNode,\n  TextNode,\n} from \"lexical\";\nimport { $createBeautifulMentionNode } from \"./MentionNode\";\nimport {\n  DEFAULT_PUNCTUATION,\n  LENGTH_LIMIT,\n  TRIGGERS,\n  VALID_CHARS,\n} from \"./mention-utils\";\n\ninterface MentionEntry {\n  type: \"mention\";\n  trigger: string;\n  value: string;\n}\n\ninterface TextEntry {\n  type: \"text\";\n  value: string;\n}\n\ntype Entry = MentionEntry | TextEntry;\n\nfunction findMentions(text: string, triggers: string[], punctuation: string) {\n  const regex = new RegExp(\n    \"(?<=\\\\s|^|\\\\()\" +\n      TRIGGERS(triggers) +\n      \"((?:\" +\n      VALID_CHARS(triggers, punctuation) +\n      \"){1,\" +\n      LENGTH_LIMIT +\n      \"})\",\n    \"g\",\n  );\n  const matches: { value: string; index: number }[] = [];\n  let match;\n  regex.lastIndex = 0;\n  while ((match = regex.exec(text)) !== null) {\n    matches.push({\n      value: match[0],\n      index: match.index,\n    });\n  }\n  return matches;\n}\n\nexport function convertToMentionEntries(\n  text: string,\n  triggers: string[],\n  punctuation: string,\n): Entry[] {\n  const matches = findMentions(text, triggers, punctuation);\n\n  const result: Entry[] = [];\n  let lastIndex = 0;\n\n  matches.forEach(({ value, index }) => {\n    // Add text before mention\n    if (index > lastIndex) {\n      const textBeforeMention = text.substring(lastIndex, index);\n      result.push({ type: \"text\", value: textBeforeMention });\n    }\n    // Add mention\n    const triggerRegExp = triggers.find((trigger) =>\n      new RegExp(trigger).test(value),\n    );\n\n    const match = triggerRegExp && new RegExp(triggerRegExp).exec(value);\n    if (!match) {\n      // should never happen since we only find mentions with the given triggers\n      throw new Error(\"No trigger found for mention\");\n    }\n    const trigger = match[0];\n\n    result.push({\n      type: \"mention\",\n      value: value.substring(trigger.length),\n      trigger,\n    });\n    // Update lastIndex\n    lastIndex = index + value.length;\n  });\n\n  // Add text after last mention\n  if (lastIndex < text.length) {\n    const textAfterMentions = text.substring(lastIndex);\n    result.push({ type: \"text\", value: textAfterMentions });\n  }\n\n  return result;\n}\n\n/**\n * Utility function that takes a string or a text nodes and converts it to a\n * list of mention and text nodes.\n *\n * ðŸš¨ Only works for mentions without spaces. Ensure spaces are disabled\n *  via the `allowSpaces` prop.\n */\nexport function $convertToMentionNodes(\n  textOrNode: string | TextNode,\n  triggers: string[],\n  punctuation = DEFAULT_PUNCTUATION,\n) {\n  const text =\n    typeof textOrNode === \"string\" ? textOrNode : textOrNode.getTextContent();\n  const entries = convertToMentionEntries(text, triggers, punctuation);\n  const nodes: LexicalNode[] = [];\n  for (const entry of entries) {\n    if (entry.type === \"text\") {\n      const textNode = $createTextNode(entry.value);\n      if (typeof textOrNode !== \"string\") {\n        textNode.setFormat(textOrNode.getFormat());\n      }\n      nodes.push(textNode);\n    } else {\n      nodes.push($createBeautifulMentionNode(entry.trigger, entry.value));\n    }\n  }\n  return nodes;\n}\n\n/**\n * Transforms text nodes containing mention strings into mention nodes.\n *\n *  ðŸš¨ Only works for mentions without spaces. Ensure spaces are disabled\n *  via the `allowSpaces` prop.\n */\nexport function $transformTextToMentionNodes(\n  triggers: string[],\n  punctuation = DEFAULT_PUNCTUATION,\n) {\n  const root = $getRoot();\n  const nodes = root.getChildren();\n\n  const traverseNodes = (nodes: LexicalNode[]) => {\n    for (const node of nodes) {\n      if ($isTextNode(node)) {\n        const newNodes = $convertToMentionNodes(node, triggers, punctuation);\n        if (newNodes.length > 1) {\n          const parent = node.getParent();\n          const index = node.getIndexWithinParent();\n          parent?.splice(index, 1, newNodes);\n        }\n      } else if ($isElementNode(node)) {\n        traverseNodes(node.getChildren());\n      }\n    }\n  };\n\n  traverseNodes(nodes);\n}\n"]}